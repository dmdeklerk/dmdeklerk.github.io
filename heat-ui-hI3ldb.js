var heat;
(function (heat) {
    heat.isTestnet = window.localStorage.getItem('testnet') == 'true';
    heat.isBetanet = window.localStorage.getItem('betanet') == 'true';
    function fullApplicationScopeReload() { }
    heat.fullApplicationScopeReload = fullApplicationScopeReload;
    var Loader = (function () {
        function Loader() {
            Loader.controller('AppController', ['$router', 'user', '$location', '$scope', '$rootScope',
                function ($router, user, $location, $scope, $rootScope) {
                    heat.$inject = angular.element(document).injector();
                    $router.config({ path: '/', redirectTo: '/login' });
                    function isUnlocked() {
                        if (!user.unlocked) {
                            if (!/\/p2pmessagingprobe.*/.test($location.path()) &&
                                !/\/trader.*/.test($location.path()) &&
                                !/\/explorer.*/.test($location.path()) &&
                                !/\/explore-account.*/.test($location.path())) {
                                if (!/\/login\/\w+/.test($location.path())) {
                                    $location.path('login');
                                }
                            }
                        }
                    }
                    isUnlocked();
                    $scope['userUnlocked'] = user.unlocked;
                    $rootScope['isTestnet'] = heat.isTestnet;
                    $rootScope.$on('$locationChangeSuccess', isUnlocked);
                    user.on(UserService.EVENT_UNLOCKED, function () {
                        $scope.$evalAsync(function () { $scope['userUnlocked'] = true; });
                    });
                    user.on(UserService.EVENT_LOCKED, function () {
                        $scope.$evalAsync(function () { $scope['userUnlocked'] = false; });
                    });
                    $scope['showApp'] = true;
                    heat.fullApplicationScopeReload = function () {
                        $scope.$evalAsync(function () {
                            $scope['showApp'] = false;
                            setTimeout(function () {
                                $scope.$evalAsync(function () {
                                    $scope['showApp'] = true;
                                });
                            }, 250);
                        });
                    };
                }]);
            this.init('heatApp', [
                'ngNewRouter',
                'ngAnimate',
                'ngMaterial',
                'ngMessages',
                'noCAPTCHA',
                'ngSanitize',
                'duScroll',
                'dc.inputAddOn',
                'jsonFormatter',
                'luegg.directives',
                'angular-popover',
                'ui.scroll', 'ui.scroll.grid'
            ]);
        }
        Loader.prototype.init = function (appName, externalModules) {
            var app = Loader.app = angular.module(appName, externalModules);
            angular.forEach(Loader.config_fn, function (v) { app.config(v); });
            angular.forEach(Loader.factory_fn, function (v) { app.factory(v.name, v.factory); });
            angular.forEach(Loader.directive_fn, function (v) { app.directive(v.name, v.factory); });
            angular.forEach(Loader.controller_fn, function (v) { app.controller(v.name, v.factory); });
            angular.forEach(Loader.run_fn, function (v) { app.run(v); });
            Loader.config_fn = null;
            Loader.run_fn = null;
            Loader.controller_fn = null;
            Loader.factory_fn = null;
            angular.bootstrap(document, [appName]);
        };
        Loader.config = function (array) { Loader.config_fn.push(array); };
        Loader.run = function (array) { Loader.run_fn.push(array); };
        Loader.controller = function (name, factory) {
            if (Loader.controller_fn)
                Loader.controller_fn.push({ name: name, factory: factory });
            else
                Loader.app.controller(name, factory);
        };
        Loader.factory = function (name, factory) {
            if (Loader.factory_fn)
                Loader.factory_fn.push({ name: name, factory: factory });
            else
                Loader.app.factory(name, factory);
        };
        Loader.directive = function (name, factory) {
            if (Loader.directive_fn)
                Loader.directive_fn.push({ name: name, factory: factory });
            else
                Loader.app.directive(name, factory);
        };
        Loader.config_fn = [];
        Loader.run_fn = [];
        Loader.controller_fn = [];
        Loader.factory_fn = [];
        Loader.directive_fn = [];
        return Loader;
    }());
    heat.Loader = Loader;
})(heat || (heat = {}));
heat.Loader.config(['$mdThemingProvider', 'noCAPTCHAProvider',
    function ($mdThemingProvider, noCAPTCHAProvider) {
        $mdThemingProvider.theme('default');
        noCAPTCHAProvider.setSiteKey("6Le7pBITAAAAANPHWrIsoP_ZvlxWr0bSjOPrlszc");
        noCAPTCHAProvider.setTheme('light');
    }]);
function Inject() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (target, key, index) {
        if (angular.isNumber(index)) {
            target.$inject = target.$inject || [];
            target.$inject[index] = args[0];
        }
        else {
            target.$inject = args;
        }
    };
}
function Component(options) {
    return function (target) {
        var d = {
            controller: target,
            controllerAs: 'vm',
            scope: {}
        };
        target.$$selector = options.selector;
        if (angular.isArray(options.styles)) {
            angular.forEach(options.styles, function (s) {
                angular.element(document).find('head').append("<style type=\"text/css\">" + s + "</style>");
            });
        }
        if (angular.isString(options.style)) {
            angular.element(document).find('head').append("<style type=\"text/css\">" + options.style + "</style>");
        }
        if (angular.isString(options.template)) {
            d['template'] = options.template;
        }
        if (angular.isArray(options.inputs)) {
            d['bindToController'] = {};
            options.inputs.forEach(function (input) {
                var bind = input.charAt(0) == '@' ? '@' : '=';
                if (bind == '@') {
                    input = input.substring(1);
                }
                d['bindToController'][input] = bind;
            });
            target.$$inputs = options.inputs;
        }
        if (angular.isArray(options.outputs)) {
            d['bindToController'] = d['bindToController'] || {};
            options.outputs.forEach(function (output) { return d['bindToController'][output] = '&'; });
        }
        if (angular.isFunction(options.link)) {
            d['link'] = options.link;
        }
        if (angular.isDefined(options.transclude)) {
            d['transclude'] = !!options.transclude;
        }
        if (angular.isDefined(options.replace)) {
            d['replace'] = !!options.replace;
        }
        heat.Loader.directive(options.selector, function () { return (d); });
    };
}
function Service(name) {
    return function (target) {
        var arr = target.$inject ? [].concat(target.$inject) : [];
        function F(args) {
            return target.apply(this, args);
        }
        F.prototype = target.prototype;
        arr.push(function () {
            return new F(arguments);
        });
        heat.Loader.factory(name, arr);
    };
}
function dashCase(str) {
    return str.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
}
function controllerNameFromPath(str) {
    return str.split('/')[1].split('-').map(function (s) { return s.charAt(0).toUpperCase() + s.slice(1); }).join('') + 'Controller';
}
function createControllerTemplate(selector, inputs) {
    var dashName = dashCase(selector);
    var t = [];
    t.push('<', dashName, ' ng-if="1" flex layout="column" layout-fill');
    angular.forEach(inputs, function (name) {
        t.push(' ', name, '="', selector, '.$$routeParams.', name, '"');
    });
    t.push('></', dashName, '>');
    return t.join('');
}
function createController(inputs) {
    Controller.$inject = ['$routeParams'];
    function Controller($routeParams) {
        this.$$routeParams = {};
        if (angular.isArray(inputs)) {
            for (var i = 0; i < inputs.length; i++) {
                this.$$routeParams[inputs[i]] = $routeParams[inputs[i]];
            }
        }
    }
    return Controller;
}
function RouteConfig() {
    var paths = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        paths[_i] = arguments[_i];
    }
    return function (target) {
        heat.Loader.controller(controllerNameFromPath(paths[0]), createController(target.$$inputs));
        heat.Loader.run(['$templateCache', '$router', function ($templateCache, $router) {
                var dashName = dashCase(target.$$selector);
                $templateCache.put('./components/' + dashName + '/' + dashName + '.html', createControllerTemplate(target.$$selector, target.$$inputs));
                angular.forEach(paths, function (p) { return $router.config({ path: p, component: target.$$selector }); });
            }]);
    };
}
var dialogs;
(function (dialogs) {
    function about($event) {
        var settings = heat.$inject.get('settings');
        dialogs.dialog({
            id: 'about',
            title: 'About',
            targetEvent: $event,
            template: "\n        <p>{{vm.applicationName}} {{vm.applicationVersion}}<br>Build: {{vm.applicationBuild}}</p>\n        <p>Embedded HEAT server {{vm.heatServerVersion}}</p>\n        <p><a href=\"#\" ng-click=\"vm.goTo('main')\">Go to MAIN NET</a></p>\n        <p><a href=\"#\" ng-click=\"vm.goTo('test')\">Go to TEST NET</a></p>\n        <p><a href=\"#\" ng-click=\"vm.goTo('beta')\">Go to BETA NET</a></p>\n        <br>\n        <p>Ethereum API <u>Powered by <a href=\"https://ethplorer.io\">Ethplorer.io</a></u></p>\n        <!--\n        <p><button onclick=\"gtag_report_conversion_signup(undefined)\">Signup Test</button></p>\n        <p><button onclick=\"gtag_report_conversion_bid(undefined, Date.now()+'')\">Bid Test</button></p>\n        <p><button onclick=\"gtag_report_conversion_signup_SECURE(undefined)\">Signup Test [SECURE]</button></p>\n        <p><button onclick=\"gtag_report_conversion_bid_SECURE(undefined, Date.now()+'')\">Bid Test [SECURE]</button></p>\n        -->\n\n      ",
            locals: {
                applicationName: settings.get(SettingsService.APPLICATION_NAME),
                applicationVersion: settings.get(SettingsService.APPLICATION_VERSION),
                applicationBuild: settings.get(SettingsService.APPLICATION_BUILD),
                heatServerVersion: SettingsService.EMBEDDED_HEATLEDGER_VERSION,
                isTestnet: window.localStorage.getItem('testnet') == 'true',
                goTo: function (net) {
                    window.localStorage.setItem('testnet', 'false');
                    window.localStorage.setItem('betanet', 'false');
                    if (net == 'test') {
                        window.localStorage.setItem('testnet', 'true');
                    }
                    else if (net == 'beta') {
                        window.localStorage.setItem('betanet', 'true');
                    }
                    window.location.reload();
                }
            }
        });
    }
    dialogs.about = about;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function assetInfo($event, info) {
        var assetInfoService = heat.$inject.get('assetInfo');
        var unsafeWarning = "This asset is operated by a third party.\nHeat Ledger has no control over the asset and does not provide support for it.\nIt's possible the asset does NOT represent what you think it does.\nPlease ensure from asset issuer that the asset is valid before purchasing it, as there may be no refunds or redemptions available.\nAsset purchases are non-refundable.";
        assetInfoService.getAssetDescription(info).then(function (description) {
            dialogs.dialog({
                id: 'assetInfo',
                title: 'Asset Info',
                targetEvent: $event,
                cancelButton: false,
                locals: {
                    description: description,
                    info: info,
                    unsafeWarning: unsafeWarning
                },
                template: "\n          <div layout=\"column\">\n            <span ng-if=\"!vm.info.certified\">{{vm.unsafeWarning}}<br><br></span>\n            <span><b>{{vm.info.symbol}}</b> {{vm.info.name}}</span>\n            <pre>{{vm.description}}</pre>\n          </div>\n        "
            });
        });
    }
    dialogs.assetInfo = assetInfo;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function blockDetails($event, blockId) {
        var $q = heat.$inject.get('$q');
        var heatApi = heat.$inject.get('heat');
        var deferred = $q.defer();
        heatApi.api.getBlock(blockId, true).then(function (response) {
            var sumofamounts = new Big("0");
            response.transactions.forEach(function (transaction) {
                sumofamounts = sumofamounts.add(new Big(transaction.amount));
            });
            dialogs.dialog({
                id: 'blockDetails',
                title: 'Block details',
                targetEvent: $event,
                cancelButton: false,
                locals: {
                    blockId: blockId,
                    height: response.height,
                    baseTarget: response.baseTarget,
                    numberOfTransactions: response.numberOfTransactions,
                    generator: response.generator,
                    posRewardHQT: response.posRewardHQT,
                    popRewardHQT: response.popRewardHQT,
                    sumofamounts: utils.commaFormat(utils.formatQNT(sumofamounts.toString(), 8)) + ' HEAT',
                    transactions: response.transactions,
                    showTransactionDetails: function ($event, transaction) {
                        dialogs.transactionDetails($event, transaction);
                    }
                },
                style: "\n         .dialog-block-details td {\n            padding: 8px;\n         }\n         .dialog-block-details ul {\n            list-style-type: none;\n            padding-left: 0px;\n            margin-left: 0px;\n         }\n         .dialog-block-details ul li {\n            padding-bottom: 5px;\n         }\n         .dialog-block-details .link-block {\n            cursor: pointer;\n            color: #3b5998;\n            text-decoration: underline;\n          }\n        ",
                template: "\n           <div layout=\"column\" class=\"dialog-block-details\">\n             <table>\n               <tr><td>Block id</td><td>{{vm.blockId}}</td></tr>\n               <tr><td>Block height</td><td>{{vm.height}}</td></tr>\n               <tr><td>Base target</td><td>{{vm.baseTarget}}</td></tr>\n               <tr><td>Number of transactions</td><td>{{vm.numberOfTransactions}}</td></tr>\n               <tr><td>Generator</td><td>{{vm.generator}}</td></tr>\n               <tr><td>POS reward</td><td>{{vm.posRewardHQT}}</td></tr>\n               <tr><td>POP reward</td><td>{{vm.popRewardHQT}}</td></tr>\n               <tr><td>Total HEAT transferred</td><td>{{vm.sumofamounts}}</td></tr>\n               <tr ng-if=\"vm.transactions.length\"><td>Transactions</td>\n                <td>\n                  <ul>\n                    <li ng-repeat=\"trans in vm.transactions\" ng-click=\"vm.showTransactionDetails($event, trans)\" class=\"link-block\">{{trans.transaction}}</li>\n                  </ul>\n                </td>\n               </tr>\n             </table>\n           </div>\n         "
            }).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    }
    dialogs.blockDetails = blockDetails;
})(dialogs || (dialogs = {}));
var QRCode;
var dialogs;
(function (dialogs) {
    function depositAsset($event, assetInfo) {
        var http = heat.$inject.get('http');
        var user = heat.$inject.get('user');
        var $q = heat.$inject.get('$q');
        var clipboard = heat.$inject.get('clipboard');
        var localKeyStore = heat.$inject.get('localKeyStore');
        var env = heat.$inject.get('env');
        var account = user.account, publicKey = user.publicKey;
        if (user.currency.symbol != 'HEAT') {
            account = localKeyStore.list()[0];
            publicKey = 'xx-yy-zz';
        }
        var url = "https://heatwallet.com/getaddr.cgi?heataccount=" + account + "&publickey=" + publicKey + "&aid=" + assetInfo.id;
        var deferred = $q.defer();
        http.get(url).then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            dialogs.dialog({
                id: 'depositAsset',
                title: "Deposit " + assetInfo.symbol,
                targetEvent: $event,
                okButton: true,
                style: "\n          .qrcodeBox {\n            margin:10px;\n          }\n        ",
                template: "\n          <div>\n            <p>{{vm.symbol}} Deposit address <b id=\"deposit-dialog-btc-address-element\">{{vm.address}}</b>&nbsp;<a ng-click=\"vm.copyAddress()\">[copy]</a></p>\n            <p><div class=\"qrcodeBox\" id=\"depositeAddressQRCode\"></div></p>\n            <p></p>\n            <p>\n              <div ng-bind-html=\"vm.dialogue\"></div>\n            </p>\n          </div>\n        ",
                locals: {
                    dialogue: parsed.deposit.dialogue,
                    isBtc: parsed.deposit.dialogue.includes('5592059897546023466'),
                    address: parsed.deposit.address,
                    shorQR: function () {
                        showQrCodeOnDialogLoad(parsed.deposit.address);
                    }(),
                    copyAddress: function () {
                        clipboard.copyWithUI(document.getElementById('deposit-dialog-btc-address-element'), 'Copied address to clipboard');
                    },
                    symbol: assetInfo.symbol
                }
            }).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    }
    dialogs.depositAsset = depositAsset;
    function showQrCodeOnDialogLoad(data) {
        setTimeout(function () {
            new QRCode("depositeAddressQRCode", {
                text: data,
                width: 128,
                height: 128,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.H
            });
        }, 1000);
    }
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function showEtherDepositDialog($event, address) {
        var clipboard = heat.$inject.get('clipboard');
        return dialogs.dialog({
            id: 'showEtherDepositDialog',
            title: "Deposit Ether",
            targetEvent: $event,
            cancelButton: false,
            okButton: true,
            locals: {
                userEtherWalletAddress: address,
                copyAddress: function () {
                    clipboard.copyWithUI(document.getElementById('deposit-dialog-eth-address-element'), 'Copied address to clipboard');
                }
            },
            template: "\n        <div layout=\"column\" flex>\n          Deposit the desired amount of Ether(ETH) to your Ethereum Address\n          <b id=\"deposit-dialog-eth-address-element\"> {{vm.userEtherWalletAddress}} </b>&nbsp;\n          <a ng-click=\"vm.copyAddress()\">[copy]</a>&nbsp;\n        </div>\n      "
        });
    }
    dialogs.showEtherDepositDialog = showEtherDepositDialog;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function $mdDialog() {
        return heat.$inject.get('$mdDialog');
    }
    dialogs.$mdDialog = $mdDialog;
    function dialog(options) {
        if (angular.isString(options.style)) {
            var styleId = 'dialog-style-' + options.id;
            if (!document.getElementById(styleId)) {
                angular.element(document).find('head').append("<style type=\"text/css\" id=\"" + styleId + "\">" + options.style + "</style>");
            }
        }
        return dialogs.$mdDialog().show({
            controller: options.controller || function () { },
            locals: angular.extend({
                isBetanet: heat.isBetanet,
                title: options.title,
                okButton: angular.isDefined(options.okButton) ? options.okButton : true,
                cancelButton: options.cancelButton,
                $mdDialog: dialogs.$mdDialog()
            }, options.locals || {}),
            controllerAs: 'vm',
            bindToController: true,
            parent: angular.element(document.body),
            targetEvent: options.targetEvent,
            template: "\n      <md-dialog>\n        <md-toolbar ng-if=\"vm.isBetanet\" style=\"background-color: #bf112f !important\">\n          <div class=\"md-toolbar-tools\">\n            <h2>B E T A N E T</h2>\n          </div>\n        </md-toolbar>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>{{vm.title}}</h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              " + options.template + "\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions layout=\"row\">\n            <span flex></span>\n            <md-button ng-if=\"vm.cancelButton\" class=\"md-warn\" ng-click=\"vm.cancelButtonClick ? vm.cancelButtonClick() : vm.$mdDialog.cancel()\" aria-label=\"Cancel\">Cancel</md-button>\n            <md-button ng-disabled=\"dialogForm.$invalid\" ng-if=\"vm.okButton\" class=\"md-primary\"\n              ng-click=\"vm.okButtonClick ? vm.okButtonClick() : vm.$mdDialog.hide()\" aria-label=\"OK\">{{vm.okButtonLabel?vm.okButtonLabel:'OK'}}</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      "
        });
    }
    dialogs.dialog = dialog;
    function wizard(options) {
        if (angular.isString(options.style)) {
            var styleId = 'wizard-style-' + options.id;
            if (!document.getElementById(styleId)) {
                angular.element(document).find('head').append("<style type=\"text/css\" id=\"" + styleId + "\">" + options.style + "</style>");
            }
        }
        return dialogs.$mdDialog().show({
            controller: options.controller || function () { },
            locals: angular.extend({
                title: options.title,
                cancelButton: options.cancelButton,
                $mdDialog: dialogs.$mdDialog(),
                pages: options.pages,
                wizardIndex: 0,
                goToNextPage: function () {
                    this.wizardIndex++;
                    if (angular.isFunction(this.pages[this.wizardIndex].show)) {
                        this.pages[this.wizardIndex].show(this, this.wizardIndex - 1);
                    }
                },
                goToPreviousPage: function () {
                    this.wizardIndex--;
                    if (angular.isFunction(this.pages[this.wizardIndex].show)) {
                        this.pages[this.wizardIndex].show(this, this.wizardIndex + 1);
                    }
                }
            }, options.locals || {}),
            controllerAs: 'vm',
            bindToController: true,
            parent: angular.element(document.body),
            targetEvent: options.targetEvent,
            template: "\n      <md-dialog>\n        <form name=\"dialogForm\">\n          <md-toolbar>\n            <div class=\"md-toolbar-tools\"><h2>{{vm.title}}<span ng-show=\"vm.pages[vm.wizardIndex].title\">{{vm.pages[vm.wizardIndex].title}}</span></h2></div>\n          </md-toolbar>\n          <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n              " + options.pages.map(function (page, index) {
                return "<div flex layout=\"column\" ng-if=\"vm.wizardIndex==" + index + "\">" +
                    page.template +
                    '</div>';
            }).join('') + "\n            </div>\n          </md-dialog-content>\n          <md-dialog-actions layout=\"row\">\n            <md-button ng-show=\"!vm.hideCancelBtn\"\n                ng-click=\"vm.cancelButtonClick ? vm.cancelButtonClick() : vm.$mdDialog.cancel()\" aria-label=\"Cancel\">Cancel</md-button>\n            <span flex></span>\n            <md-button ng-click=\"vm.goToPreviousPage()\"\n                ng-show=\"vm.wizardIndex>0 && !vm.hideBackBtn\" aria-label=\"Back\">Back</md-button>\n            <md-button ng-disabled=\"dialogForm.$invalid\"\n                ng-show=\"vm.wizardIndex < (vm.pages.length-1)\"\n                ng-click=\"vm.goToNextPage()\" aria-label=\"Continue\">{{vm.pages[vm.wizardIndex].continueBtnLabel||'Continue'}}</md-button>\n            <md-button ng-disabled=\"dialogForm.$invalid\"\n                ng-show=\"vm.wizardIndex == (vm.pages.length-1) && !vm.hideOkBtn\"\n                ng-click=\"vm.okButtonClick ? vm.okButtonClick() : vm.$mdDialog.hide()\" aria-label=\"Ok\">{{vm.pages[vm.wizardIndex].okBtnLabel||'Ok'}}</md-button>\n          </md-dialog-actions>\n        </form>\n      </md-dialog>\n      "
        });
    }
    dialogs.wizard = wizard;
    function confirm(title, content, mdDialog) {
        if (mdDialog) {
            mdDialog($mdDialog());
        }
        return dialogs.dialog({
            id: 'confirmDialog',
            title: title,
            okButton: true,
            cancelButton: true,
            locals: {
                content: content
            },
            template: "\n        <!--<md-input-container flex>-->\n        <p ng-bind-html=\"vm.content\"></p>\n        <!--</md-input-container>-->\n      "
        });
    }
    dialogs.confirm = confirm;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function download($event, account) {
        var $q = heat.$inject.get('$q');
        var heatApi = heat.$inject.get('heat');
        var $timeout = heat.$inject.get('$timeout');
        var $rootScope = heat.$inject.get('$rootScope');
        var settings = heat.$inject.get('settings');
        var assetInfo = heat.$inject.get('assetInfo');
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var locals = {
            transactions: {
                total: 0,
                array: [],
                percent: 0,
                done: false
            },
            trades: {
                total: 0,
                array: [],
                percent: 0,
                done: false
            },
            currencies: [],
            symbols: {}
        };
        heatApi.api.getTransactionsForAccountCount(account).then(function (count) {
            var scopes = [];
            for (var i = 0; i < count; i += 100) {
                scopes.push([i, i + 99]);
            }
            $rootScope.$evalAsync(function () {
                locals.transactions.total = count;
            });
            recursiveGetTransactions(account, scopes, function (transaction) {
                $rootScope.$evalAsync(function () {
                    if (transaction == null) {
                        locals.transactions.percent = 100;
                        locals.transactions.done = true;
                        done();
                    }
                    else {
                        locals.transactions.array.push(transaction);
                        locals.transactions.percent = Math.round(locals.transactions.array.length / (locals.transactions.total / 100));
                    }
                });
            });
        });
        heatApi.api.getAllAccountTradesCount(account).then(function (count) {
            var scopes = [];
            for (var i = 0; i < count; i += 100) {
                scopes.push([i, i + 99]);
            }
            $rootScope.$evalAsync(function () {
                locals.trades.total = count;
            });
            recursiveGetTrades(account, scopes, function (trade) {
                $rootScope.$evalAsync(function () {
                    if (trade == null) {
                        locals.trades.percent = 100;
                        locals.trades.done = true;
                        done();
                    }
                    else {
                        locals.trades.array.push(trade);
                        locals.trades.percent = Math.round(locals.trades.array.length / (locals.trades.total / 100));
                    }
                });
            });
        });
        function done() {
            if (locals.transactions.done && locals.trades.done) {
                console.log('duplicates', collectDuplicates(locals.transactions.array));
                var assets_1 = collectAssets(locals.transactions.array, locals.trades.array);
                getAssetSymbols(assets_1).then(function (symbols) {
                    $rootScope.$evalAsync(function () {
                        assets_1.forEach(function (asset) {
                            var symbol = symbols[asset].symbol;
                            locals.currencies.push({
                                id: asset,
                                symbol: symbol,
                                download: createDownloadFunction(asset, symbol)
                            });
                            locals.symbols[asset] = symbol;
                        });
                    });
                });
            }
        }
        function createDownloadFunction(currency, symbol) {
            return function () {
                var entries = [];
                locals.transactions.array.forEach(function (t) {
                    if (filterTransaction(currency, t))
                        entries.push(transactionToHistory(currency, t));
                });
                locals.trades.array.forEach(function (t) {
                    if (filterTrade(currency, t))
                        entries.push(tradeToHistory(currency, t));
                });
                entries.sort(function (a, b) { return a.timestamp - b.timestamp; });
                var csv = historyToCSV(entries);
                download(csv, account + '.' + symbol + '.csv');
            };
        }
        function collectAssets(transactions, trades) {
            var assets = { "0": 1 };
            transactions.forEach(function (transaction) {
                var type = transaction.type, subType = transaction.subtype;
                if (type == 2 && subType == 4 || type == 2 && subType == 3) {
                    assets[transaction.attachment.asset] = 1;
                    assets[transaction.attachment.currency] = 1;
                }
                if (type == 2 && subType == 2) {
                    assets[transaction.attachment.asset] = 1;
                }
            });
            trades.forEach(function (trade) {
                assets[trade.asset] = 1;
                assets[trade.currency] = 1;
            });
            return Object.getOwnPropertyNames(assets);
        }
        function collectDuplicates(transactions) {
            var dups = {};
            transactions.forEach(function (transaction) {
                if (typeof dups[transaction.transaction] == "number") {
                    dups[transaction.transaction]++;
                }
                else {
                    dups[transaction.transaction] = 1;
                }
            });
            var collect = {};
            Object.getOwnPropertyNames(dups).forEach(function (name) {
                if (dups[name] > 1) {
                    collect[name] = dups[name];
                }
            });
            return collect;
        }
        function getAssetSymbols(assets) {
            var promises = [];
            var data = {};
            assets.forEach(function (asset) {
                promises.push(assetInfo.getInfo(asset).then(function (info) {
                    data[asset] = info;
                }));
            });
            return Promise.all(promises).then(function () { return data; });
        }
        function filterTransaction($currency, transaction) {
            if ($currency == "0")
                return true;
            var type = transaction.type, subType = transaction.subtype;
            if (type == 2 && subType == 4 || type == 2 && subType == 3) {
                return transaction.attachment.asset == $currency || transaction.attachment.currency == $currency;
            }
            if (type == 2 && subType == 2) {
                return transaction.attachment.asset == $currency;
            }
        }
        function filterTrade($currency, trade) {
            return trade.currency == $currency || trade.asset == $currency;
        }
        function recursiveGetTransactions(account, scopes, reporter) {
            var scope = scopes.shift();
            if (!scope) {
                reporter(null);
                return;
            }
            var deferred = $q.defer();
            heatApi.api.getTransactionsForAccount(account, scope[0], scope[1]).then(function (transactions) {
                transactions.forEach(function (transaction) {
                    reporter(transaction);
                });
                $timeout(function () {
                    recursiveGetTransactions(account, scopes, reporter);
                });
            }).catch(deferred.reject);
            return deferred.promise;
        }
        function recursiveGetTrades(account, scopes, reporter) {
            var scope = scopes.shift();
            if (!scope) {
                reporter(null);
                return;
            }
            var deferred = $q.defer();
            heatApi.api.getAllAccountTrades(account, "0", 0, scope[0], scope[1]).then(function (trades) {
                trades.forEach(function (trade) {
                    reporter(trade);
                });
                $timeout(function () {
                    recursiveGetTrades(account, scopes, reporter);
                });
            }).catch(deferred.reject);
            return deferred.promise;
        }
        function transactionToHistory($currency, transaction) {
            var entry = {}, type = transaction.type, subType = transaction.subtype;
            entry.timestamp = transaction.timestamp;
            entry.ID = transaction.transaction;
            entry.TIME = dateFormat(utils.timestampToDate(transaction.timestamp), format);
            entry.TYPE = encodeTxType(type, subType);
            if (transaction.sender == account)
                entry.FEE = utils.formatQNT(transaction.fee, 8);
            else
                entry.FEE = "0";
            entry.MESSAGE = heatApi.getHeatMessageContents(transaction);
            entry.ACCOUNT = transaction.sender == account ? transaction.recipient : transaction.sender;
            entry.AMOUNT = '0';
            entry.ASSET = '';
            entry.PRICE = '';
            entry.TOTAL = '';
            if (type == 2 && subType == 4) {
                var total = utils.calculateTotalOrderPriceQNT(transaction.attachment.quantity, transaction.attachment.price);
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.asset == $currency ? transaction.attachment.asset : transaction.attachment.currency;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 2 && subType == 3) {
                var total = utils.calculateTotalOrderPriceQNT(transaction.attachment.quantity, transaction.attachment.price);
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.asset == $currency ? transaction.attachment.asset : transaction.attachment.currency;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 1 && subType == 0) {
            }
            else if (type == 0 && subType == 0) {
                entry.ASSET = "0";
                entry.ASSET_SYMBOL = "HEAT";
                if (transaction.sender == transaction.recipient)
                    entry.AMOUNT = "0";
                else if (transaction.recipient == account)
                    entry.AMOUNT = utils.formatQNT(transaction.amount, 8);
                else
                    entry.AMOUNT = "-" + utils.formatQNT(transaction.amount, 8);
            }
            else if (type == 2 && subType == 2) {
                entry.ASSET = transaction.attachment.asset;
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
                if (transaction.sender == transaction.recipient)
                    entry.AMOUNT = "0";
                else if (transaction.recipient == account)
                    entry.AMOUNT = utils.formatQNT(transaction.attachment.quantity, 8);
                else
                    entry.AMOUNT = "-" + utils.formatQNT(transaction.attachment.quantity, 8);
            }
            else if (type == 2 && subType == 6) {
                var quantity = transaction.attachment.cancelledOrderQuantity || "0";
                var price = transaction.attachment.cancelledOrderPrice || "0";
                var total = quantity != "0" && price != "0" ? utils.calculateTotalOrderPriceQNT(quantity, price) : "0";
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.cancelledOrderAsset ? (transaction.attachment.cancelledOrderAsset == $currency ? transaction.attachment.asset : transaction.attachment.currency) : '';
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 2 && subType == 5) {
                var quantity = transaction.attachment.cancelledOrderQuantity || "0";
                var price = transaction.attachment.cancelledOrderPrice || "0";
                var total = quantity != "0" && price != "0" ? utils.calculateTotalOrderPriceQNT(quantity, price) : "0";
                entry.PRICE = utils.formatQNT(transaction.attachment.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                entry.ASSET = transaction.attachment.cancelledOrderAsset ? (transaction.attachment.cancelledOrderAsset == $currency ? transaction.attachment.asset : transaction.attachment.currency) : '';
                entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            }
            else if (type == 4 && subType == 0) {
            }
            else if (type == 2 && subType == 0) {
                if (transaction.transaction == $currency) {
                    entry.AMOUNT = utils.formatQNT(transaction.attachment.quantity, 8);
                }
            }
            return entry;
        }
        function tradeToHistory($currency, trade) {
            var entry = {};
            entry.timestamp = trade.timestamp;
            entry.ID = trade.askOrder + "." + trade.bidOrder;
            entry.TYPE = 'Trade';
            entry.TIME = dateFormat(utils.timestampToDate(trade.timestamp), format);
            entry.ACCOUNT = trade.seller == account ? trade.buyer : trade.seller;
            entry.FEE = "0";
            entry.MESSAGE = '';
            entry.PRICE = '';
            entry.TOTAL = '';
            entry.ASSET = $currency;
            entry.ASSET_SYMBOL = locals.symbols[entry.ASSET];
            if (trade.seller == account && trade.buyer == account) {
                entry.AMOUNT = '0';
            }
            else {
                var total = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
                entry.PRICE = utils.formatQNT(trade.price, 8);
                entry.TOTAL = utils.formatQNT(total, 8);
                if (trade.currency == $currency) {
                    if (trade.buyer == account) {
                        entry.AMOUNT = '-' + utils.formatQNT(total, 8);
                    }
                    else {
                        entry.AMOUNT = utils.formatQNT(total, 8);
                    }
                }
                else {
                    if (trade.buyer == account) {
                        entry.AMOUNT = utils.formatQNT(trade.quantity, 8);
                    }
                    else {
                        entry.AMOUNT = '-' + utils.formatQNT(trade.quantity, 8);
                    }
                }
            }
            return entry;
        }
        function getSymbol(id) {
            return id;
        }
        function encodeTxType(type, subType) {
            if (type == 2 && subType == 4)
                return 'Buy order';
            if (type == 2 && subType == 3)
                return 'Sell order';
            if (type == 1 && subType == 0)
                return 'Message';
            if (type == 0 && subType == 0)
                return 'Transfer';
            if (type == 2 && subType == 2)
                return 'Transfer';
            if (type == 2 && subType == 6)
                return 'Cancel buy';
            if (type == 2 && subType == 5)
                return 'Cancel sell';
            if (type == 4 && subType == 0)
                return 'Balance lease';
            if (type == 2 && subType == 0)
                return 'Asset Issuance';
            return 'Other';
        }
        function removeCommas(str) {
            return str ? str.replace(/,/g, '') : '';
        }
        function historyToCSV(entries) {
            var buffer = [];
            buffer.push("ID,TIME,TYPE,ACCOUNT,ASSET,ASSET_SYMBOL,AMOUNT,PRICE,TOTAL,FEE,MESSAGE");
            entries.reverse();
            entries.forEach(function (history) {
                buffer.push([
                    JSON.stringify(history.ID),
                    history.TIME,
                    history.TYPE,
                    history.ACCOUNT,
                    history.ASSET,
                    history.ASSET_SYMBOL,
                    history.AMOUNT,
                    history.PRICE,
                    history.TOTAL,
                    history.FEE,
                    JSON.stringify(history.MESSAGE)
                ].map(function (x) { return removeCommas(x); }).join(','));
            });
            return buffer.join('\n');
        }
        function download(content, fileName) {
            var blob = new Blob([content], { type: "text/plain;charset=utf-8" });
            saveAs(blob, fileName);
        }
        return dialogs.dialog({
            id: 'download',
            title: 'Download account history (CSV)',
            targetEvent: $event,
            okButton: false,
            cancelButton: true,
            locals: locals,
            style: "\n        .dialog-download md-progress-linear {\n          margin-top: 8px !important;\n          margin-bottom: 8px !important;\n        }\n        .dialog-download .md-button {\n          text-align: left !important;\n          margin-left: 0px !important;\n          padding-left: 0px !important;\n        }\n      ",
            template: "\n        <div layout=\"column\" class=\"dialog-download\">\n          <div layout=\"row\">Transactions ({{vm.transactions.array.length}})</div>\n          <md-progress-linear md-mode=\"determinate\" ng-value=\"vm.transactions.percent\"></md-progress-linear>\n          <div layout=\"row\">Trades ({{vm.trades.array.length}})</div>\n          <md-progress-linear md-mode=\"determinate\" ng-value=\"vm.trades.percent\"></md-progress-linear>\n          <!--<div>\n            <p>Total Transactions: {{vm.transactions.total}}</p>\n            <p>Count Transactions: {{vm.transactions.array.length}}</p>\n            <p>Percent: {{vm.transactions.percent}}</p>\n            <p>Total Trades: {{vm.trades.total}}</p>\n            <p>Count Trades: {{vm.trades.array.length}}</p>\n            <p>Percent: {{vm.trades.percent}}</p>\n          </div>-->\n          <div>\n            <div ng-repeat=\"currency in vm.currencies\">\n              <md-button ng-click=\"currency.download()\">Download {{currency.symbol}}.csv</md-button> View\n            </div>\n          </div>\n        </div>\n      "
        });
    }
    dialogs.download = download;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function etherTransactionReceipt(status, message) {
        return dialogs.dialog({
            id: 'EtherTransactionReceipt',
            title: "Transaction Receipt",
            cancelButton: false,
            okButton: true,
            locals: {
                status: status,
                message: message
            },
            template: "\n        <h2>{{vm.status}}</h2><br>\n        <label ng-if=\"vm.status==='Success'\">Transaction hash is: {{vm.message}}</label>\n        <label ng-if=\"vm.status==='Error'\">{{vm.message}}</label>\n      "
        });
    }
    dialogs.etherTransactionReceipt = etherTransactionReceipt;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function jsonDetails($event, jsonObject, title) {
        return dialogs.dialog({
            id: 'jsonDetails',
            title: title,
            targetEvent: $event,
            cancelButton: false,
            locals: {
                jsonObject: jsonObject,
            },
            template: "\n        <div layout=\"column\" flex>\n          <json-formatter json=\"vm.jsonObject\" open=\"1\" class=\"json-formatter-dark\"></json-formatter>\n        </div>\n      "
        });
    }
    dialogs.jsonDetails = jsonDetails;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function prompt($event, title, description, defaultValue) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var locals = {
            v: {
                value: defaultValue || ''
            },
            description: description || '',
        };
        dialogs.dialog({
            id: 'prompt',
            title: title,
            targetEvent: $event,
            template: "\n        <p>{{vm.description}}</p>\n        <md-input-container flex>\n          <input type=\"password\" ng-model=\"vm.v.value\" autocomplete=\"off\"></input><br>\n        </md-input-container>\n      ",
            locals: locals
        }).then(function () {
            deferred.resolve(locals.v.value);
        }, deferred.reject);
        return deferred.promise;
    }
    dialogs.prompt = prompt;
    function alert($event, title, description) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var locals = {
            description: description || '',
        };
        dialogs.dialog({
            id: 'alert',
            title: title,
            targetEvent: $event,
            template: "\n        <p>{{vm.description}}</p>\n      ",
            locals: locals
        }).then(function () {
            deferred.resolve();
        }, deferred.reject);
        return deferred.promise;
    }
    dialogs.alert = alert;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function shutdown($event) {
        dialogs.dialog({
            id: 'shutdown',
            title: 'Shutting down',
            targetEvent: $event,
            okButton: false,
            template: "\n        <div layout=\"row\" layout-padding layout-align=center center\" flex>\n          <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n        </div>\n      "
        });
    }
    dialogs.shutdown = shutdown;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function textEditor(title, content, saveContentFunc) {
        dialogs.dialog({
            id: 'textEditor',
            title: title,
            okButton: false,
            cancelButton: false,
            locals: {
                save: function () {
                    saveContentFunc(this.content);
                    dialogs.$mdDialog().hide();
                },
                close: function () {
                    dialogs.$mdDialog().hide();
                },
                content: content
            },
            template: "\n        <!--<md-input-container flex>-->\n        <p>\n          <textarea rows=\"20\" ng-model=\"vm.content\" id=\"content-textarea\"></textarea>\n        </p>\n        <!--</md-input-container>-->\n        <div layout=\"row\" layout-align=\"center center\" style=\"min-height: 25px\">\n          <md-button class=\"md-primary\" ng-click=\"vm.save()\">Save</md-button>\n          <md-button class=\"md-primary\" ng-click=\"vm.close()\">Close</md-button>\n        </div>\n      ",
            style: "\n        #content-textarea {\n            width: 100%;\n        }\n      "
        });
    }
    dialogs.textEditor = textEditor;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function transactionDetails($event, transaction) {
        var settings = heat.$inject.get('settings');
        dialogs.dialog({
            id: 'transactionDetails',
            title: 'Transaction details',
            targetEvent: $event,
            cancelButton: false,
            locals: {
                date: dateFormat(utils.timestampToDate(transaction.timestamp), settings.get(SettingsService.DATEFORMAT_DEFAULT)),
                amount: utils.commaFormat(utils.convertToQNTf(transaction.amount.toString())) + ' HEAT',
                source: transaction.sender,
                destination: transaction.recipient,
                transactionId: transaction.transaction,
                confirmed: transaction.confirmations ? 'YES' : 'NO'
            },
            style: "\n        .dialog-transaction-details td {\n          padding: 8px;\n        }\n      ",
            template: "\n        <div layout=\"column\" class=\"dialog-transaction-details\">\n          <table>\n            <tr><td>Time</td><td>{{vm.date}}</td></tr>\n            <tr><td>Amount</td><td>{{vm.amount}}</td></tr>\n            <tr><td>Source</td><td>{{vm.source}}</td></tr>\n            <tr><td>Destination</td><td>{{vm.destination}}</td></tr>\n            <tr><td>Transaction ID</td><td>{{vm.transactionId}}</td></tr>\n            <tr><td>Confirmed</td><td>{{vm.confirmed}}</td></tr>\n          </table>\n        </div>\n      "
        });
    }
    dialogs.transactionDetails = transactionDetails;
})(dialogs || (dialogs = {}));
var dialogs;
(function (dialogs) {
    function withdraw(_to, _amount) {
        var lightwalletService = heat.$inject.get('lightwalletService');
        var user = heat.$inject.get('user');
        lightwalletService.sendEther(user.currency.address, _to, _amount);
        dialogs.$mdDialog().hide();
    }
    function withdrawEther($event) {
        return dialogs.dialog({
            id: 'withdrawEtherWallet',
            title: "Send Ether",
            targetEvent: $event,
            cancelButton: true,
            okButton: false,
            locals: {
                withdraw: withdraw,
                recipient: undefined,
                amount: undefined
            },
            style: "\n      .fee-button {\n        max-width:140px !important;\n      }\n    ",
            template: "\n        <md-input-container flex>\n          <input ng-model=\"vm.recipient\" name=\"recipient\" placeholder=\"Recipient address\" autocomplete=\"off\" required />\n        </md-input-container>\n        <md-input-container flex>\n          <input ng-model=\"vm.amount\" name=\"amount\" placeholder = \"Amount (in Wei)\" autocomplete=\"off\" required />\n        </md-input-container>\n        <md-button ng-click=\"0\" ng-disabled=\"true\" class=\"fee fee-button\">Fee: 0.000420 ETH</md-button>\n        <div layout=\"row\" layout-align=\"center center\" style=\"min-height: 25px\">\n          <md-button class=\"md-primary\" ng-disabled=\"!vm.amount || !vm.recipient\" ng-href=\"#/ethwallet\" ng-click=\"vm.withdraw(vm.recipient, vm.amount)\">Send</md-button>\n        </div>\n      "
        });
    }
    dialogs.withdrawEther = withdrawEther;
})(dialogs || (dialogs = {}));
var AbstractBatchViewerComponent = (function () {
    function AbstractBatchViewerComponent($scope, $q, $timeout) {
        this.$scope = $scope;
        this.$q = $q;
        this.$timeout = $timeout;
        this.batches = [];
        this.batchSize = 10;
    }
    AbstractBatchViewerComponent.prototype.clear = function () {
        this.batches = [];
    };
    AbstractBatchViewerComponent.prototype.getFirst = function () {
        return this.batches[0];
    };
    AbstractBatchViewerComponent.prototype.getLast = function () {
        return this.batches[this.batches.length - 1];
    };
    AbstractBatchViewerComponent.prototype.getFirstIndex = function () {
        return this.getLast().firstIndex;
    };
    AbstractBatchViewerComponent.prototype.getParentScope = function () {
        return this.$scope.$parent['vm'];
    };
    AbstractBatchViewerComponent.prototype.getBatch = function (index) {
        var deferred = this.$q.defer();
        if (angular.isDefined(this.batches[index])) {
            deferred.resolve(this.batches[index]);
        }
        else {
            this.getBatchInternal(index).then(deferred.resolve, deferred.reject);
        }
        return deferred.promise;
    };
    AbstractBatchViewerComponent.prototype.getBatchInternal = function (index) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.batches[index - 1])) {
            var previousFirstIndex = this.batches[index - 1].firstIndex;
            var firstIndex = Math.max(0, previousFirstIndex - this.batchSize);
            var lastIndex = previousFirstIndex - 1;
            this.getItems(firstIndex, lastIndex).then(function (items) {
                _this.batches[index] = new Batch(_this, items, firstIndex, lastIndex);
                deferred.resolve(_this.batches[index]);
            }, deferred.reject);
        }
        else {
            this.getCount().then(function (count) {
                var batchIndex = Math.floor(count / _this.batchSize);
                var firstIndex = batchIndex * _this.batchSize;
                var lastIndex = count;
                firstIndex = Math.max(0, firstIndex - _this.batchSize);
                _this.getItems(firstIndex, lastIndex).then(function (items) {
                    _this.batches[index] = new Batch(_this, items, firstIndex, lastIndex);
                    deferred.resolve(_this.batches[index]);
                }, deferred.reject);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AbstractBatchViewerComponent.prototype.scrollUp = function () {
        var _this = this;
        if (this.getFirstIndex() > 0) {
            var batchIndex = this.batches.length - 1;
            var topBatch = this.batches[batchIndex];
            var topEntryId = topBatch.getFirst().__id;
            var topEntryElement = angular.element(document.getElementById(topEntryId));
            this.$scope.$evalAsync(function () { _this.getParentScope().loading = true; });
            this.getBatch(batchIndex + 1).then(function () {
                _this.$scope.$evalAsync(function () {
                    _this.$timeout(0).then(function () {
                        _this.getScrollContainer().duScrollToElement(topEntryElement, 0, 0, null).then(function () {
                            _this.$scope.$evalAsync(function () {
                                _this.getParentScope().loading = false;
                                _this.$timeout(0).then(function () {
                                    var offset = _this.getScrollContainer()[0].clientHeight -
                                        topEntryElement[0].offsetHeight;
                                    _this.getScrollContainer().duScrollToElement(topEntryElement, offset, 1200, heat.easing.easeOutCubic);
                                });
                            });
                        });
                    });
                });
            });
        }
    };
    return AbstractBatchViewerComponent;
}());
var Batch = (function () {
    function Batch(viewer, entries, firstIndex, lastIndex) {
        this.viewer = viewer;
        this.entries = entries;
        this.firstIndex = firstIndex;
        this.lastIndex = lastIndex;
        entries.forEach(function (e) { e["__id"] = e["__id"] || "batch-entry-" + Batch.COUNTER++; });
    }
    Batch.prototype.loadMore = function () {
        var batch = this;
        var deferred = this.viewer.$q.defer();
        this.viewer.getCount().then(function (count) {
            if (count > batch.lastIndex) {
                batch.viewer.getItems(batch.lastIndex, count).then(function (items) {
                    items.forEach(function (item) {
                        item["__id"] = "batch-entry-" + Batch.COUNTER++;
                        batch.entries.push(item);
                        batch.lastIndex++;
                    });
                    deferred.resolve(items);
                }, deferred.reject);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    Batch.prototype.getFirst = function () {
        return this.entries[0];
    };
    Batch.prototype.getLast = function () {
        return this.entries[this.entries.length - 1];
    };
    Batch.COUNTER = 0;
    return Batch;
}());
var ArdorTransactionsProviderFactory = (function () {
    function ArdorTransactionsProviderFactory(http, $q, ardorBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
    }
    ArdorTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new ArdorTransactionsProvider(this.http, this.$q, this.ardorBlockExplorerService, account);
    };
    ArdorTransactionsProviderFactory = __decorate([
        Service('ardorTransactionsProviderFactory'),
        Inject('http', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, ArdorBlockExplorerService])
    ], ArdorTransactionsProviderFactory);
    return ArdorTransactionsProviderFactory;
}());
var ArdorTransactionsProvider = (function () {
    function ArdorTransactionsProvider(http, $q, ardorBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.account = account;
    }
    ArdorTransactionsProvider.prototype.destroy = function () { };
    ArdorTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.ardorBlockExplorerService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    ArdorTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.ardorBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return ArdorTransactionsProvider;
}());
var BtcTransactionsProviderFactory = (function () {
    function BtcTransactionsProviderFactory(http, $q, btcBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.btcBlockExplorerService = btcBlockExplorerService;
    }
    BtcTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new BtcTransactionsProvider(this.http, this.$q, this.btcBlockExplorerService, account);
    };
    BtcTransactionsProviderFactory = __decorate([
        Service('btcTransactionsProviderFactory'),
        Inject('http', '$q', 'btcBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, BtcBlockExplorerService])
    ], BtcTransactionsProviderFactory);
    return BtcTransactionsProviderFactory;
}());
var BtcTransactionsProvider = (function () {
    function BtcTransactionsProvider(http, $q, btcBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.account = account;
    }
    BtcTransactionsProvider.prototype.destroy = function () { };
    BtcTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.btcBlockExplorerService.getAddressInfo(this.account).then(function (result) {
            deferred.resolve(result.transactions.length);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    BtcTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.btcBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return BtcTransactionsProvider;
}());
var EthTransactionsProviderFactory = (function () {
    function EthTransactionsProviderFactory(http, $q, ethplorer, ethTransactionParser) {
        this.http = http;
        this.$q = $q;
        this.ethplorer = ethplorer;
        this.ethTransactionParser = ethTransactionParser;
    }
    EthTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new EthTransactionsProvider(this.http, this.$q, this.ethplorer, this.ethTransactionParser, account);
    };
    EthTransactionsProviderFactory = __decorate([
        Service('ethTransactionsProviderFactory'),
        Inject('http', '$q', 'ethplorer', 'ethTransactionParser'),
        __metadata("design:paramtypes", [HttpService, Function, EthplorerService,
            EthTransactionParserService])
    ], EthTransactionsProviderFactory);
    return EthTransactionsProviderFactory;
}());
var EthTransactionsProvider = (function () {
    function EthTransactionsProvider(http, $q, ethplorer, ethTransactionParser, account) {
        this.http = http;
        this.$q = $q;
        this.ethplorer = ethplorer;
        this.ethTransactionParser = ethTransactionParser;
        this.account = account;
        this.lastIndex = 0;
        this.paginator = ethplorer.createPaginator(account);
    }
    EthTransactionsProvider.prototype.destroy = function () { };
    EthTransactionsProvider.prototype.getPaginatedLength = function () {
        var _this = this;
        var deferred = this.$q.defer();
        this.paginator.getCount().then(function (count) {
            deferred.resolve(Math.min(_this.lastIndex + 40, count));
        }, deferred.reject);
        return deferred.promise;
    };
    EthTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var _this = this;
        var deferred = this.$q.defer();
        if (lastIndex > this.lastIndex) {
            this.lastIndex = lastIndex;
        }
        this.paginator.getItems(firstIndex, lastIndex).then(function (transactions) {
            deferred.resolve(_this.ethTransactionParser.parse(transactions));
        }, deferred.reject);
        return deferred.promise;
    };
    return EthTransactionsProvider;
}());
var ExplorerTradesProviderFactory = (function () {
    function ExplorerTradesProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    ExplorerTradesProviderFactory.prototype.createProvider = function (account) {
        return new TraProvider(this.heat, this.$q, account);
    };
    ExplorerTradesProviderFactory = __decorate([
        Service('explorerTradesProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], ExplorerTradesProviderFactory);
    return ExplorerTradesProviderFactory;
}());
var TraProvider = (function () {
    function TraProvider(heat, $q, account) {
        this.heat = heat;
        this.$q = $q;
        this.account = account;
    }
    TraProvider.prototype.destroy = function () { };
    TraProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.getAllAccountTradesCount(this.account);
    };
    TraProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.getAllAccountTrades(this.account, "0", 0, firstIndex, lastIndex);
    };
    return TraProvider;
}());
var FimkTransactionsProviderFactory = (function () {
    function FimkTransactionsProviderFactory(http, $q, mofoSocketService) {
        this.http = http;
        this.$q = $q;
        this.mofoSocketService = mofoSocketService;
    }
    FimkTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new FimkTransactionsProvider(this.http, this.$q, this.mofoSocketService, account);
    };
    FimkTransactionsProviderFactory = __decorate([
        Service('fimkTransactionsProviderFactory'),
        Inject('http', '$q', 'mofoSocketService'),
        __metadata("design:paramtypes", [HttpService, Function, MofoSocketService])
    ], FimkTransactionsProviderFactory);
    return FimkTransactionsProviderFactory;
}());
var FimkTransactionsProvider = (function () {
    function FimkTransactionsProvider(http, $q, mofoSocketService, account) {
        this.http = http;
        this.$q = $q;
        this.mofoSocketService = mofoSocketService;
        this.account = account;
    }
    FimkTransactionsProvider.prototype.destroy = function () { };
    FimkTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.mofoSocketService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    FimkTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var pageNum = 0;
        pageNum = (lastIndex / 15) - 1;
        return this.mofoSocketService.getTransactions(this.account, pageNum);
    };
    return FimkTransactionsProvider;
}());
var IotaTransactionsProviderFactory = (function () {
    function IotaTransactionsProviderFactory(http, $q, iotaBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
    }
    IotaTransactionsProviderFactory.prototype.createProvider = function (seed) {
        return new iotaTransactionsProvider(this.http, this.$q, this.iotaBlockExplorerService, seed);
    };
    IotaTransactionsProviderFactory = __decorate([
        Service('iotaTransactionsProviderFactory'),
        Inject('http', '$q', 'iotaBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, IotaBlockExplorerService])
    ], IotaTransactionsProviderFactory);
    return IotaTransactionsProviderFactory;
}());
var iotaTransactionsProvider = (function () {
    function iotaTransactionsProvider(http, $q, iotaBlockExplorerService, seed) {
        this.http = http;
        this.$q = $q;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
        this.seed = seed;
    }
    iotaTransactionsProvider.prototype.destroy = function () { };
    iotaTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.iotaBlockExplorerService.getAccountInfo(this.seed).then(function (result) {
            deferred.resolve(result.transfers.length);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    iotaTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.iotaBlockExplorerService.getAccountInfo(_this.seed).then(function (result) { return resolve(result.transfers); });
        });
    };
    return iotaTransactionsProvider;
}());
var LatestBlocksProviderFactory = (function () {
    function LatestBlocksProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    LatestBlocksProviderFactory.prototype.createProvider = function (blockObject, account) {
        return new LatestBlocksProvider(this.heat, this.$q, blockObject, account);
    };
    LatestBlocksProviderFactory = __decorate([
        Service('latestBlocksProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], LatestBlocksProviderFactory);
    return LatestBlocksProviderFactory;
}());
var LatestBlocksProvider = (function () {
    function LatestBlocksProvider(heat, $q, blockObject, account) {
        this.heat = heat;
        this.$q = $q;
        this.blockObject = blockObject;
        this.account = account;
    }
    LatestBlocksProvider.prototype.destroy = function () { };
    LatestBlocksProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        if (angular.isDefined(this.blockObject)) {
            deferred.resolve(1);
        }
        else {
            if (this.account) {
                this.heat.api.getAccountBlocksCount(this.account).then(function (count) {
                    deferred.resolve(count);
                }, deferred.reject);
            }
            else {
                this.heat.api.getBlockchainStatus().then(function (status) {
                    deferred.resolve(status.numberOfBlocks);
                }, deferred.reject);
            }
        }
        return deferred.promise;
    };
    LatestBlocksProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (angular.isDefined(this.blockObject)) {
            var deferred = this.$q.defer();
            deferred.resolve([this.blockObject]);
            return deferred.promise;
        }
        else {
            if (this.account) {
                return this.heat.api.getAccountBlocks(this.account, firstIndex, lastIndex);
            }
            else {
                return this.heat.api.getBlocks(firstIndex, lastIndex);
            }
        }
    };
    return LatestBlocksProvider;
}());
var NxtTransactionsProviderFactory = (function () {
    function NxtTransactionsProviderFactory(http, $q, nxtBlockExplorerService) {
        this.http = http;
        this.$q = $q;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
    }
    NxtTransactionsProviderFactory.prototype.createProvider = function (account) {
        return new NxtTransactionsProvider(this.http, this.$q, this.nxtBlockExplorerService, account);
    };
    NxtTransactionsProviderFactory = __decorate([
        Service('nxtTransactionsProviderFactory'),
        Inject('http', '$q', 'nxtBlockExplorerService'),
        __metadata("design:paramtypes", [HttpService, Function, NxtBlockExplorerService])
    ], NxtTransactionsProviderFactory);
    return NxtTransactionsProviderFactory;
}());
var NxtTransactionsProvider = (function () {
    function NxtTransactionsProvider(http, $q, nxtBlockExplorerService, account) {
        this.http = http;
        this.$q = $q;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
        this.account = account;
    }
    NxtTransactionsProvider.prototype.destroy = function () { };
    NxtTransactionsProvider.prototype.getPaginatedLength = function () {
        var deferred = this.$q.defer();
        this.nxtBlockExplorerService.getTransactionsCount(this.account).then(function (result) {
            deferred.resolve(result);
        }, function () {
            deferred.reject();
        });
        return deferred.promise;
    };
    NxtTransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.nxtBlockExplorerService.getTransactions(this.account, firstIndex, lastIndex);
    };
    return NxtTransactionsProvider;
}());
var TransactionsProviderFactory = (function () {
    function TransactionsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    TransactionsProviderFactory.prototype.createProvider = function (account, block, transactionObject) {
        return new TransactionsProvider(this.heat, this.$q, account, block, transactionObject);
    };
    TransactionsProviderFactory = __decorate([
        Service('transactionsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], TransactionsProviderFactory);
    return TransactionsProviderFactory;
}());
var TransactionsProvider = (function () {
    function TransactionsProvider(heat, $q, account, block, transactionObject) {
        this.heat = heat;
        this.$q = $q;
        this.account = account;
        this.block = block;
        this.transactionObject = transactionObject;
    }
    TransactionsProvider.prototype.destroy = function () { };
    TransactionsProvider.prototype.getPaginatedLength = function () {
        if (angular.isString(this.account)) {
            return this.heat.api.getTransactionsForAccountCount(this.account);
        }
        else if (angular.isString(this.block)) {
            return this.heat.api.getTransactionsForBlockCount(this.block);
        }
        else if (angular.isDefined(this.transactionObject)) {
            var deferred = this.$q.defer();
            deferred.resolve(1);
            return deferred.promise;
        }
        return this.heat.api.getTransactionsForAllCount();
    };
    TransactionsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (angular.isString(this.account)) {
            return this.heat.api.getTransactionsForAccount(this.account, firstIndex, lastIndex);
        }
        else if (angular.isString(this.block)) {
            return this.heat.api.getTransactionsForBlock(this.block, firstIndex, lastIndex);
        }
        else if (angular.isDefined(this.transactionObject)) {
            var deferred = this.$q.defer();
            deferred.resolve([this.transactionObject]);
            return deferred.promise;
        }
        return this.heat.api.getTransactionsForAll(firstIndex, lastIndex);
    };
    return TransactionsProvider;
}());
heat.Loader.directive("virtualRepeatFlexHelper", function () {
    return {
        restrict: 'A',
        require: '^mdVirtualRepeatContainer',
        link: function (scope, element, attributes, mdVirtualRepeatContainer) {
            var delay = 100;
            var maxDuration = 10 * 1000;
            var maxTries = maxDuration / delay;
            var tries = 0;
            var destroyed = false;
            scope.$on('$destroy', function () { destroyed = true; });
            utils.repeatWhile(100, function () {
                if (destroyed || (tries++) > maxTries)
                    return false;
                if (mdVirtualRepeatContainer.size > 0)
                    return true;
                mdVirtualRepeatContainer.updateSize();
                return false;
            });
        }
    };
});
var VirtualRepeatComponent = (function () {
    function VirtualRepeatComponent($scope, $q) {
        this.$scope = $scope;
        this.$q = $q;
        this.PAGE_SIZE = 20;
        this.loadedPages = {};
        this.numItems = -1;
        this.topIndex = 0;
        this.selected = null;
        this.loading = true;
    }
    VirtualRepeatComponent.prototype.initializeVirtualRepeat = function (provider, decorator, preprocessor) {
        this.provider = provider;
        this.decorator = decorator;
        this.preprocessor = preprocessor;
        return this.determineLength();
    };
    VirtualRepeatComponent.prototype.getItemAtIndex = function (index) {
        var pageNumber = Math.floor(index / this.PAGE_SIZE);
        var page = this.loadedPages[pageNumber];
        if (page) {
            var item = page[index % this.PAGE_SIZE];
            if (!this.selected) {
                this.selected = item;
            }
            return item;
        }
        else if (page !== null) {
            this.fetchPage(pageNumber);
        }
    };
    VirtualRepeatComponent.prototype.getLength = function () {
        return this.numItems;
    };
    VirtualRepeatComponent.prototype.determineLength = function (retain) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.provider) {
            this.loadedPages = {};
            this.provider.getPaginatedLength().then(function (length) {
                _this.numItems = length;
                if (length == 0) {
                    _this.$scope.$evalAsync(function () { _this.loading = false; });
                }
                deferred.resolve(length);
            }, deferred.reject);
        }
        else {
            deferred.reject();
        }
        return deferred.promise;
    };
    VirtualRepeatComponent.prototype.fetchPage = function (pageNumber) {
        var _this = this;
        this.loadedPages[pageNumber] = null;
        var firstIndex = pageNumber * this.PAGE_SIZE;
        var lastIndex = firstIndex + this.PAGE_SIZE;
        this.provider.getPaginatedResults(firstIndex, lastIndex).then(function (items) {
            _this.$scope.$evalAsync(function () { _this.loading = false; });
            if (_this.preprocessor) {
                if (angular.isArray(items)) {
                    _this.preprocessor(firstIndex, lastIndex, items);
                }
            }
            if (_this.decorator) {
                if (angular.isArray(items)) {
                    items.forEach(function (item) { _this.decorator(item, _this.loadedPages); });
                }
            }
            _this.loadedPages[pageNumber] = items;
        });
    };
    VirtualRepeatComponent.prototype.select = function (item) {
        this.selected = item;
        this.onSelect(item);
    };
    return VirtualRepeatComponent;
}());
var ApplicationSystemTimeComponent = (function () {
    function ApplicationSystemTimeComponent(settings, $scope, $interval) {
        var _this = this;
        this.settings = settings;
        this.$scope = $scope;
        this.time = '           ';
        var interval = $interval(function () { return _this.update(); }, 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
        this.update();
    }
    ApplicationSystemTimeComponent.prototype.update = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.time = dateFormat(new Date(), _this.settings.get(SettingsService.DATEFORMAT_DEFAULT));
        });
    };
    ApplicationSystemTimeComponent = __decorate([
        Component({
            selector: 'applicationSystemTime',
            template: "\n  <span>{{vm.time}}</span>\n  "
        }),
        Inject('settings', '$scope', '$interval'),
        __metadata("design:paramtypes", [SettingsService, Object, Function])
    ], ApplicationSystemTimeComponent);
    return ApplicationSystemTimeComponent;
}());
var CopyText = (function () {
    function CopyText(clipboard) {
        this.clipboard = clipboard;
    }
    CopyText.prototype.copy = function (element, successMsg) {
        this.clipboard.copyWithUI(document.getElementById(element), successMsg);
    };
    CopyText = __decorate([
        Component({
            selector: 'copyText',
            inputs: ['@elementId', '@message'],
            styles: ["\n    copy-text .clickable-icon {\n      cursor: pointer;\n    }\n  "],
            template: "\n    <md-icon md-font-library=\"material-icons\" ng-click=\"vm.copy(vm.elementId, vm.message)\" class=\"clickable-icon\">content_copy</md-icon>\n  "
        }),
        Inject('clipboard'),
        __metadata("design:paramtypes", [ClipboardService])
    ], CopyText);
    return CopyText;
}());
var DownloadingBlockchainComponent = (function () {
    function DownloadingBlockchainComponent($rootScope, $scope, heat, $interval, settings, router) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.heat = heat;
        this.$interval = $interval;
        this.settings = settings;
        this.router = router;
        this.showComponent = false;
        this.lastBlockHeight = 0;
        this.lastBlockTime = 0;
        this.refresh();
        var interval = $interval(function () { _this.refresh(); }, 60 * 1000, 0, false);
        var checkServerHealthInterval = $interval(function () { _this.checkServerHealth(_this.settings); }, 33 * 1000, 0, false);
        $scope.$on('$destroy', function () {
            $interval.cancel(interval);
            $interval.cancel(checkServerHealthInterval);
        });
        setTimeout(function () {
            if (SettingsService.getFailoverDescriptor())
                _this.checkServerHealth(_this.settings, true);
            else
                setTimeout(function () {
                    _this.checkServerHealth(_this.settings, true);
                }, 500);
        }, 200);
    }
    DownloadingBlockchainComponent.prototype.refresh = function () {
        var _this = this;
        this.heat.api.getBlockchainStatus().then(function (status) {
            _this.$scope.$evalAsync(function () {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                var date = utils.timestampToDate(status.lastBlockTimestamp);
                _this.lastBlockTime = dateFormat(date, format);
                _this.lastBlockHeight = status.numberOfBlocks;
                if ((Date.now() - date.getTime()) > 1000 * 60 * 60) {
                    _this.showComponent = true;
                }
                else {
                    _this.showComponent = false;
                }
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.showComponent = false;
            });
        });
    };
    DownloadingBlockchainComponent.prototype.checkServerHealth = function (settings, firstTime) {
        var _this = this;
        var knownServers = SettingsService.getFailoverDescriptor().knownServers || [];
        var currentServerHealth;
        var promises = [];
        knownServers.forEach(function (server) {
            promises.push(_this.heat.api.getServerHealth(server.host, server.port).then(function (health) {
                server.health = health;
                server.statusError = null;
            }).catch(function (err) {
                server.health = null;
                server.statusError = err;
                return err;
            }));
        });
        var minEqualityServersNumber = heat.isTestnet ? 3 : 10;
        Promise.all(promises).then(function () {
            var currentServerIsAlive = false;
            var currentServer = null;
            knownServers.forEach(function (server) {
                var health = server.health;
                server.statusScore = null;
                if (health)
                    server.statusScore = 0;
                if (server.host == settings.get(SettingsService.HEAT_HOST) && server.port == settings.get(SettingsService.HEAT_PORT)) {
                    currentServerHealth = health;
                    currentServer = server;
                    if (!_this.heatServerLocation)
                        _this.notifyOnServerLocationUpdating(currentServer);
                    currentServerIsAlive = !server.statusError;
                    server.statusScore = currentServerIsAlive ? 0 : null;
                }
            });
            if (!currentServer)
                return;
            if (currentServerIsAlive && !currentServerHealth)
                return;
            knownServers.forEach(function (server) {
                var health = server.health;
                if (!health || !currentServerHealth || !(health.balancesEquality[1] >= minEqualityServersNumber))
                    return;
                var blocksEstimation = _this.calculateBlockchainEstimation(currentServerHealth, health);
                var balancesEqualityEstimation = _this.calculateBalancesEqualityEstimation(currentServerHealth, health);
                var peerEstimation = _this.calculatePeerEstimation(currentServerHealth, health);
                server.statusScore = (blocksEstimation == 1 && balancesEqualityEstimation >= 0 && peerEstimation >= 0)
                    ? blocksEstimation + balancesEqualityEstimation + peerEstimation
                    : 0;
            });
            var best = currentServer;
            var causeToSelectBest;
            knownServers.forEach(function (server) {
                if (best == currentServer && !currentServerIsAlive) {
                    best = server;
                    var se = currentServer.statusError;
                    causeToSelectBest = "urrent server is not alive"
                        + (se.code ? ". Code: " + se.code : "") + (se.description ? ". Description: " + se.description : "");
                }
                if (server.statusScore >= 0 || !currentServerIsAlive) {
                    if ((server.statusScore != null && best.statusScore == null) || server.statusScore > best.statusScore) {
                        best = server;
                        causeToSelectBest = "Status score is better";
                    }
                    if (server.statusScore == best.statusScore && server.priority < best.priority && best != currentServer) {
                        best = server;
                        causeToSelectBest = "Server priority";
                    }
                }
            });
            if (best && best != currentServer) {
                var bestIsAlive = !best.statusError;
                if (bestIsAlive) {
                    settings.setCurrentServer(best);
                    _this.notifyOnServerLocationUpdating(best);
                    _this.heat.resetSubscriber();
                    if (firstTime) {
                        _this.router.navigate('/login');
                    }
                    else {
                        var message = currentServer
                            ? "Client API address switched from \n" + currentServer.host + ":" + currentServer.port
                                + "\nto\n" + best.host + ":" + best.port
                            : "Client API address switched to\n" + best.host + ":" + best.port;
                        if (causeToSelectBest)
                            message = message + " \n\n" + "Reason: " + causeToSelectBest;
                        alert(message);
                    }
                }
            }
        });
    };
    DownloadingBlockchainComponent.prototype.calculateBlockchainEstimation = function (currentServerHealth, health) {
        var cumulativeDifficulty = new BigInteger(health.cumulativeDifficulty);
        var difficultyDelta = cumulativeDifficulty.compareTo(new BigInteger(currentServerHealth.cumulativeDifficulty));
        var threshold = SettingsService.getFailoverDescriptor().heightDeltaThreshold;
        if (Math.abs(health.lastBlockHeight - currentServerHealth.lastBlockHeight) > threshold) {
            if (difficultyDelta > 0)
                return 1;
            if (difficultyDelta < 0)
                return -1;
        }
        return 0;
    };
    DownloadingBlockchainComponent.prototype.calculateBalancesEqualityEstimation = function (currentServerHealth, health) {
        var mismatches = health.balancesEquality[0] / health.balancesEquality[1];
        var currentServerMismatches = currentServerHealth.balancesEquality[0] / currentServerHealth.balancesEquality[1];
        var mismatchesThreshold = SettingsService.getFailoverDescriptor().balancesMismatchesThreshold;
        var equalityThreshold = SettingsService.getFailoverDescriptor().balancesEqualityThreshold;
        return (mismatches < mismatchesThreshold * currentServerMismatches
            && health.balancesEquality[2] > equalityThreshold * currentServerHealth.balancesEquality[2])
            ? 1
            : (mismatches > currentServerMismatches || health.balancesEquality[2] < 0.7 * currentServerHealth.balancesEquality[2])
                ? -1
                : 0;
    };
    DownloadingBlockchainComponent.prototype.calculatePeerEstimation = function (currentServerHealth, health) {
        var connected = health.peersIndicator.connected / health.peersIndicator.all;
        var currentServerConnected = currentServerHealth.peersIndicator.connected / currentServerHealth.peersIndicator.all;
        var threshold = SettingsService.getFailoverDescriptor().connectedPeersThreshold;
        return (threshold * connected > currentServerConnected)
            ? 1
            : (connected < 0.8 * currentServerConnected)
                ? -1
                : 0;
    };
    DownloadingBlockchainComponent.prototype.notifyOnServerLocationUpdating = function (sd) {
        this.heatServerLocation = sd.host + ":" + sd.port;
        this.$rootScope.$emit('HEAT_SERVER_LOCATION', this.heatServerLocation);
    };
    DownloadingBlockchainComponent = __decorate([
        Component({
            selector: 'downloadingBlockchain',
            template: "\n    <div layout=\"column\" flex layout-fill ng-show=\"vm.showComponent\">\n      <md-progress-linear md-mode=\"indeterminate\"></md-progress-linear>\n      <center><div><b>Attention!!</b></div>\n      <div>Downloading blockchain last block height: {{vm.lastBlockHeight}}, time {{vm.lastBlockTime}}</div></center>\n    </div>\n  "
        }),
        Inject('$rootScope', '$scope', 'heat', '$interval', 'settings', '$router'),
        __metadata("design:paramtypes", [Object, Object, HeatService, Function, SettingsService, Object])
    ], DownloadingBlockchainComponent);
    return DownloadingBlockchainComponent;
}());
var ElipsesLoadingComponent = (function () {
    function ElipsesLoadingComponent() {
    }
    ElipsesLoadingComponent = __decorate([
        Component({
            selector: 'elipsesLoading',
            styles: ["\n    .elipses-loading-one {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.0s;\n        animation: elipses-loading-dot 1.3s infinite;\n        animation-delay: 0.0s;\n    }\n\n    .elipses-loading-two {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.2s;\n          animation: elipses-loading-dot 1.3s infinite;\n          animation-delay: 0.2s;\n    }\n\n    .elipses-loading-three {\n        opacity: 0;\n        -webkit-animation: elipses-loading-dot 1.3s infinite;\n        -webkit-animation-delay: 0.3s;\n        animation: elipses-loading-dot 1.3s infinite;\n        animation-delay: 0.3s;\n    }\n\n    @-webkit-keyframes elipses-loading-dot {\n          0% { opacity: 0; }\n        50% { opacity: 0; }\n        100% { opacity: 1; }\n    }\n\n    @keyframes elipses-loading-dot {\n          0% { opacity: 0; }\n        50% { opacity: 0; }\n        100% { opacity: 1; }\n    }\n  "],
            template: "\n  <span class=\"elipses-loading-one\">.</span><span class=\"elipses-loading-two\">.</span><span class=\"elipses-loading-three\">.</span>\n  "
        })
    ], ElipsesLoadingComponent);
    return ElipsesLoadingComponent;
}());
var Timestamp = (function () {
    function Timestamp(settings, $scope) {
        var _this = this;
        this.settings = settings;
        $scope.$watch(function () { return _this.timestampValue; }, function () { _this.update(); });
        this.update();
    }
    Timestamp.prototype.update = function () {
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var date = utils.timestampToDate(parseInt(this.timestampValue));
        this.timestampFormatted = this.timestampValue != "0" ? dateFormat(date, format) : "GENESIS";
    };
    Timestamp = __decorate([
        Component({
            selector: 'timestamp',
            inputs: ['timestampValue'],
            template: "\n    <span>{{ vm.timestampFormatted }}</span>\n  "
        }),
        Inject('settings', '$scope'),
        __metadata("design:paramtypes", [SettingsService, Object])
    ], Timestamp);
    return Timestamp;
}());
var TransactionVerificationError = (function () {
    function TransactionVerificationError(name, expected, actual) {
        this.name = name;
        this.expected = expected;
        this.actual = actual;
    }
    return TransactionVerificationError;
}());
var Appendix = (function () {
    function Appendix(bytes) {
        this.version = bytes.byteArray[bytes.pos];
        bytes.pos++;
    }
    return Appendix;
}());
var AppendixMessage = (function (_super) {
    __extends(AppendixMessage, _super);
    function AppendixMessage(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.isText = length < 0;
        if (length < 0) {
            length &= 2147483647;
        }
        if (_this.isText) {
            _this.message = converters.byteArrayToString(bytes.byteArray, bytes.pos, length);
        }
        else {
            var slice = bytes.byteArray.slice(bytes.pos, bytes.pos + length);
            _this.message = converters.byteArrayToHexString(slice);
        }
        bytes.pos += length;
        return _this;
    }
    return AppendixMessage;
}(Appendix));
var AbstractEncryptedMessage = (function (_super) {
    __extends(AbstractEncryptedMessage, _super);
    function AbstractEncryptedMessage(bytes, data) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.isText = length < 0;
        if (length < 0) {
            length &= 2147483647;
        }
        _this.encryptedMessageData = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        _this.encryptedMessageNonce = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 32));
        bytes.pos += 32;
        return _this;
    }
    return AbstractEncryptedMessage;
}(Appendix));
var AppendixEncryptedMessage = (function (_super) {
    __extends(AppendixEncryptedMessage, _super);
    function AppendixEncryptedMessage(bytes) {
        return _super.call(this, bytes, null) || this;
    }
    return AppendixEncryptedMessage;
}(AbstractEncryptedMessage));
var AppendixPublicKeyAnnouncement = (function (_super) {
    __extends(AppendixPublicKeyAnnouncement, _super);
    function AppendixPublicKeyAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.publicKey = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 32));
        bytes.pos += 32;
        return _this;
    }
    return AppendixPublicKeyAnnouncement;
}(Appendix));
var AppendixEncryptToSelfMessage = (function (_super) {
    __extends(AppendixEncryptToSelfMessage, _super);
    function AppendixEncryptToSelfMessage(bytes) {
        return _super.call(this, bytes, null) || this;
    }
    return AppendixEncryptToSelfMessage;
}(AbstractEncryptedMessage));
var AppendixPrivateNameAnnouncement = (function (_super) {
    __extends(AppendixPrivateNameAnnouncement, _super);
    function AppendixPrivateNameAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.privateNameAnnouncement = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return _this;
    }
    return AppendixPrivateNameAnnouncement;
}(Appendix));
var AppendixPrivateNameAssignment = (function (_super) {
    __extends(AppendixPrivateNameAssignment, _super);
    function AppendixPrivateNameAssignment(bytes) {
        var _this = _super.call(this, bytes) || this;
        _this.privateNameAssignment = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        _this.signature = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 64));
        bytes.pos += 64;
        return _this;
    }
    return AppendixPrivateNameAssignment;
}(Appendix));
var AppendixPublicNameAnnouncement = (function (_super) {
    __extends(AppendixPublicNameAnnouncement, _super);
    function AppendixPublicNameAnnouncement(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.publicNameAnnouncement = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        return _this;
    }
    return AppendixPublicNameAnnouncement;
}(Appendix));
var AppendixPublicNameAssignment = (function (_super) {
    __extends(AppendixPublicNameAssignment, _super);
    function AppendixPublicNameAssignment(bytes) {
        var _this = _super.call(this, bytes) || this;
        var length = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        _this.publicNameAssignment = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + length));
        bytes.pos += length;
        _this.signature = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 64));
        bytes.pos += 64;
        return _this;
    }
    return AppendixPublicNameAssignment;
}(Appendix));
var AbstractTransaction = (function () {
    function AbstractTransaction() {
    }
    AbstractTransaction.prototype.confirm = function (name, expected, actual) {
        if (expected != actual) {
            throw new TransactionVerificationError(name, expected, actual);
        }
    };
    AbstractTransaction.prototype.verifyAndSignTransactionBytes = function (transactionBytes, signature, data) {
        var transaction = {};
        var byteArray = converters.hexStringToByteArray(transactionBytes);
        transaction.type = byteArray[0];
        transaction.version = (byteArray[1] & 0xF0) >> 4;
        transaction.subtype = byteArray[1] & 0x0F;
        transaction.timestamp = converters.byteArrayToSignedInt32(byteArray, 2);
        transaction.deadline = converters.byteArrayToSignedShort(byteArray, 6);
        this.confirm("deadline", data.deadline, transaction.deadline);
        transaction.senderPublicKey = converters.byteArrayToHexString(byteArray.slice(8, 40));
        this.confirm("senderPublicKey", data.publicKey, transaction.senderPublicKey);
        transaction.recipient = String(converters.byteArrayToBigInteger(byteArray, 40));
        if (data.recipient)
            this.confirm("recipient", data.recipient, transaction.recipient);
        else {
            if (data.recipientPublicKey)
                this.confirm("recipientPublicKey", heat.crypto.getAccountIdFromPublicKey(data.recipientPublicKey), transaction.recipient);
            else
                this.confirm("recipient", "8150091319858025343", transaction.recipient);
        }
        transaction.amount = String(converters.byteArrayToBigInteger(byteArray, 48));
        if (data.OrdinaryPayment)
            this.confirm("amount", data.OrdinaryPayment.amountHQT, transaction.amount);
        else
            this.confirm("amount", "0", transaction.amount);
        transaction.fee = String(converters.byteArrayToBigInteger(byteArray, 56));
        this.confirm("fee", data.fee, transaction.fee);
        transaction.signature = converters.byteArrayToHexString(byteArray.slice(64, 128));
        transaction.flags = converters.byteArrayToSignedInt32(byteArray, 128);
        transaction.ecBlockHeight = converters.byteArrayToSignedInt32(byteArray, 132);
        transaction.ecBlockId = String(converters.byteArrayToBigInteger(byteArray, 136));
        var pos = 144;
        pos++;
        var bytes = {
            byteArray: byteArray,
            pos: pos
        };
        if (!this.verify(transaction, bytes, data)) {
            return;
        }
        var position = 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixMessage(bytes);
            this.confirm("Message.message", data.message, appendix.message);
            this.confirm("Message.messageIsText", data.messageIsText, appendix.isText);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixEncryptedMessage(bytes);
            this.confirm("EncryptedMessage.encryptedMessageData", data.encryptedMessageData, appendix.encryptedMessageData);
            this.confirm("EncryptedMessage.encryptedMessageNonce", data.encryptedMessageNonce, appendix.encryptedMessageNonce);
            this.confirm("EncryptedMessage.messageToEncryptIsText", data.messageToEncryptIsText, appendix.isText);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicKeyAnnouncement(bytes);
            this.confirm("PublicKeyAnnouncement.recipientPublicKey", data.recipientPublicKey, appendix.publicKey);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixEncryptToSelfMessage(bytes);
            this.confirm("EncryptToSelfMessage.encryptedMessageData", data.encryptToSelfMessageData, appendix.encryptedMessageData);
            this.confirm("EncryptToSelfMessage.encryptedMessageNonce", data.encryptToSelfMessageNonce, appendix.encryptedMessageNonce);
            this.confirm("EncryptToSelfMessage.messageToEncryptIsText", data.messageToEncryptToSelfIsText, appendix.isText);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPrivateNameAnnouncement(bytes);
            this.confirm("PrivateNameAnnouncement.privateNameAnnouncement", data.privateNameAnnouncement, appendix.privateNameAnnouncement);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPrivateNameAssignment(bytes);
            this.confirm("PrivateNameAssignment.privateNameAssignment", data.privateNameAssignment, appendix.privateNameAssignment);
            this.confirm("PrivateNameAssignment.privateNameAssignmentSignature", data.privateNameAssignmentSignature, appendix.signature);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicNameAnnouncement(bytes);
            this.confirm("PublicNameAnnouncement.privateNameAssignment", data.publicNameAnnouncement, appendix.publicNameAnnouncement);
        }
        position <<= 1;
        if ((transaction.flags & position) != 0) {
            var appendix = new AppendixPublicNameAssignment(bytes);
            this.confirm("PublicNameAssignment.publicNameAssignment", data.publicNameAssignment, appendix.publicNameAssignment);
            this.confirm("PublicNameAssignment.publicNameAssignmentSignature", data.publicNameAssignmentSignature, appendix.signature);
        }
        var tmp1 = converters.hexStringToByteArray(transactionBytes);
        var tmp2 = converters.hexStringToByteArray(signature);
        Array.prototype.splice.apply(tmp1, [64, 64].concat(tmp2));
        return converters.byteArrayToHexString(tmp1);
    };
    AbstractTransaction.checkType = function (transaction, type, subtype) {
        return transaction.type === type && transaction.subtype === subtype;
    };
    return AbstractTransaction;
}());
var GenericDialogState;
(function (GenericDialogState) {
    GenericDialogState[GenericDialogState["EDIT"] = 0] = "EDIT";
    GenericDialogState[GenericDialogState["CREATE"] = 1] = "CREATE";
    GenericDialogState[GenericDialogState["SIGN"] = 2] = "SIGN";
    GenericDialogState[GenericDialogState["BROADCAST"] = 3] = "BROADCAST";
})(GenericDialogState || (GenericDialogState = {}));
var GenericDialogBroadcastState;
(function (GenericDialogBroadcastState) {
    GenericDialogBroadcastState[GenericDialogBroadcastState["INTERNAL_TIMEOUT"] = 0] = "INTERNAL_TIMEOUT";
    GenericDialogBroadcastState[GenericDialogBroadcastState["INTERNAL_ERROR"] = 1] = "INTERNAL_ERROR";
    GenericDialogBroadcastState[GenericDialogBroadcastState["SERVER_ERROR"] = 2] = "SERVER_ERROR";
})(GenericDialogBroadcastState || (GenericDialogBroadcastState = {}));
var GenericDialog = (function () {
    function GenericDialog($event) {
        this.okBtnTitle = 'OK';
        this.fields = {};
        this.state = GenericDialogState.EDIT;
        this.busy = false;
        this.error = false;
        this.cancelled = false;
        this.instantSend = false;
        this.bindToController = true;
        this.controllerAs = 'vm';
        this.controller = GenericDialogCreateController(this);
        this.parent = angular.element(document.body);
        this.template = "\n    <md-dialog class=\"{{ vm.dialogClass }}\">\n      <form name=\"dialogForm\">\n        <md-toolbar>\n          <div class=\"md-toolbar-tools\">\n            <h2>{{ vm.dialogTitle }}</h2>\n            <div class=\"wrapper\">&nbsp;</div>\n            <h2>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists && vm.fields.recipientPublicKey.value\">\n                {{vm.fields.recipient.value}}\n              </span>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists && !vm.fields.recipientPublicKey.value\"\n                    style=\"color: red\">NO PUBLIC KEY</span>\n              <span ng-if=\"vm.fields.recipient && vm.fields.recipient.value && vm.fields.recipient.accountExists === false\"\n                    style=\"color: red\">UNKNOWN DESTINATION</span>\n            </h2>\n          </div>\n        </md-toolbar>\n        <md-dialog-content style=\"min-width:500px\" layout=\"column\" layout-padding ng-switch=\"vm.state\">\n\n          <!-- EDIT -->\n          <div ng-switch-when=\"0\">\n            <div ng-repeat=\"field in vm.fields\">\n              <field selector=\"{{field._selector}}\" f=\"field\" label=\"field._label\" value=\"field.value\" changed=\"field.changed()\"></field>\n            </div>\n          </div>\n\n          <!-- CREATE -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"1\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-click=\"vm.state=0;vm.error=false;vm.maybeClose()\" ng-show=\"vm.error\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Creating transaction</div>\n              <div ng-show=\"vm.error\">{{vm.message}}</div>\n            </div>\n          </div>\n\n          <!-- SIGN -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"2\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error\" ng-click=\"vm.cancelBtn()\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Signing transaction</div>\n              <div ng-show=\"vm.error\">{{vm.message}}</div>\n            </div>\n          </div>\n\n          <!-- BROADCAST -->\n          <div layout=\"column\" layout-align=\"center center\" ng-switch-when=\"3\" layout-padding>\n            <div layout=\"column\" layout-align=\"center center\">\n              <md-progress-circular md-mode=\"indeterminate\" ng-show=\"vm.busy\"></md-progress-circular>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error && vm.broadcastState == 0\" ng-click=\"vm.broadcast()\">\n                <md-icon md-font-library=\"material-icons\">refresh</md-icon>\n              </md-button>\n              <md-button class=\"md-fab md-warn\" ng-show=\"vm.error && (vm.broadcastState == 1 || vm.broadcastState == 2)\"\n                    ng-click=\"vm.state=0;vm.error=false;vm.maybeClose()\">\n                <md-icon md-font-library=\"material-icons\">warning</md-icon>\n              </md-button>\n              <md-button class=\"md-fab md-primary\" ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\" ng-click=\"vm.dialogHide()\">\n                <md-icon md-font-library=\"material-icons\">check</md-icon>\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <div ng-show=\"vm.busy\">Broadcasting transaction</div>\n              <div ng-show=\"vm.error\" layout=\"column\" layout-align=\"center center\">\n                <div>{{ vm.message }}</div>\n                <div>{{ vm.secondaryMessage }}</div>\n              </div>\n              <div ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\" layout=\"column\" layout-align=\"center center\">\n                <!-- <div>Succesully broadcasted transaction</div> -->\n                <div>Transaction completed</div>\n              </div>\n            </div>\n          </div>\n        </md-dialog-content>\n        <md-dialog-actions layout=\"row\" ng-switch=\"vm.state\">\n          <md-button ng-if=\"!vm.customFeeTitle\" ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">Fee {{vm.feeFormatted}} HEAT</md-button>\n          <md-button ng-if=\"vm.customFeeTitle\" ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">{{vm.customFeeTitle}}</md-button>\n          <span flex></span>\n\n          <!-- EDIT -->\n          <div ng-switch-when=\"0\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\">Cancel</md-button>\n            <!--<md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.okBtn['processing']\"></md-progress-circular>-->\n            <span class=\"text-center\" ng-hide=\"!vm.okBtn['processing']\"><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contacting...&nbsp;</i></span>\n            <md-button class=\"md-primary\" ng-hide=\"vm.okBtn['processing']\" ng-click=\"vm.okBtn()\" ng-disabled=\"!dialogForm.$valid || vm.okBtn['processing'] || vm.okBtn['disabled']\">\n              {{vm.okBtnTitle}}\n            </md-button>\n          </div>\n\n          <!-- CREATE -->\n          <div ng-switch-when=\"1\" ng-show=\"vm.busy\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\">Cancel</md-button>\n          </div>\n\n          <!-- SIGN -->\n          <div ng-switch-when=\"2\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.busy\">Cancel</md-button>\n            <md-button class=\"md-primary\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.error\">Close</md-button>\n          </div>\n\n          <!-- BROADCAST -->\n          <div ng-switch-when=\"3\">\n            <md-button class=\"md-warn\" ng-click=\"vm.cancelBtn()\" ng-show=\"vm.broadcastState==1 || vm.broadcastState==2\">Cancel</md-button>\n            <!-- <md-button class=\"md-primary\" ng-click=\"vm.reset()\" ng-show=\"!vm.broadcastState && !vm.error && !vm.busy\">More</md-button> -->\n          </div>\n        </md-dialog-actions>\n      </form>\n    </md-dialog>\n  ";
        this.targetEvent = $event;
    }
    GenericDialog.prototype.fieldsReady = function ($scope) { };
    GenericDialog.prototype.send = function () {
        this.instantSend = true;
        return this.show();
    };
    GenericDialog.prototype.show = function () {
        var $mdDialog = heat.$inject.get('$mdDialog');
        return $mdDialog.show(this);
    };
    return GenericDialog;
}());
function GenericDialogCreateController(dialog) {
    return function ($scope, $mdDialog, settings) {
        var _this = this;
        this.fields = dialog.getFields($scope);
        this.fields.forEach(function (field) {
            dialog.fields[field.name] = field;
            _this.fields[field.name] = field;
        });
        dialog.fieldsReady($scope);
        this.builder = null;
        this.visualization_delay = settings.get(SettingsService.TRANSACTION_PROCESSING_VISUALIZATION);
        this.stateRecipient = null;
        this.stateRecipientExists = false;
        this.stateRecipientNoPublicKey = false;
        this.dialogCancel = function () {
            $mdDialog.cancel();
        };
        this.dialogHide = function () {
            $mdDialog.hide(this.builder.transactionId);
        };
        this.reset = function () {
            this.state = GenericDialogState.EDIT;
            this.error = null;
            this.message = null;
            this.broadcastState = null;
            this.secondaryMessage = null;
            for (var i = 0; i < this.fields.length; i++) {
                this.fields[i].value = undefined;
            }
        };
        this.maybeClose = function () {
            if (dialog.instantSend) {
                this.dialogCancel();
            }
        };
        var overridedOkBtn = dialog['okBtn'];
        if (overridedOkBtn) {
            overridedOkBtn['mdDialog'] = $mdDialog;
            overridedOkBtn['scope'] = $scope;
        }
        this.okBtn = overridedOkBtn ? overridedOkBtn : function () {
            var _this = this;
            this.builder = dialog.getTransactionBuilder();
            this.state = GenericDialogState.CREATE;
            this.busy = true;
            this.error = false;
            this.message = null;
            var promise = utils.delayPromise(this.builder.create(), this.visualization_delay);
            promise.then(function () {
                if (_this.cancelled)
                    return;
                promise = utils.delayPromise(_this.builder.sign(), _this.visualization_delay);
                $scope.$evalAsync(function () {
                    _this.state = GenericDialogState.SIGN;
                    promise.then(function () {
                        if (_this.cancelled)
                            return;
                        _this.broadcast();
                    }, function (error) {
                        $scope.$evalAsync(function () {
                            _this.busy = false;
                            _this.error = true;
                            _this.message = error.description;
                        });
                    });
                });
            }, function (error) {
                $scope.$evalAsync(function () {
                    _this.busy = false;
                    _this.error = true;
                    _this.message = error.description;
                });
            });
        };
        this.cancelBtn = function () {
            this.cancelled = true;
            this.dialogCancel();
        };
        this.broadcast = function () {
            var _this = this;
            var promise = utils.delayPromise(this.builder.broadcast(), this.visualization_delay);
            $scope.$evalAsync(function () {
                _this.busy = true;
                _this.error = false;
                _this.state = GenericDialogState.BROADCAST;
                _this.broadcastState = null;
                promise.then(function (response) {
                    if (_this.cancelled)
                        return;
                    $scope.$evalAsync(function () {
                        _this.busy = false;
                        if (response.internalTimeout) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.INTERNAL_TIMEOUT;
                            _this.message = 'Internal timeout';
                            _this.secondaryMessage = 'Click to retry';
                        }
                        else if (response.internalError) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.INTERNAL_ERROR;
                            _this.message = 'Internal error';
                            _this.secondaryMessage = 'Unable to confirm broadcast succeeded';
                        }
                        else if (response.serverError) {
                            _this.error = true;
                            _this.broadcastState = GenericDialogBroadcastState.SERVER_ERROR;
                            _this.message = 'Server error';
                            _this.secondaryMessage = response.serverError;
                        }
                        else {
                            setTimeout(function () { _this.dialogHide(); }, 666);
                        }
                    });
                });
            });
        };
        if (this.instantSend) {
            this.okBtn();
        }
    };
}
var AssetIssueService = (function (_super) {
    __extends(AssetIssueService, _super);
    function AssetIssueService($q, user, assetInfo, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.assetInfo = assetInfo;
        _this.heat = heat;
        return _this;
    }
    AssetIssueService.prototype.dialog = function (currency, readonly, $event) {
        return new AssetIssueDialog($event, this, this.$q, this.user, this.assetInfo, this.heat, readonly);
    };
    AssetIssueService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 0)
            return false;
        var descriptionUrlLen = bytes.byteArray[bytes.pos];
        bytes.pos += 1;
        transaction.descriptionUrl = converters.byteArrayToString(bytes.byteArray, bytes.pos, descriptionUrlLen);
        bytes.pos += descriptionUrlLen;
        transaction.descriptionHash = converters.byteArrayToHexString(bytes.byteArray.slice(bytes.pos, bytes.pos + 32));
        bytes.pos += 32;
        transaction.quantity = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.decimals = bytes.byteArray[bytes.pos];
        bytes.pos += 1;
        transaction.dillutable = bytes.byteArray[bytes.pos] == 1;
        bytes.pos += 1;
        return transaction.descriptionUrl === data.AssetIssuance.descriptionUrl &&
            transaction.descriptionHash === data.AssetIssuance.descriptionHash &&
            transaction.quantity === data.AssetIssuance.quantityQNT &&
            transaction.decimals === data.AssetIssuance.decimals &&
            transaction.dillutable === data.AssetIssuance.dillutable;
    };
    AssetIssueService = __decorate([
        Service('assetIssue'),
        Inject('$q', 'user', 'assetInfo', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            AssetInfoService,
            HeatService])
    ], AssetIssueService);
    return AssetIssueService;
}(AbstractTransaction));
var AssetIssueDialog = (function (_super) {
    __extends(AssetIssueDialog, _super);
    function AssetIssueDialog($event, transaction, $q, user, assetInfo, heat, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.assetInfo = assetInfo;
        _this.heat = heat;
        _this.readonly = readonly;
        _this.dialogTitle = 'Issue asset';
        _this.dialogDescription = 'Description on how to issue an asset';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.assetIssue, 8).replace(/000000$/, '');
        _this.okBtnTitle = 'SEND';
        return _this;
    }
    AssetIssueDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('symbol').
                label('Asset symbol (3-4 chars)').
                validate("Symbol must have 3 to 4 chars", function (symbol) {
                var len = angular.isString(symbol) ? symbol.trim().length : 0;
                return len >= 3 && len <= 4;
            }).
                asyncValidate("Symbol name already in use", function (symbol) {
                var deferred = _this.$q.defer();
                _this.heat.api.getAssetProtocol1(symbol).then(function (asset) {
                    deferred.reject();
                }, function (response) {
                    if (response && response.code == 3 && response.description == "Unknown asset")
                        deferred.resolve();
                    else
                        deferred.reject();
                });
                return deferred.promise;
            }).
                required(),
            builder.text('name').
                label('Asset name').
                validate("Name can be at most 100 characters long", function (name) {
                var len = angular.isString(name) ? name.trim().length : 0;
                return len <= 100;
            }).
                required(),
            builder.text('quantity').
                label('Quantity').
                required(),
            builder.text('decimals').
                label('Decimals').
                required().
                validate("Allowed range 0 .. 8", function (decimals) {
                var num = parseInt(decimals);
                if (isNaN(num))
                    return false;
                return num >= 0 && num <= 8;
            }),
            builder.text('dillutable', 'false').
                label('Dillutable').
                required().
                validate("Either type true or false", function (dillutable) {
                return dillutable == 'true' || dillutable == 'false';
            }),
            builder.text('descriptionUrl', 'http://').
                label('Description URL (http:// or https://) (can be changed later)').
                validate("Either leave blank or has to start with http:// or https://", function (value) {
                return !value || value.indexOf('http://') == 0 || value.indexOf('https://') == 0;
            }).
                required(false),
            builder.text('descriptionHash').
                label('Description hash (SHA256) of the description url contents (can be changed later)').
                validate("Either leave blank or provide SHA256 hash in hex encoding", function (value) {
                if (value) {
                    if (!/[0-9A-Fa-f]{6}/g.test(value))
                        return false;
                    var bytes = converters.hexStringToByteArray(value);
                    if (bytes.length != 32)
                        return false;
                }
                return true;
            }).
                required(false),
        ];
    };
    AssetIssueDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.assetIssue)
            .attachment('AssetIssuance', {
            decimals: parseInt(this.fields['decimals'].value),
            dillutable: this.fields['dillutable'].value == 'true',
            quantityQNT: utils.convertToQNT(this.fields['quantity'].value),
            descriptionHash: this.fields['descriptionHash'].value || "0".repeat(64),
            descriptionUrl: this.fields['descriptionUrl'].value || 'http://'
        });
        var properties = this.assetInfo.stringifyProperties({
            symbol: this.fields['symbol'].value,
            name: this.fields['name'].value
        });
        var messageHex = heat.bundle.createAssetProperties({
            asset: "0",
            protocol: 1,
            value: properties
        });
        builder.message(messageHex, TransactionMessageType.PUBLIC, true);
        return builder;
    };
    return AssetIssueDialog;
}(GenericDialog));
var SendmoneyService = (function (_super) {
    __extends(SendmoneyService, _super);
    function SendmoneyService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    SendmoneyService.prototype.dialog = function ($event, recipient, recipientPublicKey, amount, userMessage) {
        return new SendmoneyDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, amount, userMessage);
    };
    SendmoneyService.prototype.verify = function (transaction, bytes) {
        return transaction.type === 0 && transaction.subtype === 0;
    };
    SendmoneyService = __decorate([
        Service('sendmoney'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], SendmoneyService);
    return SendmoneyService;
}(AbstractTransaction));
var SendmoneyDialog = (function (_super) {
    __extends(SendmoneyDialog, _super);
    function SendmoneyDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, amount, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.amount = amount;
        _this.userMessage = userMessage;
        _this.dialogTitle = 'Send HEAT';
        _this.dialogDescription = 'Description on how to send money';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.amount = _this.amount || '0';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    SendmoneyDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.fields['message'].changed();
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            }).
                required(),
            builder.money('amount', this.amount).
                label('Amount').
                required().
                precision(8).
                symbol('HEAT').
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                _this.heat.api.getAccountBalance(_this.user.account, '0').then(function (balance) {
                    try {
                        var avail = new Big(balance.unconfirmedBalance);
                        var total = new Big(amount).add(new Big(HeatAPI.fee.standard));
                        if (avail.gte(total) > 0) {
                            deferred.resolve();
                        }
                        else {
                            deferred.reject();
                        }
                    }
                    catch (e) {
                        deferred.reject();
                    }
                }, deferred.reject);
                return deferred.promise;
            }),
            builder.text('message', this.userMessage).
                rows(2).
                asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            }).
                label('Message'),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    SendmoneyDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('OrdinaryPayment', {
            amountHQT: this.fields['amount'].value
        });
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return SendmoneyDialog;
}(GenericDialog));
var ToolbarComponent = (function () {
    function ToolbarComponent($rootScope, $scope, $mdSidenav, user, sendmoney, electron, env, assetTransfer, assetIssue, whitelistMarket, balanceLease, masternodeService, storage, $window, $mdToast, walletFile, localKeyStore, panel, $location, clipboard, p2pMessaging) {
        var _this = this;
        this.$rootScope = $rootScope;
        this.$scope = $scope;
        this.$mdSidenav = $mdSidenav;
        this.user = user;
        this.sendmoney = sendmoney;
        this.electron = electron;
        this.env = env;
        this.assetTransfer = assetTransfer;
        this.assetIssue = assetIssue;
        this.whitelistMarket = whitelistMarket;
        this.balanceLease = balanceLease;
        this.masternodeService = masternodeService;
        this.storage = storage;
        this.$window = $window;
        this.$mdToast = $mdToast;
        this.walletFile = walletFile;
        this.localKeyStore = localKeyStore;
        this.panel = panel;
        this.$location = $location;
        this.clipboard = clipboard;
        this.p2pMessaging = p2pMessaging;
        this.isNodeEnv = false;
        this.isTestnet = heat.isTestnet;
        this.isBetanet = heat.isBetanet;
        this.hasUnreadP2PMessage = false;
        this.localHeatMasterAccounts = [];
        this.isNodeEnv = env.type == EnvType.NODEJS;
        var refresh = utils.debounce(this.refreshLocalWallet.bind(this), 1000, false);
        this.user.on(UserService.EVENT_UNLOCKED, refresh);
        this.refreshLocalWallet();
        $rootScope.$on('HEAT_SERVER_LOCATION', function (event, location) {
            _this.heatServerLocation = location;
        });
        var unreadChangedListener = function (rooms) {
            _this.$scope.$evalAsync(function () {
                _this.hasUnreadP2PMessage = rooms.length > 0;
            });
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_HAS_UNREAD_CHANGED, unreadChangedListener);
        $scope.$on('$destroy', function () { return _this.p2pMessaging.removeListener(P2PMessaging.EVENT_HAS_UNREAD_CHANGED, unreadChangedListener); });
    }
    ToolbarComponent.prototype.copyAddress = function () {
        this.clipboard.copyWithUI(document.getElementById('toolbar-user-address'), 'Copied address to clipboard');
    };
    ToolbarComponent.prototype.goToHome = function () {
        this.$location.path(this.user.currency.homePath);
    };
    ToolbarComponent.prototype.goToExchange = function () {
        if (this.user.currency && this.user.currency.symbol === 'ARDR') {
            this.$location.path('/ardor-trader/15307894944226771409/ardor');
        }
        else {
            this.isTestnet ? this.$location.path('/trader/2949625650944850605/0') : this.$location.path('/trader/5592059897546023466/0');
        }
    };
    ToolbarComponent.prototype.goToMessenger = function () {
        this.$location.path('messenger/0');
    };
    ToolbarComponent.prototype.openTestPage = function () {
        var _this = this;
        var address = '0x98d84343b9b98bb15a2ba3d6867c42a89c37a067';
        var ethplorer = heat.$inject.get('ethplorer');
        ethplorer.getAddressInfo(address).then(function () {
            _this.$location.path('ethereum-account/' + address);
        });
    };
    ToolbarComponent.prototype.refreshLocalWallet = function () {
        var _this = this;
        this.localHeatMasterAccounts = [];
        this.localKeyStore.list().map(function (account) {
            var name = _this.localKeyStore.keyName(account);
            _this.localHeatMasterAccounts.push({
                account: account,
                locked: true,
                identifier: name || account
            });
        });
        this.localHeatMasterAccounts.forEach(function (acc) {
            var password = _this.localKeyStore.getPasswordForAccount(acc.account);
            if (password) {
                acc.locked = false;
            }
        });
    };
    ToolbarComponent.prototype.unlock = function (secretPhrase) {
        var _this = this;
        this.user.unlock(secretPhrase, null).then(function () {
            _this.$location.path("/explorer-account/" + _this.user.account + "/transactions");
            heat.fullApplicationScopeReload();
        });
    };
    ToolbarComponent.prototype.selectWalletAccount = function ($event, item) {
        var _this = this;
        var password = this.localKeyStore.getPasswordForAccount(item.account);
        if (password) {
            var key = this.localKeyStore.load(item.account, password);
            if (key) {
                this.unlock(key.secretPhrase);
            }
        }
        else {
            dialogs.prompt($event, 'Enter Password (or Pin)', 'Please enter your Password (or Pin) to unlock', '').then(function (password) {
                try {
                    var key = _this.localKeyStore.load(item.account, password);
                    if (key) {
                        _this.unlock(key.secretPhrase);
                        return;
                    }
                }
                catch (e) {
                    console.log(e);
                }
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Incorrect Password (or Pin)").hideDelay(5000));
            });
        }
    };
    ToolbarComponent.prototype.showSendmoneyDialog = function ($event) {
        this.user.currency.invokeSendDialog($event);
    };
    ToolbarComponent.prototype.showAssetTransferDialog = function ($event) {
        this.assetTransfer.dialog($event).show();
    };
    ToolbarComponent.prototype.showIssueAssetDialog = function ($event) {
        this.assetIssue.dialog($event).show();
    };
    ToolbarComponent.prototype.showWhitelistMarketDialog = function ($event) {
        var _this = this;
        var dialog = this.whitelistMarket.dialog($event);
        dialog.show().then(function () {
            var currency = dialog.fields['currency'].value;
            var asset = dialog.fields['asset'].value;
            var currencyAvailableAssets = dialog.fields['currency']['availableAssets'];
            var assetAvailableAssets = dialog.fields['asset']['availableAssets'];
            var currencySymbol, assetSymbol;
            for (var i = 0; i < currencyAvailableAssets.length; i++) {
                var available = currencyAvailableAssets[i];
                if (available.id == currency) {
                    currencySymbol = available.symbol;
                    break;
                }
            }
            for (var i = 0; i < assetAvailableAssets.length; i++) {
                var available = assetAvailableAssets[i];
                if (available.id == asset) {
                    assetSymbol = available.symbol;
                    break;
                }
            }
            var mymarkets = _this.storage.namespace('trader').get('my-markets');
            if (!mymarkets) {
                mymarkets = [];
            }
            mymarkets.push({
                currency: { id: currency, symbol: currencySymbol },
                asset: { id: asset, symbol: assetSymbol }
            });
            _this.storage.namespace('trader').put('my-markets', mymarkets);
        });
    };
    ToolbarComponent.prototype.showLeaseBalanceDialog = function ($event) {
        this.balanceLease.dialog(1440, null).show();
    };
    ToolbarComponent.prototype.registerInternetAddress = function ($event) {
        this.masternodeService.dialog(null).show();
    };
    ToolbarComponent.prototype.signout = function () {
        this.user.lock();
    };
    ToolbarComponent.prototype.exit = function () {
        this.$window.close();
    };
    ToolbarComponent.prototype.about = function ($event) {
        dialogs.about($event);
    };
    ToolbarComponent.prototype.opendevTools = function () {
        this.electron.openDevTools(OpenDevToolsMode.detach);
    };
    ToolbarComponent.prototype.showSecretPhrase = function () {
        this.panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <textarea rows=\"2\" flex ng-bind=\"vm.secretPhrase\" readonly ng-trim=\"false\"></textarea>\n        </md-input-container>\n      </div>\n    ", {
            secretPhrase: this.user.secretPhrase
        });
    };
    ToolbarComponent.prototype.backupWallet = function () {
        var exported = this.localKeyStore.export();
        var encoded = this.walletFile.encode(exported);
        var blob = new Blob([encoded], { type: "text/plain;charset=utf-8" });
        saveAs(blob, 'heat.wallet');
    };
    ToolbarComponent = __decorate([
        Component({
            selector: 'toolbar',
            styles: ["\n  toolbar .admin-menu .md-button:not(.active) {\n    background-color: #FFA726;\n  }\n  toolbar .admin-selected-user .md-button {\n    margin-right: 18px;\n    margin-left: 0px;\n  }\n  toolbar .test-net {\n    font-size: 22px !important;\n    font-weight: bold !important;\n    line-height: 0.6;\n  }\n  toolbar .test-net-color {\n    background-color: #4CAF50 !important;\n  }\n  toolbar .beta-net-color {\n    background-color: #bf112f !important;\n  }\n  .unread-message-mark {\n    position: absolute;\n    top: 22px;\n    left: 32px;\n    color: green;\n    font-size: 35px;\n  }\n  "],
            template: "\n    <md-toolbar class=\"main-toolbar\" ng-class=\"{'test-net-color':vm.isTestnet,'beta-net-color':vm.isBetanet}\">\n      <div class=\"md-toolbar-tools\">\n        <h2 ng-if=\"vm.isTestnet\" class=\"test-net\">\n          <md-tooltip md-direction=\"bottom\">See About dialog to switch to main net</md-tooltip>\n          TEST-NET&nbsp;&nbsp;&nbsp;&nbsp;\n          <br/><span style=\"font-size: 9px; font-weight: normal;\">{{vm.heatServerLocation}}&nbsp;&nbsp;&nbsp;&nbsp;</span>\n        </h2>\n        <h2 ng-if=\"vm.isBetanet\" class=\"test-net\">\n          <md-tooltip md-direction=\"bottom\">See About dialog to switch to main net</md-tooltip>\n          B E T A N E T &nbsp;\n        </h2>\n\n        <div class=\"wrapper\">\n          <div>\n            <div class=\"user\">\n              <div class=\"small-logo\" ng-if=\"!vm.isBetanet\"></div>\n              <h2 ng-if=\"vm.user.unlocked\">\n                <div class=\"account-name\">{{vm.user.accountName}}</div>\n                <div>\n                  <user-balance ng-if=\"vm.user.unlocked\"></user-balance>\n                </div>\n              </h2>\n            </div>\n\n            <div ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"home\" class=\"md-icon-button\" ng-click=\"vm.goToHome()\">\n                <md-tooltip md-direction=\"bottom\">Your {{vm.user.currency.symbol}} Home</md-tooltip>\n                <i><img src=\"assets/homeIcon.png\"></i>\n              </md-button>\n            </div>\n\n            <div>\n              <md-button aria-label=\"explorer\" class=\"md-icon-button\" href=\"#/explorer\">\n                <md-tooltip md-direction=\"bottom\">Blockchain explorer</md-tooltip>\n                <i><img src=\"assets/exploreIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"trader\" class=\"md-icon-button\" ng-click=\"vm.goToExchange()\">\n                <md-tooltip md-direction=\"bottom\">Exchange</md-tooltip>\n                <i><img src=\"assets/exchangeIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"server\" class=\"md-icon-button\" href=\"#/server\" ng-show=\"vm.isNodeEnv\">\n                <md-tooltip md-direction=\"bottom\">App Server</md-tooltip>\n                <i><img src=\"assets/serverIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"home\" class=\"md-icon-button\" href=\"#/wallet\" ng-if=\"!vm.user.unlocked\">\n                <md-tooltip md-direction=\"bottom\">Wallet</md-tooltip>\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n\n              <!--\n              <md-button aria-label=\"home\" class=\"md-icon-button\" ng-click=\"vm.$mdToast.show(vm.$mdToast.simple().textContent('Incorrect Password (or Pin)').hideDelay(15000))\">\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n              -->\n\n\n            </div>\n\n            <div hide show-gt-sm ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"send heat\" class=\"md-icon-button\" ng-click=\"vm.showSendmoneyDialog($event);\">\n                <md-tooltip md-direction=\"bottom\">Send {{vm.user.currency.symbol}}</md-tooltip>\n                <i><img src=\"assets/sendHeatIcon.png\"></i>\n              </md-button>\n              <md-button aria-label=\"messages\" class=\"md-icon-button\" ng-click=\"vm.goToMessenger()\">\n                <md-tooltip md-direction=\"bottom\">Messages</md-tooltip>\n                <i>\n                  <img src=\"assets/messageIcon.png\">\n                </i>\n                <div class=\"unread-message-mark\" ng-if=\"vm.hasUnreadP2PMessage\">*</div>\n              </md-button>\n              <md-button aria-label=\"home\" class=\"md-icon-button\" href=\"#/wallet\">\n                <md-tooltip md-direction=\"bottom\">Wallet</md-tooltip>\n                <i><img src=\"assets/walletIcon.png\"></i>\n              </md-button>\n            </div>\n\n            <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 34px\" hide-gt-sm ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"user menu\" class=\"md-icon-button\" ng-click=\"$mdOpenMenu($event)\" md-menu-origin >\n                <md-icon md-font-library=\"material-icons\">more_vert</md-icon>\n              </md-button>\n              <md-menu-content width=\"4\">\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"home\" ng-click=\"vm.goToHome()\">\n                    <md-icon md-font-library=\"material-icons\">home</md-icon>\n                    Your {{vm.user.currency.symbol}} Home\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"explorer\" href=\"#/explorer\">\n                    <md-icon md-font-library=\"material-icons\">explore</md-icon>\n                    Blockchain explorer\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"trader\" ng-click=\"vm.goToExchange()\">\n                    <md-icon md-font-library=\"material-icons\">bar_chart</md-icon>\n                    Exchange\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-show=\"vm.isNodeEnv\">\n                  <md-button aria-label=\"server\" href=\"#/server\">\n                    <md-icon md-font-library=\"material-icons\">settings</md-icon>\n                    App Server\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button aria-label=\"wallet\" href=\"#/wallet\">\n                    <md-icon md-font-library=\"material-icons\">account_balance_wallet</md-icon>\n                    Wallet\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"send heat\" ng-click=\"vm.showSendmoneyDialog($event);\">\n                    <md-icon md-font-library=\"material-icons\">send</md-icon>\n                    Send {{vm.user.currency.symbol}}\n                  </md-button>\n                </md-menu-item>\n                <md-menu-item ng-if=\"vm.user.unlocked\">\n                  <md-button aria-label=\"messages\" ng-click=\"vm.goToMessenger()\">\n                    <md-icon md-font-library=\"material-icons\">chat</md-icon>\n                    Messages\n                  </md-button>\n                </md-menu-item>\n                <!--\n                <md-menu-item>\n                  <md-button aria-label=\"home\" ng-click=\"vm.openTestPage()\">\n                    <md-icon md-font-library=\"material-icons\">check</md-icon>\n                  </md-button>\n                </md-menu-item>\n                -->\n              </md-menu-content>\n            </md-menu>\n\n            <span flex></span>\n\n            <div class=\"selected-address\" ng-if=\"vm.user.unlocked\">\n              <div>Currently using <b>{{vm.user.currency.symbol}}</b></div>\n              <div layout=\"row\">\n                <div class=\"address wrapped\">\n                  <a href=\"#{{vm.user.currency.homePath}}\" id=\"toolbar-user-address\">{{vm.user.currency.address}}</a>\n                </div>\n                &nbsp;<a ng-click=\"vm.copyAddress()\">[copy]</a>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <md-menu ng-if=\"vm.user.unlocked\" style=\"margin-right: -12px;\">\n          <md-button aria-label=\"signout\" class=\"md-icon-button\" ng-click=\"$mdOpenMenu($event)\" md-menu-origin >\n            <md-icon md-font-library=\"material-icons\">face</md-icon>\n          </md-button>\n          <md-menu-content width=\"4\">\n            <md-menu-item ng-repeat=\"item in vm.localHeatMasterAccounts\">\n              <md-button ng-click=\"vm.selectWalletAccount($event, item)\">\n                <span>{{item.identifier}}</span>\n              </md-button>\n            </md-menu-item>\n          </md-menu>\n        </md-menu>\n\n        <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 0px\">\n          <md-button aria-label=\"signout\" class=\"md-icon-button\" ng-click=\"$mdOpenMenu($event)\" md-menu-origin >\n            <i><img src=\"assets/sandwich.png\"></i>\n          </md-button>\n          <md-menu-content width=\"4\">\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"transfer asset\" ng-click=\"vm.showAssetTransferDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">swap_horiz</md-icon>\n                <span>Transfer Asset</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"issue asset\" ng-click=\"vm.showIssueAssetDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">library_add</md-icon>\n                <span>Issue Asset</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"whitelits market\" ng-click=\"vm.showWhitelistMarketDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">insert_chart</md-icon>\n                <span>Create Market</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"lease balance\" ng-click=\"vm.showLeaseBalanceDialog($event)\">\n                <md-icon md-font-library=\"material-icons\">update</md-icon>\n                <span>Lease Balance</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"register internet address\" ng-click=\"vm.registerInternetAddress($event)\">\n                <md-icon md-font-library=\"material-icons\">spellcheck</md-icon>\n                <span>Register Masternode Address</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item ng-show=\"vm.isNodeEnv\">\n              <md-button aria-label=\"dev-tools\" ng-click=\"vm.opendevTools($event)\">\n                <md-icon md-font-library=\"material-icons\">developer_board</md-icon>\n                Developer tools\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button aria-label=\"about\" ng-click=\"vm.about($event)\">\n                <md-icon md-font-library=\"material-icons\">info_outline</md-icon>\n                About HEAT\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button aria-label=\"about\" href=\"https://heatwallet.com/api\" target=\"_blank\">\n                <md-icon md-font-library=\"material-icons\">find_in_page</md-icon>\n                <span>Heat API (external)</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"Show copy\" ng-click=\"vm.showSecretPhrase()\">\n                <md-icon md-font-library=\"material-icons\">content_copy</md-icon>\n                <span>Show private key</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item>\n              <md-button aria-label=\"backup\" ng-click=\"vm.backupWallet()\">\n                <md-icon md-font-library=\"material-icons\">save</md-icon>\n                <span>Backup Wallet</span>\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"vm.user.unlocked\">\n              <md-button aria-label=\"signout\" ng-click=\"vm.signout()\">\n                <md-icon md-font-library=\"material-icons\">close</md-icon>\n                Sign out\n              </md-button>\n            </md-menu-item>\n            <md-menu-item  ng-if=\"!vm.user.unlocked\">\n              <md-button aria-label=\"signin\" href=\"#/login\">\n                <md-icon md-font-library=\"material-icons\">lock_open</md-icon>\n                Sign in\n              </md-button>\n            </md-menu-item>\n            <md-menu-item ng-if=\"vm.isNodeEnv\">\n              <md-button aria-label=\"exit\" ng-click=\"vm.exit()\">\n                <md-icon md-font-library=\"material-icons\">exit_to_app</md-icon>\n                Exit\n              </md-button>\n            </md-menu-item>\n          </md-menu-content>\n        </md-menu>\n      </div>\n    </md-toolbar>\n  "
        }),
        Inject('$rootScope', '$scope', '$mdSidenav', 'user', 'sendmoney', 'electron', 'env', 'assetTransfer', 'assetIssue', 'whitelistMarket', 'balanceLease', 'masternode', 'storage', '$window', '$mdToast', 'walletFile', 'localKeyStore', 'panel', '$location', 'clipboard', 'P2PMessaging'),
        __metadata("design:paramtypes", [Object, Object, Object, UserService,
            SendmoneyService,
            ElectronService,
            EnvService,
            AssetTransferService,
            AssetIssueService,
            WhitelistMarketService,
            BalanceLeaseService,
            MasternodeService,
            StorageService, Object, Object, WalletFileService,
            LocalKeyStoreService,
            PanelService, Object, ClipboardService,
            P2PMessaging])
    ], ToolbarComponent);
    return ToolbarComponent;
}());
var UserBalanceComponent = (function () {
    function UserBalanceComponent($scope, user, heat, $q, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.heat = heat;
        this.$q = $q;
        this.$interval = $interval;
        this.formattedBalance = "0";
        this.formattedFraction = ".00";
        this.loading = true;
        this.showError = false;
        var refresh = utils.debounce((angular.bind(this, this.refresh)), 1 * 1000, false);
        var unsubscribe = this.user.currency.subscribeBalanceChanged(function () { return refresh(); });
        $scope.$on('$destroy', unsubscribe);
        this.user.on(UserService.EVENT_UNLOCKED, refresh);
        $scope.$on('$destroy', function () {
            _this.user.removeListener(UserService.EVENT_UNLOCKED, refresh);
        });
        var interval = $interval(refresh, 10 * 1000);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
        this.refresh();
    }
    UserBalanceComponent.prototype.refresh = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.loading = true;
        });
        var address = this.user.currency.address;
        this.user.currency.getBalance().then(function (balance) {
            _this.$scope.$evalAsync(function () {
                var formatted = balance.split(".");
                _this.formattedBalance = formatted[0];
                _this.formattedFraction = "." + (formatted[1] || "00");
                _this.showError = false;
                _this.loading = false;
            });
        }, function (error) {
            _this.$scope.$evalAsync(function () {
                _this.formattedBalance = "0";
                _this.formattedFraction = ".00000000";
                _this.showError = true;
                _this.errorDescription = error.description;
                _this.loading = false;
            });
        });
    };
    UserBalanceComponent = __decorate([
        Component({
            selector: 'userBalance',
            template: "\n    <div layout=\"column\">\n      <span>\n        <md-tooltip ng-if=\"vm.showError\" md-direction=\"bottom\">{{vm.errorDescription}}</md-tooltip>\n        <span class=\"balance\">{{vm.formattedBalance}}</span>\n        <span class=\"fraction\">{{vm.formattedFraction}}</span>&nbsp;\n        <span class=\"currencyName\">{{vm.user.currency.symbol}}</span>\n        <md-icon ng-if=\"vm.showError\" md-font-library=\"material-icons\">error</md-icon>\n      </span>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'heat', '$q', '$interval'),
        __metadata("design:paramtypes", [Object, UserService,
            HeatService, Function, Function])
    ], UserBalanceComponent);
    return UserBalanceComponent;
}());
var UserContactsComponent = (function () {
    function UserContactsComponent($scope, user, heat, $q, $timeout, $interval, $location, $rootScope, storage, p2pMessaging, $mdToast) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.heat = heat;
        this.$q = $q;
        this.$timeout = $timeout;
        this.$interval = $interval;
        this.$location = $location;
        this.$rootScope = $rootScope;
        this.p2pMessaging = p2pMessaging;
        this.$mdToast = $mdToast;
        this.contacts = [];
        this.account = this.user.key ? this.user.key.account : this.user.account;
        this.refresh = utils.debounce(function () {
            _this.refreshContacts();
        }, 500, true);
        heat.subscriber.unconfirmedTransaction({ recipient: this.account }, function () { _this.refresh(); });
        this.store = storage.namespace('contacts.latestTimestamp', $scope);
        this.store.on(Store.EVENT_PUT, this.refresh);
        this.p2pMessaging.seenP2PMessageTimestampStore.on(Store.EVENT_PUT, function (key) {
            if (key.indexOf("_last-message-time") > -1)
                return;
            _this.refresh();
        });
        var contactListener = function (fullKey) {
            var contactKey = fullKey.substr(fullKey.lastIndexOf('.') + 1);
            var contact = _this.p2pMessaging.p2pContactStore.get(contactKey);
            if (contact && contact.activityTimestamp) {
                if (contact.activityTimestamp < 0) {
                    contact.activityTimestamp = -contact.activityTimestamp;
                    _this.$location.path("/messenger/" + contact.publicKey);
                }
            }
            else {
                _this.refresh();
            }
        };
        this.p2pMessaging.p2pContactStore.on(Store.EVENT_PUT, contactListener);
        if (user.unlocked) {
            this.init();
        }
        else {
            var listener_1 = function () { _this.init(); };
            user.on(UserService.EVENT_UNLOCKED, listener_1);
            $scope.$on('$destroy', function () { return user.removeListener(UserService.EVENT_UNLOCKED, listener_1); });
        }
        $rootScope.$on('$locationChangeSuccess', function () { _this.setActivePublicKey(); });
        this.setActivePublicKey();
        var messageListener = function (msg, room) {
            for (var _i = 0, _a = _this.contacts; _i < _a.length; _i++) {
                var contact = _a[_i];
                if (_this.contactHasUnreadP2PMessage(contact)) {
                    _this.refreshContacts();
                    return;
                }
            }
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_NEW_MESSAGE, messageListener);
        var channelListener = function (room, peerId) {
            _this.refresh();
        };
        this.p2pMessaging.on(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, channelListener);
        this.p2pMessaging.on(P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL, channelListener);
        $scope.$on('$destroy', function () {
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_NEW_MESSAGE, messageListener);
            _this.p2pMessaging.seenP2PMessageTimestampStore.removeListener(Store.EVENT_PUT, _this.refresh);
            _this.p2pMessaging.p2pContactStore.removeListener(Store.EVENT_PUT, contactListener);
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, channelListener);
            _this.p2pMessaging.removeListener(P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL, channelListener);
        });
    }
    UserContactsComponent.prototype.getActivePublicKey = function () {
        var path = this.$location.path().replace(/^\//, '').split('/'), route = path[0], params = path.slice(1);
        return (route == "messenger") ? params[0] : null;
    };
    UserContactsComponent.prototype.setActivePublicKey = function () {
        var _this = this;
        this.activePublicKey = this.getActivePublicKey();
        if (this.activePublicKey && this.activePublicKey != "0") {
            var room = this.p2pMessaging.enterRoom(this.activePublicKey);
        }
        if (!this.activePublicKey || this.activePublicKey == "0") {
            if (this.contacts[0] && this.contacts[0].publicKey != "0") {
                this.$location.path("/messenger/" + this.contacts[0].publicKey);
            }
        }
        var activeContact = this.contacts.find(function (contact) { return contact.publicKey == _this.activePublicKey; });
        if (activeContact) {
            activeContact["hasUnreadP2PMessage"] = false;
        }
    };
    UserContactsComponent.prototype.init = function () {
        this.refreshContacts();
    };
    UserContactsComponent.prototype.refreshContacts = function () {
        var _this = this;
        this.heat.api.getMessagingContacts(this.account, 0, 100).then(function (contacts) {
            _this.$scope.$evalAsync(function () {
                _this.contacts = contacts;
                _this.p2pMessaging.p2pContactStore.forEach(function (key, p2pContact) {
                    var existingHeatContact = _this.contacts.find(function (contact) { return !p2pContact.publicKey || contact.publicKey == p2pContact.publicKey; });
                    if (existingHeatContact) {
                        existingHeatContact.activityTimestamp = p2pContact.activityTimestamp;
                    }
                    else {
                        p2pContact['isP2POnlyContact'] = true;
                        _this.contacts.push(p2pContact);
                    }
                });
                _this.contacts = _this.contacts.filter(function (contact) { return contact.publicKey && contact.account != _this.account; })
                    .map(function (contact) {
                    if (!contact['isP2POnlyContact']) {
                        contact['hasUnreadMessage'] = _this.contactHasUnreadMessage(contact);
                    }
                    contact['hasUnreadP2PMessage'] =
                        !(_this.p2pMessaging.offchainMode && _this.activePublicKey == contact.publicKey)
                            && _this.contactHasUnreadP2PMessage(contact);
                    return contact;
                })
                    .sort(function (c1, c2) { return (c2.activityTimestamp ? Math.abs(c2.activityTimestamp) : 0) - (c1.activityTimestamp ? Math.abs(c1.activityTimestamp) : 0); });
                if (_this.getActivePublicKey() == "0") {
                    _this.setActivePublicKey();
                }
            });
        });
    };
    UserContactsComponent.prototype.p2pStatus = function (contact) {
        if (!contact.publicKey)
            return;
        var room = this.p2pMessaging.getOneToOneRoom(contact.publicKey);
        if (room) {
            var peer = room.getPeer(contact.publicKey);
            if (peer && peer.isConnected()) {
                return "channelOpened";
            }
            else {
                if (room.state.entered != "not") {
                    return "roomRegistered";
                }
            }
        }
    };
    UserContactsComponent.prototype.contactHasUnreadMessage = function (contact) {
        return contact.timestamp > this.store.getNumber(contact.account, 0);
    };
    UserContactsComponent.prototype.contactHasUnreadP2PMessage = function (contact) {
        var room = this.p2pMessaging.getOneToOneRoom(contact.publicKey, true);
        if (room) {
            return this.p2pMessaging.roomHasUnreadMessage(room);
        }
        return false;
    };
    UserContactsComponent = __decorate([
        Component({
            selector: 'userContacts',
            styles: ["\n    .unread-symbol {\n      font-size: 22px;\n      color: #ff3301;\n      margin: 0 6px -6px 0;\n    }\n    .p2p-unread-symbol {\n      font-size: 22px;\n      color: green;\n      margin: 0 6px -6px 0;\n    }\n    @keyframes blinker {\n      80% {opacity: 0.5;}\n    }\n    .channelopened-status-symbol {\n      font-size: 22px;\n      color: green;\n      margin: 0 6px 4px 0;\n    }\n    .roomregistered-status-symbol {\n      font-size: 22px;\n      color: grey;\n      margin: 0 6px 4px 0;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <md-list flex layout=\"column\">\n        <md-list-item ng-repeat=\"contact in vm.contacts\" aria-label=\"Entry\">\n          <!--<div class=\"truncate-col unread-col left\">\n            <md-icon md-font-library=\"material-icons\" ng-class=\"{'has-unread-message': contact.hasUnreadMessage}\">fiber_manual_record</md-icon>\n          </div>-->\n          <span ng-if=\"contact.hasUnreadMessage\" class=\"unread-symbol\">*</span>\n          <span ng-if=\"contact.hasUnreadP2PMessage\" class=\"p2p-unread-symbol\">*</span>\n          <span ng-if=\"vm.p2pStatus(contact)=='channelOpened'\" class=\"channelopened-status-symbol\">\u25CF</span>\n          <span ng-if=\"vm.p2pStatus(contact)=='roomRegistered'\" class=\"roomregistered-status-symbol\">\u25CF</span>\n          <div class=\"truncate-col account-col left\">\n            <a href=\"#/messenger/{{contact.publicKey}}\" ng-class=\"{'active':contact.publicKey==vm.activePublicKey}\">{{contact.publicName || contact.account}}</a>\n          </div>\n        </md-list-item>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'heat', '$q', '$interval', '$timeout', '$location', '$rootScope', 'storage', 'P2PMessaging', '$mdToast'),
        __metadata("design:paramtypes", [Object, UserService,
            HeatService, Function, Function, Function, Object, Object, StorageService,
            P2PMessaging, Object])
    ], UserContactsComponent);
    return UserContactsComponent;
}());
var VirtualRepeatArdrTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatArdrTransactionsComponent, _super);
    function VirtualRepeatArdrTransactionsComponent($scope, $q, ardorTransactionsProviderFactory, settings, ardorPendingTransactions, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.ardorTransactionsProviderFactory = ardorTransactionsProviderFactory;
        _this.settings = settings;
        _this.ardorPendingTransactions = ardorPendingTransactions;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = _this.user.secretPhrase;
        _this.initializeVirtualRepeat(_this.ardorTransactionsProviderFactory.createProvider(_this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.ardorTimestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.encryptedMessage) {
                if (transaction.senderPublicKey !== _this.user.publicKey)
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.senderPublicKey, secretPhrase);
                else {
                    try {
                        var recipientPublicKey_1;
                        _this.ardorBlockExplorerService.getPublicKeyFromAddress(transaction.recipientRS).then(function (_publicKey) {
                            recipientPublicKey_1 = _publicKey;
                            transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, recipientPublicKey_1, secretPhrase);
                            transaction.json.message = transaction.message;
                        });
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000
            };
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        _this.PAGE_SIZE = 10;
        ardorPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            ardorPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatArdrTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatArdrTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatArdrTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatArdorTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'ardorTransactionsProviderFactory', 'settings', 'ardorPendingTransactions', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, ArdorTransactionsProviderFactory,
            SettingsService,
            ArdorPendingTransactionsService,
            UserService,
            ArdorBlockExplorerService])
    ], VirtualRepeatArdrTransactionsComponent);
    return VirtualRepeatArdrTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatBtcTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatBtcTransactionsComponent, _super);
    function VirtualRepeatBtcTransactionsComponent($scope, $q, btcTransactionsProviderFactory, settings, bitcoinPendingTransactions, user, bitcoinMessagesService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.btcTransactionsProviderFactory = btcTransactionsProviderFactory;
        _this.settings = settings;
        _this.bitcoinPendingTransactions = bitcoinPendingTransactions;
        _this.user = user;
        _this.bitcoinMessagesService = bitcoinMessagesService;
        _this.btcMessages = [];
        _this.getBitcoinMessages = function (privateKey, publicKey) {
            _this.btcMessages = [];
            var addr = _this.user.account;
            var messages = _this.bitcoinMessagesService.messages[addr];
            if (messages) {
                messages.forEach(function (entry) {
                    var parts = entry.message.split(':'), data = parts[0], nonce = parts[1];
                    var message = heat.crypto.decryptMessage(data, nonce, publicKey, privateKey);
                    _this.btcMessages.push({
                        txId: entry.txId,
                        message: message
                    });
                });
            }
        };
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var privateKey = _this.user.secretPhrase;
        var publicKey = _this.user.publicKey;
        _this.getBitcoinMessages(privateKey, publicKey);
        _this.initializeVirtualRepeat(_this.btcTransactionsProviderFactory.createProvider(_this.account), function (transaction) {
            transaction.amount = transaction.vout[0].value;
            _this.btcMessages.forEach(function (message) {
                if (message.txId == transaction.txid) {
                    transaction.displayMessage = message.message;
                    if (transaction.displayMessage.length > 13) {
                        transaction.displayMessage = transaction.displayMessage.substr(0, 10).concat('...');
                    }
                    transaction.message = message.message;
                }
            });
            transaction.dateTime = dateFormat(new Date(transaction.time * 1000), format);
            transaction.from = transaction.vin[0].addr;
            var totalInputs = 0;
            var inputs = '';
            for (var i = 0; i < transaction.vin.length; i++) {
                totalInputs += parseFloat(transaction.vin[i].value);
                inputs += "\n          " + transaction.vin[i].addr + " (" + transaction.vin[i].value + ")";
                if (transaction.vin[i].addr === _this.account) {
                    transaction.from = transaction.vin[i].addr;
                }
            }
            var totalOutputs = 0;
            var outputs = '';
            for (var i = 0; i < transaction.vout.length; i++) {
                totalOutputs += parseFloat(transaction.vout[i].value);
                if (transaction.vout[i].scriptPubKey.addresses) {
                    outputs += "\n            " + transaction.vout[i].scriptPubKey.addresses[0] + " (" + transaction.vout[i].value + ")";
                }
            }
            for (var i = 0; i < transaction.vout.length && transaction.vout[i].scriptPubKey.addresses; i++) {
                if (transaction.vout[i].scriptPubKey.addresses) {
                    transaction.to = transaction.vout[0].scriptPubKey.addresses[0];
                    break;
                }
            }
            if (transaction.from === transaction.to) {
                for (var i = 1; i < transaction.vout.length && transaction.vout[i].scriptPubKey.addresses; i++) {
                    transaction.to = transaction.vout[i].scriptPubKey.addresses[0];
                    transaction.amount = transaction.vout[i].value;
                    break;
                }
            }
            if (inputs.includes(_this.account)) {
                transaction.amount = "-" + transaction.amount;
            }
            else {
                for (var i = 0; i < transaction.vout.length; i++) {
                    if (transaction.vout[i].scriptPubKey.addresses && transaction.vout[i].scriptPubKey.addresses[0] === _this.account) {
                        transaction.to = _this.account;
                        transaction.amount = transaction.vout[i].value;
                    }
                }
            }
            if (!outputs.includes(_this.account) && transaction.vout.length > 1) {
                transaction.to = 'Multiple Outputs';
            }
            transaction.json = {
                txid: transaction.txid,
                time: transaction.dateTime,
                block: transaction.blockheight,
                totalInputs: totalInputs,
                totalOutputs: totalOutputs,
                confirmations: transaction.confirmations,
                fees: transaction.fees,
                inputs: inputs.trim(),
                outputs: outputs.trim(),
                size: transaction.size,
                message: transaction.message ? transaction.message : ''
            };
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        _this.PAGE_SIZE = 10;
        bitcoinPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            bitcoinPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatBtcTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatBtcTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatBtcTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatBtcTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col right\">Amount</div>\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>\n                <a target=\"_blank\" href=\"https://live.blockcypher.com/btc/tx/{{item.txid}}\">{{item.txid}}</a>\n              </span>\n            </div>\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span ng-show = \"item.to !== 'Multiple Outputs'\">{{item.to}}</span>\n              <a ng-show = \"item.to === 'Multiple Outputs'\" ng-click=\"vm.jsonDetails($event, item.json)\">{{item.to}}</a>\n            </div>\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col right\">\n              <span>{{item.amount}}</span>\n            </div>\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.displayMessage}}</span>\n            </div>\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'btcTransactionsProviderFactory', 'settings', 'bitcoinPendingTransactions', 'user', 'bitcoinMessagesService'),
        __metadata("design:paramtypes", [Object, Function, BtcTransactionsProviderFactory,
            SettingsService,
            BitcoinPendingTransactionsService,
            UserService,
            BitcoinMessagesService])
    ], VirtualRepeatBtcTransactionsComponent);
    return VirtualRepeatBtcTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatEthTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatEthTransactionsComponent, _super);
    function VirtualRepeatEthTransactionsComponent($scope, $q, ethTransactionsProviderFactory, settings, user, render, $mdPanel, controlCharRender, web3, ethereumPendingTransactions) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.ethTransactionsProviderFactory = ethTransactionsProviderFactory;
        _this.settings = settings;
        _this.user = user;
        _this.render = render;
        _this.$mdPanel = $mdPanel;
        _this.controlCharRender = controlCharRender;
        _this.web3 = web3;
        _this.ethereumPendingTransactions = ethereumPendingTransactions;
        _this.renderer = new EthTransactionRenderer(_this);
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.ethTransactionsProviderFactory.createProvider(_this.account), function (transaction) {
            var date = new Date(0);
            date.setUTCSeconds(transaction.timestamp);
            transaction['time'] = dateFormat(date, format);
            transaction['heightDisplay'] = 'no height';
            if (_this.personalize) {
                transaction['outgoing'] = _this.user.account == transaction.from;
                var amountVal = _this.renderer.renderAmount(transaction);
                transaction['renderedAmount'] = amountVal;
                transaction['renderedToFrom'] = _this.renderer.renderedToFrom(transaction);
            }
            var renderedInfo = _this.renderer.renderInfo(transaction);
            if (angular.isString(renderedInfo)) {
                transaction['renderedInfo'] = renderedInfo;
            }
            else if (angular.isObject(renderedInfo)) {
                renderedInfo.then(function (text) {
                    transaction['renderedInfo'] = text;
                });
            }
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        ethereumPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            ethereumPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatEthTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.transaction);
    };
    VirtualRepeatEthTransactionsComponent.prototype.imageUrl = function (contractAddress) {
        return "https://raw.githubusercontent.com/dmdeklerk/tokens/master/images/" + contractAddress + ".png";
    };
    VirtualRepeatEthTransactionsComponent.prototype.renderSync = function (transaction) {
        try {
            if (transaction['erc20']) {
                return JSON.stringify(transaction['erc20']);
            }
            return this.web3.parseInput(transaction.input);
        }
        catch (e) {
            console.log(e);
        }
    };
    VirtualRepeatEthTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatEthTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatEthTransactions',
            inputs: ['account', 'personalize'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- HEIGHT\n          <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">Height</div>\n          -->\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- ID -->\n          <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">Id</div>\n\n          <!-- INOUT -->\n          <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">In/Out</div>\n\n          <!-- TRANSACTION -->\n          <!-- <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">Transaction</div> -->\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">Amount</div>\n\n          <!-- TOFROM -->\n          <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">To/From</div>\n\n          <!-- INFO -->\n          <div class=\"truncate-col info-col left\" flex>Info</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- HEIGHT\n            <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">\n              <span ng-show=\"item.height!=2147483647\">{{item.heightDisplay}}</span>\n              <span>\n                <a target=\"_blank\" href=\"https://etherscan.io/block/{{item.heightDisplay}}\">{{item.heightDisplay}}</a>\n              </span>\n            </div>\n            -->\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- ID -->\n            <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">\n              <a target=\"_blank\" href=\"https://ethplorer.io/tx/{{item.hash}}\">{{item.hash}}</a>\n            </div>\n\n            <!-- INOUT -->\n            <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">\n              <md-icon md-font-library=\"material-icons\" ng-class=\"{outgoing: item.outgoing, incoming: !item.outgoing}\">\n                {{item.outgoing ? 'keyboard_arrow_up': 'keyboard_arrow_down'}}\n              </md-icon>\n            </div>\n\n            <!-- TRANSACTION -->\n            <!-- <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedTransactionType\"></span>\n            </div> -->\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedAmount\"></span>\n            </div>\n\n            <!-- TOFROM -->\n            <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedToFrom\"></span>\n            </div>\n\n            <!-- INFO -->\n            <div class=\"truncate-col info-col left\" flex>\n              <span ng-bind-html=\"item.renderedInfo\"></span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'ethTransactionsProviderFactory', 'settings', 'user', 'render', '$mdPanel', 'controlCharRender', 'web3', 'ethereumPendingTransactions'),
        __metadata("design:paramtypes", [Object, Function, EthTransactionsProviderFactory,
            SettingsService,
            UserService,
            RenderService, Object, ControlCharRenderService,
            Web3Service,
            EthereumPendingTransactionsService])
    ], VirtualRepeatEthTransactionsComponent);
    return VirtualRepeatEthTransactionsComponent;
}(VirtualRepeatComponent));
var EthTransactionRenderHelper = (function () {
    function EthTransactionRenderHelper(template, extractor) {
        this.template = template;
        this.extractor = extractor;
        this.$q = heat.$inject.get('$q');
    }
    EthTransactionRenderHelper.prototype.isPromise = function (val) {
        return angular.isObject(val) && angular.isFunction(val['then']);
    };
    EthTransactionRenderHelper.prototype.render = function (transaction) {
        var _this = this;
        var parts = this.extractor(transaction);
        var args = {};
        var promises = [];
        angular.forEach(parts, function (val, key) {
            if (_this.isPromise(val)) {
                promises.push(val);
                val.then(function (promiseVal) {
                    args[key] = promiseVal;
                });
            }
            else {
                args[key] = val;
            }
        });
        var template = angular.isFunction(this.template) ? this.template.call(null, transaction) : this.template;
        var text = (' ' + template).slice(1);
        if (promises.length > 0) {
            var deferred = this.$q.defer();
            this.$q.all(promises).then(function () {
                angular.forEach(args, function (val, key) {
                    text = text.replace(new RegExp("\\$" + key, 'g'), val);
                });
                deferred.resolve(text);
            });
            return deferred.promise;
        }
        angular.forEach(args, function (val, key) {
            text = text.replace(new RegExp("\\$" + key, 'g'), val);
        });
        return text;
    };
    return EthTransactionRenderHelper;
}());
var EthTransactionRenderer = (function () {
    function EthTransactionRenderer(provider) {
        var _this = this;
        this.provider = provider;
        this.TYPE_ETHEREUM_TRANSFER = 'eth:transfer';
        this.TYPE_ERC20_APPROVE = 'approve';
        this.TYPE_ERC20_ALLOWANCE = 'allowance';
        this.TYPE_ERC20_TRANSFER = 'transfer';
        this.TYPE_ERC20_TRANSFER_FROM = 'transferFrom';
        this.TYPE_ETHERDELTA_DEPOSIT_TOKEN = 'depositToken';
        this.TYPE_ETHERDELTA_WITHDRAWAL = 'withdraw';
        this.TYPE_ETHERDELTA_WITHDRAWAL_TOKEN = 'withdrawToken';
        this.TYPE_ETHERDELTA_ORDER = 'order';
        this.TYPE_ETHERDELTA_TRADE = 'trade';
        this.TYPE_ETHERDELTA_TRADE_BALANCES = 'tradeBalances';
        this.TYPE_ETHERDELTA_CANCEL_ORDER = 'cancelOrder';
        this.renderers = {};
        this.transactionTypes = {};
        var key;
        this.$q = heat.$inject.get('$q');
        this.ethTransactionParser = heat.$inject.get('ethTransactionParser');
        this.ethplorer = heat.$inject.get('ethplorer');
        key = this.TYPE_ETHEREUM_TRANSFER;
        this.transactionTypes[key] = 'TRANSFER';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return '<b>TRANSFER</b> $amount from $from to $to';
        }, function (t) {
            return {
                from: _this.account(t.from),
                to: _this.account(t.to),
                amount: _this.amount(t.value)
            };
        });
        key = this.TYPE_ERC20_APPROVE;
        this.transactionTypes[key] = 'ERC20 APPROVE';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return '<b>ERC20 APPROVE</b> $from $to $spender $value';
        }, function (t) {
            return {
                from: _this.account(t.from),
                to: _this.account(t.to),
                spender: _this.account(t.abi.decodedData.params[0].value),
                value: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ERC20_ALLOWANCE;
        this.transactionTypes[key] = 'ERC20 ALLOWANCE';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return '<b>ERC20 ALLOWANCE</b> ';
        }, function (t) {
            return {};
        });
        key = this.TYPE_ERC20_TRANSFER;
        this.transactionTypes[key] = 'ERC20 TRANSFER';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>ERC20 TRANSFER</b> Send $value $token from $from to $to";
        }, function (t) {
            return {
                token: _this.token(t.to),
                from: _this.account(t.from),
                to: _this.account(t.abi.decodedData.params[0].value),
                value: _this.amount(t.abi.decodedData.params[1].value, _this.ethplorer.tokenInfoCache[t.to])
            };
        });
        key = this.TYPE_ERC20_TRANSFER_FROM;
        this.transactionTypes[key] = 'ERC20 TRANSFER FROM';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>ERC20 TRANSFER FROM</b> $asset from $sender to $recipient amount $amount";
        }, function (t) {
            return {
                asset: _this.token(t.to),
                sender: _this.account(t.abi.decodedData.params[0].value),
                recipient: _this.account(t.abi.decodedData.params[1].value),
                amount: _this.amount(t.abi.decodedData.params[2].value, _this.ethplorer.tokenInfoCache[t.to])
            };
        });
        key = this.TYPE_ETHERDELTA_DEPOSIT_TOKEN;
        this.transactionTypes[key] = 'DELTA DEPOSIT';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA DEPOSIT</b> Deposit $amount $token";
        }, function (t) {
            return {
                token: _this.token(t.abi.decodedData.params[0].value),
                amount: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ETHERDELTA_WITHDRAWAL;
        this.transactionTypes[key] = 'DELTA WITHDRAW';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA WITHDRAW</b> Withdraw $amount";
        }, function (t) {
            return {
                amount: _this.amount(t.abi.decodedData.params[0].value)
            };
        });
        key = this.TYPE_ETHERDELTA_WITHDRAWAL_TOKEN;
        this.transactionTypes[key] = 'DELTA WITHDRAW TOKEN';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA WITHDRAW TOKEN</b> Withdraw $amount $token";
        }, function (t) {
            return {
                token: _this.token(t.abi.decodedData.params[0].value),
                amount: _this.amount(t.abi.decodedData.params[1].value)
            };
        });
        key = this.TYPE_ETHERDELTA_ORDER;
        this.transactionTypes[key] = 'DELTA ORDER';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA ORDER</b> Order get $amountGet $tokenGet pay $amountGive $tokenGive";
        }, function (t) {
            return {
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value
            };
        });
        key = this.TYPE_ETHERDELTA_TRADE;
        this.transactionTypes[key] = 'DELTA TRADE';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA TRADE</b> Trade get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount";
        }, function (t) {
            return {
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value,
                user: _this.account(t.abi.decodedData.params[6].value),
                amount: _this.amount(t.abi.decodedData.params[10].value)
            };
        });
        key = this.TYPE_ETHERDELTA_TRADE_BALANCES;
        this.transactionTypes[key] = 'DELTA TRADE BALANCES';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA TRADE BALANCES</b> Trade balances get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount";
        }, function (t) {
            return {
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                user: _this.account(t.abi.decodedData.params[4].value),
                amount: _this.amount(t.abi.decodedData.params[5].value)
            };
        });
        key = this.TYPE_ETHERDELTA_CANCEL_ORDER;
        this.transactionTypes[key] = 'DELTA CANCEL ORDER';
        this.renderers[key] = new EthTransactionRenderHelper(function (t) {
            return "<b>DELTA CANCEL ORDER</b> Trade get $amountGet $tokenGet pay $amountGive $tokenGive from $user amount $amount";
        }, function (t) {
            return {
                tokenGet: _this.token(t.abi.decodedData.params[0].value),
                amountGet: _this.amount(t.abi.decodedData.params[1].value),
                tokenGive: _this.token(t.abi.decodedData.params[2].value),
                amountGive: _this.amount(t.abi.decodedData.params[3].value),
                expires: t.abi.decodedData.params[4].value
            };
        });
    }
    EthTransactionRenderer.prototype.renderTransactionType = function (transaction) {
        return 'txn type';
    };
    EthTransactionRenderer.prototype.renderAmount = function (transaction) {
        return this.amount(transaction.value);
    };
    EthTransactionRenderer.prototype.renderedToFrom = function (transaction) {
        if (transaction.from == this.provider.account) {
            return this.account(transaction.to);
        }
        return this.account(transaction.from);
    };
    EthTransactionRenderer.prototype.isOutgoing = function (transaction) {
        return transaction.from == this.provider.account;
    };
    EthTransactionRenderer.prototype.renderInfo = function (transaction) {
        var key = this.TYPE_ETHEREUM_TRANSFER;
        if (transaction.abi && transaction.abi.decodedData) {
            key = transaction.abi.decodedData.name;
        }
        var renderer = this.renderers[key];
        if (renderer)
            return renderer.render(transaction);
        return "not supported " + key;
    };
    EthTransactionRenderer.prototype.account = function (account) {
        if (account == this.provider.account) {
            return "<a target=\"_blank\" href=\"https://ethplorer.io/address/" + account + "\">Myself</a>";
        }
        return "<a target=\"_blank\" href=\"https://ethplorer.io/address/" + account + "\">" + account + "</a>";
    };
    EthTransactionRenderer.prototype.token = function (address) {
        var tokenInfo = this.ethplorer.tokenInfoCache[address];
        if (tokenInfo) {
            return "<a target=\"_blank\" href=\"https://ethplorer.io/address/" + address + "\">" + tokenInfo.symbol + "</a>";
        }
        return "<a target=\"_blank\" href=\"https://ethplorer.io/address/" + address + "\">" + address + "</a>";
    };
    EthTransactionRenderer.prototype.amount = function (amount, tokenInfo) {
        var str;
        amount = (amount + "") || "0";
        if (tokenInfo) {
            str = utils.formatQNT(amount, tokenInfo.decimals) + ' ' + tokenInfo.symbol;
        }
        else {
            str = utils.commaFormat(Number(amount).toFixed(18)).replace(/(\.\d*?[1-9])0+$/g, "$1") + ' ETH';
        }
        return "<span>" + str + "</span>";
    };
    return EthTransactionRenderer;
}());
var VirtualRepeatFIMKTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatFIMKTransactionsComponent, _super);
    function VirtualRepeatFIMKTransactionsComponent($scope, $q, fimkTransactionsProviderFactory, settings, fimkPendingTransactions, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.fimkTransactionsProviderFactory = fimkTransactionsProviderFactory;
        _this.settings = settings;
        _this.fimkPendingTransactions = fimkPendingTransactions;
        _this.user = user;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = _this.user.secretPhrase;
        _this.initializeVirtualRepeat(_this.fimkTransactionsProviderFactory.createProvider(_this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.senderPublicKey) {
                if (transaction.attachment.senderPublicKey !== _this.user.publicKey)
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.attachment.senderPublicKey, secretPhrase);
                else {
                    try {
                        transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.attachment.recipientPublicKey, secretPhrase);
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000,
                message: transaction.message
            };
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        _this.PAGE_SIZE = 15;
        fimkPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            fimkPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatFIMKTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatFIMKTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatFIMKTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatFimkTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'fimkTransactionsProviderFactory', 'settings', 'fimkPendingTransactions', 'user'),
        __metadata("design:paramtypes", [Object, Function, FimkTransactionsProviderFactory,
            SettingsService,
            FimkPendingTransactionsService,
            UserService])
    ], VirtualRepeatFIMKTransactionsComponent);
    return VirtualRepeatFIMKTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatIotaTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatIotaTransactionsComponent, _super);
    function VirtualRepeatIotaTransactionsComponent($scope, $q, iotaTransactionsProviderFactory, settings, iotaPendingTransactions, user, iotaBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.iotaTransactionsProviderFactory = iotaTransactionsProviderFactory;
        _this.settings = settings;
        _this.iotaPendingTransactions = iotaPendingTransactions;
        _this.user = user;
        _this.iotaBlockExplorerService = iotaBlockExplorerService;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.iotaTransactionsProviderFactory.createProvider(_this.user.secretPhrase), function (bundle) {
            bundle.dateTime = dateFormat(new Date(bundle[0].timestamp * 1000), _this.settings.get(SettingsService.DATEFORMAT_DEFAULT));
            bundle.bundleId = bundle[0].hash;
            bundle.forEach(function (tx) {
                if (!bundle.from && tx.value < 0)
                    bundle.from = tx.address;
                else if (bundle.from && tx.value < 0 && bundle.from !== tx.address)
                    bundle.from = 'Multiple Inputs';
                if (!bundle.to && tx.value > 0) {
                    bundle.to = tx.address;
                    bundle.amount = tx.value;
                }
            });
            bundle.displayFromAddress = bundle.from.substring(0, 55).concat('...');
            bundle.displayToAddress = bundle.to.substring(0, 55).concat('...');
            bundle.displayBundleAddress = bundle.bundleId.substring(0, 50).concat('...');
            bundle.json = {
                bundle: bundle.bundleId,
                time: bundle.dateTime,
                from: bundle.from,
                to: bundle.to,
                amount: bundle.amount,
            };
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        iotaPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            iotaPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatIotaTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatIotaTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatIotaTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatIotaTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- BUNDLE ID  -->\n          <div class=\"truncate-col bundle-col left\">Bundle ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- Bundle ID -->\n            <div class=\"truncate-col bundle-col left\" >\n              <span>\n                <a target=\"_blank\" href=\"https://thetangle.org/bundle/{{item.bundleId}}\">{{item.displayBundleAddress}}</a>\n              </span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.displayFromAddress}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.displayToAddress}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'iotaTransactionsProviderFactory', 'settings', 'iotaPendingTransactions', 'user', 'iotaBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, IotaTransactionsProviderFactory,
            SettingsService,
            IotaPendingTransactionsService,
            UserService,
            IotaBlockExplorerService])
    ], VirtualRepeatIotaTransactionsComponent);
    return VirtualRepeatIotaTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatNxtTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatNxtTransactionsComponent, _super);
    function VirtualRepeatNxtTransactionsComponent($scope, $q, nxtTransactionsProviderFactory, settings, nxtPendingTransactions, user, nxtBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.nxtTransactionsProviderFactory = nxtTransactionsProviderFactory;
        _this.settings = settings;
        _this.nxtPendingTransactions = nxtPendingTransactions;
        _this.user = user;
        _this.nxtBlockExplorerService = nxtBlockExplorerService;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var secretPhrase = _this.user.secretPhrase;
        _this.initializeVirtualRepeat(_this.nxtTransactionsProviderFactory.createProvider(_this.account), function (transaction) {
            transaction.amount = transaction.amountNQT / 100000000;
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.dateTime = dateFormat(date, format);
            transaction.from = transaction.senderRS;
            transaction.to = transaction.recipientRS;
            transaction.txid = transaction.transaction;
            transaction.message = '';
            if (transaction.attachment.encryptedMessage) {
                if (transaction.senderPublicKey !== _this.user.publicKey)
                    transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, transaction.senderPublicKey, secretPhrase);
                else {
                    try {
                        var recipientPublicKey_2;
                        _this.nxtBlockExplorerService.getPublicKeyFromAddress(transaction.recipientRS).then(function (_publicKey) {
                            recipientPublicKey_2 = _publicKey;
                            transaction.message = heat.crypto.decryptMessage(transaction.attachment.encryptedMessage.data, transaction.attachment.encryptedMessage.nonce, recipientPublicKey_2, secretPhrase);
                            transaction.json.message = transaction.message;
                        });
                    }
                    catch (e) {
                        transaction.message = '';
                    }
                }
            }
            transaction.json = {
                txid: transaction.transaction,
                time: transaction.dateTime,
                from: transaction.from,
                to: transaction.to,
                amount: transaction.amount,
                block: transaction.height,
                confirmations: transaction.confirmations,
                fee: transaction.feeNQT / 100000000
            };
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        var timeout = setTimeout(refresh, 10 * 1000);
        var listener = _this.determineLength.bind(_this);
        _this.PAGE_SIZE = 10;
        nxtPendingTransactions.addListener(listener);
        $scope.$on('$destroy', function () {
            nxtPendingTransactions.removeListener(listener);
            clearTimeout(timeout);
        });
        return _this;
    }
    VirtualRepeatNxtTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.txid);
    };
    VirtualRepeatNxtTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatNxtTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatNxtTransactions',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- TX ID  -->\n          <div class=\"truncate-col tx-col left\">Transaction ID</div>\n\n          <!-- FROM -->\n          <div class=\"truncate-col info-col left\">FROM</div>\n\n          <!-- TO -->\n          <div class=\"truncate-col info-col left\">TO</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- MESSAGE -->\n          <div class=\"truncate-col message-col left\">Message</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.dateTime}}</div>\n\n            <!-- TX ID -->\n            <div class=\"truncate-col tx-col left\" >\n              <span>{{item.txid}}</span>\n            </div>\n\n            <!-- FROM -->\n            <div class=\"truncate-col info-col left\">\n             <span>{{item.from}}</span>\n            </div>\n\n            <!-- TO -->\n            <div class=\"truncate-col info-col left\">\n              <span>{{item.to}}</span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">\n              <span>{{item.amount}}</span>\n            </div>\n\n            <!-- MESSAGE -->\n            <div class=\"truncate-col message-col left\">\n              <span>{{item.message}}</span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item.json)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'nxtTransactionsProviderFactory', 'settings', 'nxtPendingTransactions', 'user', 'nxtBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, NxtTransactionsProviderFactory,
            SettingsService,
            NxtPendingTransactionsService,
            UserService,
            NxtBlockExplorerService])
    ], VirtualRepeatNxtTransactionsComponent);
    return VirtualRepeatNxtTransactionsComponent;
}(VirtualRepeatComponent));
var VirtualRepeatTradesComponent = (function (_super) {
    __extends(VirtualRepeatTradesComponent, _super);
    function VirtualRepeatTradesComponent($scope, $q, heat, explorerTradesProviderFactory, settings, assetInfo) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.explorerTradesProviderFactory = explorerTradesProviderFactory;
        _this.settings = settings;
        _this.assetInfo = assetInfo;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.explorerTradesProviderFactory.createProvider(_this.account), function (trade) {
            var date = utils.timestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            var currecy = _this.asset(trade.currency);
            var asset = _this.asset(trade.asset);
            var decimals = currecy.decimals;
            trade.market = currecy.symbol + "/" + asset.symbol;
            trade.type = trade.buyer === _this.account ? 'Buy' : 'Sell';
            trade.price = (trade.price / (Math.pow(10, decimals))).toFixed(decimals);
            trade.amount = (trade.quantity / (Math.pow(10, decimals))).toFixed(decimals);
            trade.buyersellerName = trade.type === 'Buy' ? trade.sellerName : trade.buyerName;
            trade.buyerseller = trade.type === 'Buy' ? trade.seller : trade.buyer;
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        if (angular.isUndefined(_this.account)) {
            heat.subscriber.blockPopped({}, refresh, $scope);
            heat.subscriber.blockPushed({}, refresh, $scope);
        }
        return _this;
    }
    VirtualRepeatTradesComponent.prototype.asset = function (asset) {
        if (this.assetInfo.cache[asset] && this.assetInfo.cache[asset].symbol)
            return this.assetInfo.cache[asset];
        else
            this.assetInfo.getInfo(asset);
    };
    VirtualRepeatTradesComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Trade: ' + item.askOrder);
    };
    VirtualRepeatTradesComponent.prototype.onSelect = function (selectedTrade) { };
    VirtualRepeatTradesComponent = __decorate([
        Component({
            selector: 'virtualRepeatTrades',
            inputs: ['account', 'block', 'personalize', 'hideLabel'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- MARKET -->\n          <div class=\"truncate-col market-col left\">Market</div>\n\n          <!-- TYPE -->\n          <div class=\"truncate-col type-col left\" flex>Type</div>\n\n          <!-- PRICE -->\n          <div class=\"truncate-col price-col left\">Price</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\">Amount</div>\n\n          <!-- BUYER/ SELLER -->\n          <div class=\"truncate-col buyerseller-col left\">Buyer/ Seller</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- MARKET -->\n            <div class=\"truncate-col market-col left\">{{item.market}}</div>\n\n            <!-- TYPE -->\n            <div class=\"truncate-col type-col left\" flex>{{item.type}}</div>\n\n            <!-- PRICE -->\n            <div class=\"truncate-col price-col left\">{{item.price}}</div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\">{{item.amount}}</div>\n\n            <!-- BUYER/ SELLER -->\n            <div class=\"truncate-col buyerseller-col left\">\n              <a href=\"#/explorer-account/{{item.buyerseller}}/trades\">{{item.buyersellerName}} </a>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'explorerTradesProviderFactory', 'settings', 'assetInfo'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            ExplorerTradesProviderFactory,
            SettingsService,
            AssetInfoService])
    ], VirtualRepeatTradesComponent);
    return VirtualRepeatTradesComponent;
}(VirtualRepeatComponent));
var VirtualRepeatTransactionsComponent = (function (_super) {
    __extends(VirtualRepeatTransactionsComponent, _super);
    function VirtualRepeatTransactionsComponent($scope, $q, heat, transactionsProviderFactory, settings, user, render, $mdPanel, controlCharRender) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.transactionsProviderFactory = transactionsProviderFactory;
        _this.settings = settings;
        _this.user = user;
        _this.render = render;
        _this.$mdPanel = $mdPanel;
        _this.controlCharRender = controlCharRender;
        _this.renderer = new TransactionRenderer(_this);
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.transactionsProviderFactory.createProvider(_this.account, _this.block, _this.transactionObject), function (transaction) {
            var date = utils.timestampToDate(transaction.timestamp);
            transaction.time = dateFormat(date, format);
            transaction.heightDisplay = transaction.height == 2147483647 ? '*' : transaction.height;
            if (_this.personalize) {
                if (transaction.type == 2 && (transaction.subtype == 5 || transaction.subtype == 6)) {
                    transaction['outgoing'] = false;
                }
                else {
                    transaction['outgoing'] = _this.user.account == transaction.sender;
                }
                transaction['renderedTransactionType'] = _this.renderer.renderTransactionType(transaction);
                var amountVal = _this.renderer.renderAmount(transaction);
                if (angular.isString(amountVal)) {
                    transaction['renderedAmount'] = amountVal;
                }
                else if (angular.isObject(amountVal)) {
                    amountVal.then(function (val) {
                        transaction['renderedAmount'] = val;
                    });
                }
                transaction['renderedToFrom'] = _this.renderer.renderedToFrom(transaction);
            }
            var renderedInfo = _this.renderer.renderInfo(transaction);
            if (angular.isString(renderedInfo)) {
                transaction['renderedInfo'] = renderedInfo;
            }
            else if (angular.isObject(renderedInfo)) {
                renderedInfo.then(function (text) {
                    transaction['renderedInfo'] = text;
                });
            }
            transaction['messageText'] = _this.heat.getHeatMessageContents(transaction);
            if (angular.isString(transaction['messageText'])) {
                var messagePreview = transaction['messageText'].substr(0, 50);
                if (transaction['messageText'].length > 50) {
                    messagePreview += " ...";
                }
                transaction['messagePreview'] = messagePreview;
            }
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        if (angular.isString(_this.account)) {
            heat.subscriber.unconfirmedTransaction({ recipient: _this.account }, refresh, $scope);
            heat.subscriber.unconfirmedTransaction({ sender: _this.account }, refresh, $scope);
        }
        if (angular.isUndefined(_this.block) && angular.isUndefined(_this.account)) {
            heat.subscriber.unconfirmedTransaction({}, refresh, $scope);
            heat.subscriber.blockPopped({}, refresh, $scope);
            heat.subscriber.blockPushed({}, refresh, $scope);
        }
        return _this;
    }
    VirtualRepeatTransactionsComponent.prototype.showPopup = function (messageText) {
        var renderedHTML = this.render.render(messageText, [this.controlCharRender]);
        var position = this.$mdPanel.newPanelPosition().absolute().center();
        var config = {
            attachTo: angular.element(document.body),
            controller: function () { },
            controllerAs: 'vm',
            disableParentScroll: true,
            template: "\n        <div class=\"virtual-repeat-transactions-message-contents\" ng-bind-html=\"vm.renderedHTML\"></div>\n      ",
            hasBackdrop: true,
            panelClass: 'demo-dialog-example',
            position: position,
            trapFocus: true,
            zIndex: 150,
            clickOutsideToClose: true,
            escapeToClose: true,
            focusOnOpen: true,
            locals: {
                renderedHTML: renderedHTML
            }
        };
        this.$mdPanel.open(config);
    };
    VirtualRepeatTransactionsComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Transaction: ' + item.transaction);
    };
    VirtualRepeatTransactionsComponent.prototype.onSelect = function (selectedTransaction) { };
    VirtualRepeatTransactionsComponent = __decorate([
        Component({
            selector: 'virtualRepeatTransactions',
            inputs: ['account', 'block', 'personalize', 'transactionObject', 'hideLabel'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Transactions\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <!-- HEIGHT -->\n          <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">Height</div>\n\n          <!-- ID -->\n          <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">Id</div>\n\n          <!-- DATE -->\n          <div class=\"truncate-col date-col left\">Time</div>\n\n          <!-- INOUT -->\n          <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">In/Out</div>\n\n          <!-- TRANSACTION -->\n          <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">Transaction</div>\n\n          <!-- AMOUNT -->\n          <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">Amount</div>\n\n          <!-- TOFROM -->\n          <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">To/From</div>\n\n          <!-- INFO -->\n          <div class=\"truncate-col info-col left\" flex>Info</div>\n\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" class=\"row\">\n\n            <!-- HEIGHT -->\n            <div class=\"he truncate-col height-col left\" ng-if=\"!vm.personalize\">\n              <elipses-loading ng-show=\"item.height==2147483647\"></elipses-loading>\n              <span ng-show=\"item.height!=2147483647\">{{item.height}}</span>\n            </div>\n\n            <!-- ID -->\n            <div class=\"truncate-col id-col left\" ng-if=\"vm.personalize || vm.account\">\n              {{item.transaction}}\n            </div>\n\n            <!-- DATE -->\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n\n            <!-- INOUT -->\n            <div class=\"truncate-col inoutgoing-col left\" ng-if=\"vm.personalize\">\n              <md-icon md-font-library=\"material-icons\" ng-class=\"{outgoing: item.outgoing, incoming: !item.outgoing}\">\n                {{item.outgoing ? 'keyboard_arrow_up': 'keyboard_arrow_down'}}\n              </md-icon>\n            </div>\n\n            <!-- TRANSACTION -->\n            <div class=\"truncate-col transaction-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedTransactionType\"></span>\n            </div>\n\n            <!-- AMOUNT -->\n            <div class=\"truncate-col amount-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedAmount\"></span>\n            </div>\n\n            <!-- TOFROM -->\n            <div class=\"truncate-col tofrom-col left\" ng-if=\"vm.personalize\">\n              <span ng-bind-html=\"item.renderedToFrom\"></span>\n            </div>\n\n            <!-- INFO -->\n            <div class=\"truncate-col info-col left\" flex>\n              <span ng-bind-html=\"item.renderedInfo\"></span>\n              <span class=\"virtual-repeat-transactions-message\" ng-if=\"item.messageText\">\n                <md-button ng-click=\"vm.showPopup(item.messageText)\" class=\"md-icon-button\" md-no-ink>\n                  <md-icon md-font-library=\"material-icons\">message</md-icon>\n                </md-button>\n                <code>{{item.messagePreview}}</code>\n              </span>\n            </div>\n\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'transactionsProviderFactory', 'settings', 'user', 'render', '$mdPanel', 'controlCharRender'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            TransactionsProviderFactory,
            SettingsService,
            UserService,
            RenderService, Object, ControlCharRenderService])
    ], VirtualRepeatTransactionsComponent);
    return VirtualRepeatTransactionsComponent;
}(VirtualRepeatComponent));
var TransactionRenderHelper = (function () {
    function TransactionRenderHelper(template, extractor) {
        this.template = template;
        this.extractor = extractor;
        this.$q = heat.$inject.get('$q');
    }
    TransactionRenderHelper.prototype.isPromise = function (val) {
        return angular.isObject(val) && angular.isFunction(val['then']);
    };
    TransactionRenderHelper.prototype.render = function (transaction) {
        var _this = this;
        var parts = this.extractor(transaction);
        var args = {};
        var promises = [];
        angular.forEach(parts, function (val, key) {
            if (_this.isPromise(val)) {
                promises.push(val);
                val.then(function (promiseVal) {
                    args[key] = promiseVal;
                });
            }
            else {
                args[key] = val;
            }
        });
        var template = angular.isFunction(this.template) ? this.template.call(null, transaction) : this.template;
        var text = (' ' + template).slice(1);
        if (promises.length > 0) {
            var deferred = this.$q.defer();
            this.$q.all(promises).then(function () {
                angular.forEach(args, function (val, key) {
                    text = text.replace(new RegExp("\\$" + key, 'g'), val);
                });
                deferred.resolve(text);
            });
            return deferred.promise;
        }
        angular.forEach(args, function (val, key) {
            text = text.replace(new RegExp("\\$" + key, 'g'), val);
        });
        return text;
    };
    return TransactionRenderHelper;
}());
var TransactionRenderer = (function () {
    function TransactionRenderer(provider) {
        var _this = this;
        this.provider = provider;
        this.TYPE_PAYMENT = 0;
        this.TYPE_MESSAGING = 1;
        this.TYPE_COLORED_COINS = 2;
        this.TYPE_ACCOUNT_CONTROL = 4;
        this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT = 0;
        this.SUBTYPE_MESSAGING_ARBITRARY_MESSAGE = 0;
        this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE = 0;
        this.SUBTYPE_COLORED_COINS_ASSET_ISSUE_MORE = 1;
        this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER = 2;
        this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT = 3;
        this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT = 4;
        this.SUBTYPE_COLORED_COINS_ASK_ORDER_CANCELLATION = 5;
        this.SUBTYPE_COLORED_COINS_BID_ORDER_CANCELLATION = 6;
        this.SUBTYPE_COLORED_COINS_WHITELIST_ACCOUNT_ADDITION = 7;
        this.SUBTYPE_COLORED_COINS_WHITELIST_ACCOUNT_REMOVAL = 8;
        this.SUBTYPE_COLORED_COINS_WHITELIST_MARKET = 9;
        this.SUBTYPE_COLORED_COINS_ATOMIC_MULTI_TRANSFER = 10;
        this.SUBTYPE_ACCOUNT_CONTROL_EFFECTIVE_BALANCE_LEASING = 0;
        this.SUBTYPE_ACCOUNT_CONTROL_INTERNET_ADDRESS = 1;
        this.renderers = {};
        this.transactionTypes = {};
        var key;
        this.heat = heat.$inject.get('heat');
        this.assetInfo = heat.$inject.get('assetInfo');
        this.$q = heat.$inject.get('$q');
        key = this.TYPE_PAYMENT + ":" + this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT;
        this.transactionTypes[key] = 'TRANSFER HEAT';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>TRANSFER HEAT</b> From $sender to $recipient amount $amount';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                amount: _this.amount(t.amount, 8, "HEAT"),
                recipient: _this.account(t.recipient, t.recipientPublicName)
            };
        });
        key = this.TYPE_MESSAGING + ":" + this.SUBTYPE_MESSAGING_ARBITRARY_MESSAGE;
        this.transactionTypes[key] = 'SEND MESSAGE';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>SEND MESSAGE</b> From $sender to $recipient';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName)
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE;
        this.transactionTypes[key] = 'ISSUE ASSET';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? 'Asset $asset' : "<b>ISSUE ASSET</b> Issuer $sender asset $asset";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                asset: t.transaction
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER;
        this.transactionTypes[key] = 'TRANSFER ASSET';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : "<b>TRANSFER ASSET</b> $asset from $sender to $recipient amount $amount";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName),
                asset: _this.asset(t.attachment['asset']),
                amount: _this.amount(t.attachment['quantity'], 8),
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT;
        this.transactionTypes[key] = 'SELL ORDER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                "<b>SELL ORDER</b> $sender placed sell order $currency/$asset amount $amount price $price";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                currency: _this.asset(t.attachment['currency']),
                asset: _this.asset(t.attachment['asset']),
                amount: _this.amount(t.attachment['quantity'], 8),
                price: _this.amount(t.attachment['price'], 8),
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT;
        this.transactionTypes[key] = 'BUY ORDER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                "<b>BUY ORDER</b> $sender placed buy order $currency/$asset amount $amount price $price";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                currency: _this.asset(t.attachment['currency']),
                asset: _this.asset(t.attachment['asset']),
                amount: _this.amount(t.attachment['quantity'], 8),
                price: _this.amount(t.attachment['price'], 8),
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ASK_ORDER_CANCELLATION;
        this.transactionTypes[key] = 'CANCEL SELL';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                '<b>CANCEL SELL</b> $sender cancelled order $currency/$asset amount $amount price $price';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                order: t.attachment['order'],
                currency: _this.asset(t['cancelledAskCurrency']),
                asset: _this.asset(t['cancelledAskAsset']),
                amount: _this.amount(t['cancelledAskQuantity'], 8),
                price: _this.amount(t['cancelledAskPrice'], 8)
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_BID_ORDER_CANCELLATION;
        this.transactionTypes[key] = 'CANCEL BUY';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ?
                '$currency/$asset amount $amount price $price' :
                '<b>CANCEL BUY</b> $sender cancelled order $currency/$asset amount $amount price $price';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                order: t.attachment['order'],
                currency: _this.asset(t['cancelledBidCurrency']),
                asset: _this.asset(t['cancelledBidAsset']),
                amount: _this.amount(t['cancelledBidQuantity'], 8),
                price: _this.amount(t['cancelledBidPrice'], 8)
            };
        });
        key = this.TYPE_COLORED_COINS + ":" + this.SUBTYPE_COLORED_COINS_ATOMIC_MULTI_TRANSFER;
        this.transactionTypes[key] = 'MULTI TRANSFER';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? '' : '<b>MULTI TRANSFER</b> From $sender';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName)
            };
        });
        key = this.TYPE_ACCOUNT_CONTROL + ":" + this.SUBTYPE_ACCOUNT_CONTROL_EFFECTIVE_BALANCE_LEASING;
        this.transactionTypes[key] = 'BALANCE LEASE';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize ? 'Lease balance for $period blocks' : "<b>BALANCE LEASE</b> From $sender to $recipient for $period blocks";
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                recipient: _this.account(t.recipient, t.recipientPublicName),
                period: utils.commaFormat(t.attachment['period'].toString())
            };
        });
        key = this.TYPE_ACCOUNT_CONTROL + ":" + this.SUBTYPE_ACCOUNT_CONTROL_INTERNET_ADDRESS;
        this.transactionTypes[key] = 'INTERNET ADDRESS';
        this.renderers[key] = new TransactionRenderHelper(function (t) {
            return provider.personalize
                ? 'internet address $a'
                : '<b>REGISTER INTERNET ADDRESS</b> $sender registered internet address "$a"';
        }, function (t) {
            return {
                sender: _this.account(t.sender, t.senderPublicName),
                a: t.attachment['internetAddress']
            };
        });
    }
    TransactionRenderer.prototype.renderTransactionType = function (transaction) {
        var key = transaction.type + ":" + transaction.subtype;
        return this.transactionTypes[key] || key;
    };
    TransactionRenderer.prototype.renderAmount = function (transaction) {
        var _this = this;
        if (transaction.type == this.TYPE_PAYMENT && transaction.subtype == this.SUBTYPE_PAYMENT_ORDINARY_PAYMENT) {
            var amount = transaction.amount;
            var symbol = 'HEAT';
            var neg = transaction.sender == this.provider.account;
            return this.formatAmount(amount, symbol, neg);
        }
        if (transaction.type == this.TYPE_COLORED_COINS) {
            var amount_1 = null;
            var neg_1 = null;
            var currency = null;
            switch (transaction.subtype) {
                case this.SUBTYPE_COLORED_COINS_ASSET_ISSUANCE:
                case this.SUBTYPE_COLORED_COINS_ASSET_ISSUE_MORE: {
                    amount_1 = transaction.attachment['quantity'];
                    currency = transaction.transaction;
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_ASSET_TRANSFER: {
                    amount_1 = transaction.attachment['quantity'];
                    neg_1 = transaction.sender == this.provider.account;
                    currency = transaction.attachment['asset'];
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_ASK_ORDER_PLACEMENT: {
                    amount_1 = transaction.attachment['quantity'];
                    currency = transaction.attachment['asset'];
                    neg_1 = true;
                    break;
                }
                case this.SUBTYPE_COLORED_COINS_BID_ORDER_PLACEMENT: {
                    amount_1 = utils.calculateTotalOrderPriceQNT(transaction.attachment['quantity'], transaction.attachment['price']);
                    currency = transaction.attachment['currency'];
                    neg_1 = true;
                    break;
                }
            }
            if (angular.isString(amount_1)) {
                if (angular.isDefined(this.assetInfo.cache[currency])) {
                    var symbol = this.assetInfo.cache[currency].symbol;
                    if (angular.isString(symbol)) {
                        return this.formatAmount(amount_1, symbol, neg_1);
                    }
                }
                var deferred_1 = this.$q.defer();
                this.assetInfo.getInfo(currency).then(function (info) {
                    deferred_1.resolve(_this.formatAmount(amount_1, info.symbol, neg_1));
                }, deferred_1.reject);
                return deferred_1.promise;
            }
        }
    };
    TransactionRenderer.prototype.renderedToFrom = function (transaction) {
        if (transaction.sender == this.provider.account) {
            return this.account(transaction.recipient, transaction.recipientPublicName);
        }
        return this.account(transaction.sender, transaction.senderPublicName);
    };
    TransactionRenderer.prototype.formatAmount = function (amount, symbol, neg) {
        var returns = this.amount(amount, 8, symbol);
        return (neg ? '-' : '+') + returns;
    };
    TransactionRenderer.prototype.isOutgoing = function (transaction) {
        return transaction.sender == this.provider.account;
    };
    TransactionRenderer.prototype.renderInfo = function (transaction) {
        var renderer = this.renderers[transaction.type + ":" + transaction.subtype];
        if (renderer)
            return renderer.render(transaction);
        return "not supported type=" + transaction.type + " subtype=" + transaction.subtype;
    };
    TransactionRenderer.prototype.account = function (account, publicName) {
        return account == '0' ? '' : "<a href=\"#/explorer-account/" + account + "/transactions\">" + (publicName || account) + "</a>";
    };
    TransactionRenderer.prototype.amount = function (amountHQT, decimals, symbol) {
        return "<span>" + utils.formatQNT(amountHQT || "0", decimals) + " " + (symbol || "") + "</span>";
    };
    TransactionRenderer.prototype.asset = function (asset) {
        if (asset == "5592059897546023466")
            return "<b>BTC</b>";
        if (asset == "0")
            return "<b>HEAT</b>";
        if (this.assetInfo.cache[asset] && this.assetInfo.cache[asset].symbol)
            return this.assetInfo.cache[asset].symbol;
        else
            this.assetInfo.getInfo(asset);
        return asset;
    };
    return TransactionRenderer;
}());
var EventEmitter = (function () {
    function EventEmitter() {
        this.cache = new EventEmitterCache();
    }
    EventEmitter.prototype.addListener = function (event, listener) {
        this.cache.add(event, listener);
    };
    EventEmitter.prototype.removeListener = function (event, listener) {
        this.cache.remove(event, listener);
    };
    EventEmitter.prototype.on = function (event, listener) {
        this.addListener(event, listener);
    };
    EventEmitter.prototype.removeAllListeners = function (event) {
        var _this = this;
        if (angular.isDefined(event)) {
            this.cache.get(event).forEach(function (listener) {
                _this.cache.remove(event, listener);
            });
        }
        else {
            this.cache.clear();
        }
    };
    EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.cache.get(event).forEach(function (listener) {
            listener.apply(null, args);
        });
    };
    return EventEmitter;
}());
var EventEmitterCache = (function () {
    function EventEmitterCache() {
        this.cache = {};
    }
    EventEmitterCache.prototype.clear = function () {
        this.cache = {};
    };
    EventEmitterCache.prototype.add = function (event, listener) {
        if (!angular.isDefined(this.cache[event])) {
            this.cache[event] = [];
        }
        this.cache[event].push(listener);
    };
    EventEmitterCache.prototype.remove = function (event, listener) {
        if (angular.isDefined(this.cache[event])) {
            this.cache[event] = this.cache[event].filter(function (l) { return l != listener; });
            if (this.cache[event].length === 0) {
                delete this.cache[event];
            }
        }
    };
    EventEmitterCache.prototype.get = function (event) {
        return this.cache[event] || [];
    };
    return EventEmitterCache;
}());
var converters;
(function (converters) {
    var charToNibble = {};
    var nibbleToChar = [];
    var i;
    for (i = 0; i <= 9; ++i) {
        var character = i.toString();
        charToNibble[character] = i;
        nibbleToChar.push(character);
    }
    for (i = 10; i <= 15; ++i) {
        var lowerChar = String.fromCharCode('a'.charCodeAt(0) + i - 10);
        var upperChar = String.fromCharCode('A'.charCodeAt(0) + i - 10);
        charToNibble[lowerChar] = i;
        charToNibble[upperChar] = i;
        nibbleToChar.push(lowerChar);
    }
    function byteArrayToHexString(bytes) {
        var str = '';
        for (var i = 0; i < bytes.length; ++i) {
            if (bytes[i] < 0) {
                bytes[i] += 256;
            }
            str += nibbleToChar[bytes[i] >> 4] + nibbleToChar[bytes[i] & 0x0F];
        }
        return str;
    }
    converters.byteArrayToHexString = byteArrayToHexString;
    function stringToByteArray(stringValue) {
        var str = unescape(encodeURIComponent(stringValue));
        var bytes = new Array(str.length);
        for (var i = 0; i < str.length; ++i) {
            bytes[i] = str.charCodeAt(i);
        }
        return bytes;
    }
    converters.stringToByteArray = stringToByteArray;
    function hexStringToByteArray(str) {
        var bytes = [];
        var i = 0;
        if (0 !== str.length % 2) {
            bytes.push(charToNibble[str.charAt(0)]);
            ++i;
        }
        for (; i < str.length - 1; i += 2) {
            bytes.push((charToNibble[str.charAt(i)] << 4) + charToNibble[str.charAt(i + 1)]);
        }
        return bytes;
    }
    converters.hexStringToByteArray = hexStringToByteArray;
    function stringToHexString(str) {
        return byteArrayToHexString(stringToByteArray(str));
    }
    converters.stringToHexString = stringToHexString;
    function hexStringToString(hex) {
        return byteArrayToString(hexStringToByteArray(hex));
    }
    converters.hexStringToString = hexStringToString;
    function checkBytesToIntInput(bytes, numBytes, opt_startIndex) {
        var startIndex = opt_startIndex || 0;
        if (startIndex < 0) {
            throw new Error('Start index should not be negative');
        }
        if (bytes.length < startIndex + numBytes) {
            throw new Error('Need at least ' + (numBytes) + ' bytes to convert to an integer');
        }
        return startIndex;
    }
    function byteArrayToSignedShort(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 2, opt_startIndex);
        var value = bytes[index];
        value += bytes[index + 1] << 8;
        return value;
    }
    converters.byteArrayToSignedShort = byteArrayToSignedShort;
    function byteArrayToSignedInt32(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 4, opt_startIndex);
        var value = bytes[index];
        value += bytes[index + 1] << 8;
        value += bytes[index + 2] << 16;
        value += bytes[index + 3] << 24;
        return value;
    }
    converters.byteArrayToSignedInt32 = byteArrayToSignedInt32;
    function byteArrayToBigInteger(bytes, opt_startIndex) {
        var index = checkBytesToIntInput(bytes, 8, opt_startIndex);
        var value = new BigInteger("0", 10);
        var temp1, temp2;
        for (var i = 7; i >= 0; i--) {
            temp1 = value.multiply(new BigInteger("256", 10));
            temp2 = temp1.add(new BigInteger(bytes[opt_startIndex + i].toString(10), 10));
            value = temp2;
        }
        return value;
    }
    converters.byteArrayToBigInteger = byteArrayToBigInteger;
    function byteArrayToWordArray(byteArray) {
        var i = 0, offset = 0, word = 0, len = byteArray.length;
        var words = new Uint32Array(((len / 4) | 0) + (len % 4 == 0 ? 0 : 1));
        while (i < (len - (len % 4))) {
            words[offset++] = (byteArray[i++] << 24) | (byteArray[i++] << 16) | (byteArray[i++] << 8) | (byteArray[i++]);
        }
        if (len % 4 != 0) {
            word = byteArray[i++] << 24;
            if (len % 4 > 1) {
                word = word | byteArray[i++] << 16;
            }
            if (len % 4 > 2) {
                word = word | byteArray[i++] << 8;
            }
            words[offset] = word;
        }
        return { sigBytes: len, words: words };
    }
    converters.byteArrayToWordArray = byteArrayToWordArray;
    function wordArrayToByteArray(wordArray) {
        var len = wordArray.words.length;
        if (len == 0) {
            return new Array(0);
        }
        var byteArray = new Array(wordArray.sigBytes);
        var offset = 0, word, i;
        for (i = 0; i < len - 1; i++) {
            word = wordArray.words[i];
            byteArray[offset++] = word >> 24;
            byteArray[offset++] = (word >> 16) & 0xff;
            byteArray[offset++] = (word >> 8) & 0xff;
            byteArray[offset++] = word & 0xff;
        }
        word = wordArray.words[len - 1];
        byteArray[offset++] = word >> 24;
        if (wordArray.sigBytes % 4 == 0) {
            byteArray[offset++] = (word >> 16) & 0xff;
            byteArray[offset++] = (word >> 8) & 0xff;
            byteArray[offset++] = word & 0xff;
        }
        if (wordArray.sigBytes % 4 > 1) {
            byteArray[offset++] = (word >> 16) & 0xff;
        }
        if (wordArray.sigBytes % 4 > 2) {
            byteArray[offset++] = (word >> 8) & 0xff;
        }
        return byteArray;
    }
    converters.wordArrayToByteArray = wordArrayToByteArray;
    function byteArrayToString(bytes, opt_startIndex, length) {
        if (length == 0) {
            return "";
        }
        if (opt_startIndex && length) {
            var index = checkBytesToIntInput(bytes, parseInt(length, 10), parseInt(opt_startIndex, 10));
            bytes = bytes.slice(opt_startIndex, opt_startIndex + length);
        }
        return decodeURIComponent(escape(String.fromCharCode.apply(null, bytes)));
    }
    converters.byteArrayToString = byteArrayToString;
    function byteArrayToShortArray(byteArray) {
        var shortArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var i;
        for (i = 0; i < 16; i++) {
            shortArray[i] = byteArray[i * 2] | byteArray[i * 2 + 1] << 8;
        }
        return shortArray;
    }
    converters.byteArrayToShortArray = byteArrayToShortArray;
    function shortArrayToByteArray(shortArray) {
        var byteArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var i;
        for (i = 0; i < 16; i++) {
            byteArray[2 * i] = shortArray[i] & 0xff;
            byteArray[2 * i + 1] = shortArray[i] >> 8;
        }
        return byteArray;
    }
    converters.shortArrayToByteArray = shortArrayToByteArray;
    function shortArrayToHexString(ary) {
        var res = [];
        for (var i = 0; i < ary.length; i++) {
            res.push(nibbleToChar[(ary[i] >> 4) & 0x0f], nibbleToChar[ary[i] & 0x0f], nibbleToChar[(ary[i] >> 12) & 0x0f], nibbleToChar[(ary[i] >> 8) & 0x0f]);
        }
        return res.join("");
    }
    converters.shortArrayToHexString = shortArrayToHexString;
    function int32ToBytes(x, opt_bigEndian) {
        return intToBytes_(x, 4, 4294967295, opt_bigEndian);
    }
    converters.int32ToBytes = int32ToBytes;
    function intToBytes_(x, numBytes, unsignedMax, opt_bigEndian) {
        var signedMax = Math.floor(unsignedMax / 2);
        var negativeMax = (signedMax + 1) * -1;
        if (x != Math.floor(x) || x < negativeMax || x > unsignedMax) {
            throw new Error(x + ' is not a ' + (numBytes * 8) + ' bit integer');
        }
        var bytes = [];
        var current;
        var numberType = x >= 0 && x <= signedMax ? 0 :
            x > signedMax && x <= unsignedMax ? 1 : 2;
        if (numberType == 2) {
            x = (x * -1) - 1;
        }
        for (var i = 0; i < numBytes; i++) {
            if (numberType == 2) {
                current = 255 - (x % 256);
            }
            else {
                current = x % 256;
            }
            if (opt_bigEndian) {
                bytes.unshift(current);
            }
            else {
                bytes.push(current);
            }
            if (numberType == 1) {
                x = Math.floor(x / 256);
            }
            else {
                x = x >> 8;
            }
        }
        return bytes;
    }
})(converters || (converters = {}));
var heat;
(function (heat) {
    var crypto;
    (function (crypto_1) {
        var _hash = {
            init: SHA256_init,
            update: SHA256_write,
            getBytes: SHA256_finalize
        };
        crypto_1.SHA256 = _hash;
        function simpleHash(message) {
            _hash.init();
            _hash.update(message);
            return _hash.getBytes();
        }
        function curve25519_clamp(curve) {
            curve[0] &= 0xFFF8;
            curve[15] &= 0x7FFF;
            curve[15] |= 0x4000;
            return curve;
        }
        function calculateStringHash(inputString) {
            var hexString = converters.stringToHexString(inputString);
            var bytes = converters.hexStringToByteArray(hexString);
            var hashBytes = simpleHash(bytes);
            return converters.byteArrayToHexString(hashBytes);
        }
        crypto_1.calculateStringHash = calculateStringHash;
        function byteArrayToBigInteger(byteArray, startIndex) {
            var value = new BigInteger("0", 10);
            var temp1, temp2;
            for (var i = byteArray.length - 1; i >= 0; i--) {
                temp1 = value.multiply(new BigInteger("256", 10));
                temp2 = temp1.add(new BigInteger(byteArray[i].toString(10), 10));
                value = temp2;
            }
            return value;
        }
        function calculateFullHash(unsignedTransaction, signature) {
            var unsignedTransactionBytes = converters.hexStringToByteArray(unsignedTransaction);
            var signatureBytes = converters.hexStringToByteArray(signature);
            var signatureHash = simpleHash(signatureBytes);
            _hash.init();
            _hash.update(unsignedTransactionBytes);
            _hash.update(signatureHash);
            var fullHash = _hash.getBytes();
            return converters.byteArrayToHexString(fullHash);
        }
        crypto_1.calculateFullHash = calculateFullHash;
        function fullNameToHash(fullNameUTF8) {
            _hash.init();
            _hash.update(converters.stringToByteArray(fullNameUTF8));
            var slice = (converters.hexStringToByteArray(converters.byteArrayToHexString(_hash.getBytes()))).slice(0, 8);
            return byteArrayToBigInteger(slice).toString();
        }
        crypto_1.fullNameToHash = fullNameToHash;
        function calculateTransactionId(fullHashHex) {
            var slice = (converters.hexStringToByteArray(fullHashHex)).slice(0, 8);
            var transactionId = byteArrayToBigInteger(slice).toString();
            return transactionId;
        }
        crypto_1.calculateTransactionId = calculateTransactionId;
        function secretPhraseToPublicKey(secretPhrase) {
            var secretHex = converters.stringToHexString(secretPhrase);
            var secretPhraseBytes = converters.hexStringToByteArray(secretHex);
            var digest = simpleHash(secretPhraseBytes);
            return converters.byteArrayToHexString(curve25519.keygen(digest).p);
        }
        crypto_1.secretPhraseToPublicKey = secretPhraseToPublicKey;
        function getPrivateKey(secretPhrase) {
            SHA256_init();
            SHA256_write(converters.stringToByteArray(secretPhrase));
            return converters.shortArrayToHexString(curve25519_clamp(converters.byteArrayToShortArray(SHA256_finalize())));
        }
        crypto_1.getPrivateKey = getPrivateKey;
        function getAccountId(secretPhrase) {
            var publicKey = this.secretPhraseToPublicKey(secretPhrase);
            return this.getAccountIdFromPublicKey(publicKey);
        }
        crypto_1.getAccountId = getAccountId;
        function getAccountIdFromPublicKey(publicKey) {
            _hash.init();
            _hash.update(converters.hexStringToByteArray(publicKey));
            var account = _hash.getBytes();
            var slice = (converters.hexStringToByteArray(converters.byteArrayToHexString(account))).slice(0, 8);
            return byteArrayToBigInteger(slice).toString();
        }
        crypto_1.getAccountIdFromPublicKey = getAccountIdFromPublicKey;
        function signBytes(message, secretPhrase) {
            var messageBytes = converters.hexStringToByteArray(message);
            var secretPhraseBytes = converters.hexStringToByteArray(secretPhrase);
            var digest = simpleHash(secretPhraseBytes);
            var s = curve25519.keygen(digest).s;
            var m = simpleHash(messageBytes);
            _hash.init();
            _hash.update(m);
            _hash.update(s);
            var x = _hash.getBytes();
            var y = curve25519.keygen(x).p;
            _hash.init();
            _hash.update(m);
            _hash.update(y);
            var h = _hash.getBytes();
            var v = curve25519.sign(h, x, s);
            return converters.byteArrayToHexString(v.concat(h));
        }
        crypto_1.signBytes = signBytes;
        function verifyBytes(signature, message, publicKey) {
            var signatureBytes = converters.hexStringToByteArray(signature);
            var messageBytes = converters.hexStringToByteArray(message);
            var publicKeyBytes = converters.hexStringToByteArray(publicKey);
            var v = signatureBytes.slice(0, 32);
            var h = signatureBytes.slice(32);
            var y = curve25519.verify(v, h, publicKeyBytes);
            var m = simpleHash(messageBytes);
            _hash.init();
            _hash.update(m);
            _hash.update(y);
            var h2 = _hash.getBytes();
            return areByteArraysEqual(h, h2);
        }
        crypto_1.verifyBytes = verifyBytes;
        function areByteArraysEqual(bytes1, bytes2) {
            if (bytes1.length !== bytes2.length) {
                return false;
            }
            for (var i = 0; i < bytes1.length; ++i) {
                if (bytes1[i] !== bytes2[i])
                    return false;
            }
            return true;
        }
        function encryptNote(message, options, secretPhrase, uncompressed) {
            if (!options.sharedKey) {
                if (!options.privateKey) {
                    options.privateKey = converters.hexStringToByteArray(this.getPrivateKey(secretPhrase));
                }
                if (!options.publicKey) {
                    throw new Error('Missing publicKey argument');
                }
            }
            var encrypted = encryptData(converters.stringToByteArray(message), options, uncompressed);
            return {
                "message": converters.byteArrayToHexString(encrypted.data),
                "nonce": converters.byteArrayToHexString(encrypted.nonce)
            };
        }
        crypto_1.encryptNote = encryptNote;
        function encryptBinaryNote(message, options, secretPhrase, uncompressed) {
            if (!options.sharedKey) {
                if (!options.privateKey) {
                    options.privateKey = converters.hexStringToByteArray(this.getPrivateKey(secretPhrase));
                }
                if (!options.publicKey) {
                    throw new Error('Missing publicKey argument');
                }
            }
            var encrypted = encryptData(message, options, uncompressed);
            return {
                "message": converters.byteArrayToHexString(encrypted.data),
                "nonce": converters.byteArrayToHexString(encrypted.nonce)
            };
        }
        crypto_1.encryptBinaryNote = encryptBinaryNote;
        function getSharedKey(key1, key2) {
            return converters.shortArrayToByteArray(curve25519_(converters.byteArrayToShortArray(key1), converters.byteArrayToShortArray(key2), null));
        }
        function encryptData(plaintext, options, uncompressed) {
            var crypto = window.crypto || window['msCrypto'];
            if (!crypto) {
                throw new Error("Browser not supported");
            }
            if (!options.sharedKey) {
                options.sharedKey = getSharedKey(options.privateKey, options.publicKey);
            }
            options.nonce = new Uint8Array(32);
            crypto.getRandomValues(options.nonce);
            var compressedPlaintext = uncompressed ? new Uint8Array(plaintext) : pako.gzip(new Uint8Array(plaintext));
            var data = aesEncrypt(compressedPlaintext, options);
            return {
                "nonce": options.nonce,
                "data": data
            };
        }
        function aesEncrypt(plaintext, options) {
            var crypto = window.crypto || window['msCrypto'];
            var text = converters.byteArrayToWordArray(plaintext);
            var sharedKey = options.sharedKey ? options.sharedKey.slice(0) :
                getSharedKey(options.privateKey, options.publicKey);
            for (var i = 0; i < 32; i++) {
                sharedKey[i] ^= options.nonce[i];
            }
            var tmp = new Uint8Array(16);
            crypto.getRandomValues(tmp);
            var key = CryptoJS.SHA256(converters.byteArrayToWordArray(sharedKey));
            var iv = converters.byteArrayToWordArray(tmp);
            var encrypted = CryptoJS.AES.encrypt(text, key, {
                iv: iv
            });
            var ivOut = converters.wordArrayToByteArray(encrypted.iv);
            var ciphertextOut = converters.wordArrayToByteArray(encrypted.ciphertext);
            return ivOut.concat(ciphertextOut);
        }
        function encryptMessage(message, publicKey, secretPhrase, uncompressed) {
            var options = {
                "account": crypto.getAccountIdFromPublicKey(publicKey),
                "publicKey": converters.hexStringToByteArray(publicKey)
            };
            var encrypted = heat.crypto.encryptNote(message, options, secretPhrase, uncompressed);
            return {
                isText: true,
                data: encrypted.message,
                nonce: encrypted.nonce
            };
        }
        crypto_1.encryptMessage = encryptMessage;
        function decryptMessage(data, nonce, publicKey, secretPhrase, uncompressed) {
            var privateKey = converters.hexStringToByteArray(this.getPrivateKey(secretPhrase));
            var publicKeyBytes = converters.hexStringToByteArray(publicKey);
            var sharedKey = getSharedKey(privateKey, publicKeyBytes);
            var dataBytes = converters.hexStringToByteArray(data);
            var nonceBytes = converters.hexStringToByteArray(nonce);
            try {
                return decryptData(dataBytes, {
                    privateKey: privateKey,
                    publicKey: publicKeyBytes,
                    nonce: nonceBytes,
                    sharedKey: sharedKey
                }, uncompressed);
            }
            catch (e) {
                if (e instanceof RangeError || e == 'incorrect header check') {
                    console.error('Managed Exception: ' + e);
                    return decryptData(dataBytes, {
                        privateKey: privateKey,
                        publicKey: publicKeyBytes,
                        nonce: nonceBytes,
                        sharedKey: sharedKey
                    }, !uncompressed);
                }
                throw e;
            }
        }
        crypto_1.decryptMessage = decryptMessage;
        function decryptData(data, options, uncompressed) {
            var compressedPlaintext = aesDecrypt(data, options);
            var binData = new Uint8Array(compressedPlaintext);
            var data = uncompressed ? binData : pako.inflate(binData);
            return converters.byteArrayToString(data);
        }
        function aesDecrypt(ivCiphertext, options) {
            if (ivCiphertext.length < 16 || ivCiphertext.length % 16 != 0) {
                throw { name: "invalid ciphertext" };
            }
            var iv = converters.byteArrayToWordArray(ivCiphertext.slice(0, 16));
            var ciphertext = converters.byteArrayToWordArray(ivCiphertext.slice(16));
            var sharedKey = options.sharedKey.slice(0);
            for (var i = 0; i < 32; i++) {
                sharedKey[i] ^= options.nonce[i];
            }
            var key = CryptoJS.SHA256(converters.byteArrayToWordArray(sharedKey));
            var encrypted = CryptoJS.lib.CipherParams.create({
                ciphertext: ciphertext,
                iv: iv,
                key: key
            });
            var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                iv: iv
            });
            var plaintext = converters.wordArrayToByteArray(decrypted);
            return plaintext;
        }
        var PassphraseEncryptedMessage = (function () {
            function PassphraseEncryptedMessage(ciphertext, salt, iv, HMAC) {
                this.ciphertext = ciphertext;
                this.salt = salt;
                this.iv = iv;
                this.HMAC = HMAC;
            }
            PassphraseEncryptedMessage.decode = function (encoded) {
                var json = JSON.parse(encoded);
                return new PassphraseEncryptedMessage(json[0], json[1], json[2], json[3]);
            };
            PassphraseEncryptedMessage.prototype.encode = function () {
                return JSON.stringify([
                    this.ciphertext,
                    this.salt,
                    this.iv,
                    this.HMAC
                ]);
            };
            return PassphraseEncryptedMessage;
        }());
        crypto_1.PassphraseEncryptedMessage = PassphraseEncryptedMessage;
        function passphraseEncrypt(message, passphrase) {
            var salt = CryptoJS.lib.WordArray.random(256 / 8);
            var key = CryptoJS.PBKDF2(passphrase, salt, { iterations: 10, hasher: CryptoJS.algo.SHA256 });
            var iv = CryptoJS.lib.WordArray.random(128 / 8);
            var encrypted = CryptoJS.AES.encrypt(message, key, { iv: iv });
            var ciphertext = CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
            var salt_str = CryptoJS.enc.Hex.stringify(salt);
            var iv_str = CryptoJS.enc.Hex.stringify(iv);
            var key_str = CryptoJS.enc.Hex.stringify(key);
            var HMAC = CryptoJS.HmacSHA256(ciphertext + iv_str, key_str);
            var HMAC_str = CryptoJS.enc.Hex.stringify(HMAC);
            return new PassphraseEncryptedMessage(ciphertext, salt_str, iv_str, HMAC_str);
        }
        crypto_1.passphraseEncrypt = passphraseEncrypt;
        function passphraseDecrypt(cp, passphrase) {
            var iv = CryptoJS.enc.Hex.parse(cp.iv);
            var salt = CryptoJS.enc.Hex.parse(cp.salt);
            var key = CryptoJS.PBKDF2(passphrase, salt, { iterations: 10, hasher: CryptoJS.algo.SHA256 });
            var ciphertext = CryptoJS.enc.Base64.parse(cp.ciphertext);
            var key_str = CryptoJS.enc.Hex.stringify(key);
            var HMAC = CryptoJS.HmacSHA256(cp.ciphertext + cp.iv, key_str);
            var HMAC_str = CryptoJS.enc.Hex.stringify(HMAC);
            if (HMAC_str != cp.HMAC) {
                return null;
            }
            var _cp = CryptoJS.lib.CipherParams.create({
                ciphertext: ciphertext
            });
            var decrypted = CryptoJS.AES.decrypt(_cp, key, { iv: iv });
            return decrypted.toString(CryptoJS.enc.Utf8);
        }
        crypto_1.passphraseDecrypt = passphraseDecrypt;
    })(crypto = heat.crypto || (heat.crypto = {}));
})(heat || (heat = {}));
var heat;
(function (heat) {
    var easing;
    (function (easing) {
        function linear(t) { return t; }
        easing.linear = linear;
        function easeInQuad(t) { return t * t; }
        easing.easeInQuad = easeInQuad;
        function easeOutQuad(t) { return t * (2 - t); }
        easing.easeOutQuad = easeOutQuad;
        function easeInOutQuad(t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }
        easing.easeInOutQuad = easeInOutQuad;
        function easeInCubic(t) { return t * t * t; }
        easing.easeInCubic = easeInCubic;
        function easeOutCubic(t) { return (--t) * t * t + 1; }
        easing.easeOutCubic = easeOutCubic;
        function easeInOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }
        easing.easeInOutCubic = easeInOutCubic;
        function easeInQuart(t) { return t * t * t * t; }
        easing.easeInQuart = easeInQuart;
        function easeOutQuart(t) { return 1 - (--t) * t * t * t; }
        easing.easeOutQuart = easeOutQuart;
        function easeInOutQuart(t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t; }
        easing.easeInOutQuart = easeInOutQuart;
        function easeInQuint(t) { return t * t * t * t * t; }
        easing.easeInQuint = easeInQuint;
        function easeOutQuint(t) { return 1 + (--t) * t * t * t * t; }
        easing.easeOutQuint = easeOutQuint;
        function easeInOutQuint(t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }
        easing.easeInOutQuint = easeInOutQuint;
    })(easing = heat.easing || (heat.easing = {}));
})(heat || (heat = {}));
heat.Loader.directive('inputClear', function () {
    return {
        restrict: 'A',
        compile: function (element, attrs) {
            var color = attrs.inputClear;
            var action = attrs.ngModel + " = ''";
            element.after('<md-button aria-label="Close" class="animate-show md-icon-button md-accent"' +
                'ng-show="' + attrs.ngModel + '" ng-click="' + action + '"' +
                'style="position: absolute; top: 0px; right: -2px; margin-right:0px;">' +
                '<md-icon style="color:black;font-size: 18px;" md-font-library="material-icons">close</md-icon>' +
                '</md-button>');
        }
    };
});
var heat;
(function (heat) {
    var Iterator = (function () {
        function Iterator(array) {
            this.array = array;
            this.cursor = 0;
        }
        Iterator.prototype.hasMore = function () {
            return this.cursor < this.array.length;
        };
        Iterator.prototype.next = function () {
            return this.array[this.cursor++];
        };
        Iterator.prototype.peek = function () {
            return this.array[this.cursor];
        };
        return Iterator;
    }());
    heat.Iterator = Iterator;
})(heat || (heat = {}));
if (!Array.prototype['find']) {
    Array.prototype['find'] = function (predicate) {
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}
if (!String.prototype['repeat']) {
    String.prototype['repeat'] = function (count) {
        'use strict';
        if (this == null) {
            throw new TypeError('can\'t convert ' + this + ' to object');
        }
        var str = '' + this;
        count = +count;
        if (count != count) {
            count = 0;
        }
        if (count < 0) {
            throw new RangeError('repeat count must be non-negative');
        }
        if (count == Infinity) {
            throw new RangeError('repeat count must be less than infinity');
        }
        count = Math.floor(count);
        if (str.length == 0 || count == 0) {
            return '';
        }
        if (str.length * count >= 1 << 28) {
            throw new RangeError('repeat count must not overflow maximum string size');
        }
        var rpt = '';
        for (;;) {
            if ((count & 1) == 1) {
                rpt += str;
            }
            count >>>= 1;
            if (count == 0) {
                break;
            }
            str += str;
        }
        return rpt;
    };
}
var utils;
(function (utils) {
    function unformat(commaFormatted) {
        return commaFormatted ? commaFormatted.replace(/,/g, "") : "0";
    }
    utils.unformat = unformat;
    function commaFormat(amount) {
        if (typeof amount == 'undefined') {
            return '0';
        }
        amount = amount.replace(/,/g, '');
        var neg = amount.indexOf('-') == 0;
        if (neg) {
            amount = amount.substr(1);
        }
        amount = amount.split('.');
        var parts = amount[0].split("").reverse().join("").split(/(\d{3})/).reverse();
        var format = [];
        for (var i = 0; i < parts.length; i++) {
            if (parts[i]) {
                format.push(parts[i].split('').reverse().join(''));
            }
        }
        return (neg ? '-' : '') + format.join(',') + (amount.length == 2 ? ('.' + amount[1]) : '');
    }
    utils.commaFormat = commaFormat;
    function isNumber(value) {
        var num = String(value).replace(/,/g, '');
        if (num.match(/^\d+$/)) {
            return true;
        }
        else if (num.match(/^\d+\.\d+$/)) {
            return true;
        }
        return false;
    }
    utils.isNumber = isNumber;
    function isHex(value) {
        return angular.isString(value) && (/^[0-9a-fA-F]+$/.test(value));
    }
    utils.isHex = isHex;
    function isTimeWithinThreasholdLimit(inputTime) {
        return ((inputTime * 1000) + 6 * 60 * 60 * 1000) > new Date().getTime();
    }
    utils.isTimeWithinThreasholdLimit = isTimeWithinThreasholdLimit;
    function hasToManyDecimals(value, decimals) {
        var num = String(value).replace(/,/g, '');
        var parts = num.split(".");
        if (parts[1]) {
            var fractional = parts[1].replace(/[\s0]*$/g, "");
            if (fractional.length > decimals)
                return true;
        }
        return false;
    }
    utils.hasToManyDecimals = hasToManyDecimals;
    function parseResponse(response) {
        var parsed = {};
        if (angular.isString(response)) {
            try {
                parsed = JSON.parse(response);
            }
            catch (e) {
                parsed = { heatUtilParsingError: response };
            }
        }
        else {
            parsed = response;
        }
        return parsed;
    }
    utils.parseResponse = parseResponse;
    function ardorTimestampToDate(timestamp) {
        return new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0) + timestamp * 1000);
    }
    utils.ardorTimestampToDate = ardorTimestampToDate;
    function timestampToDate(timestamp) {
        return new Date(Date.UTC(2013, 10, 24, 12, 0, 0, 0) + timestamp * 1000);
    }
    utils.timestampToDate = timestampToDate;
    function epochTime(timestamp) {
        var t = timestamp ? timestamp : Date.now();
        return (t - 1385294400000 + 500) / 1000;
    }
    utils.epochTime = epochTime;
    function roundTo(value, decimals) {
        return String(parseFloat(value).toFixed(decimals));
    }
    utils.roundTo = roundTo;
    function delayPromise(promise, delay) {
        var $q = heat.$inject.get('$q');
        var deferred = $q.defer();
        var result, resolved = false, rejected = false;
        var timeout = setTimeout(function () {
            timeout = null;
            if (resolved) {
                deferred.resolve(result);
            }
            else if (rejected) {
                deferred.reject(result);
            }
        }, delay);
        promise.then(function (r) {
            result = r;
            resolved = true;
            if (timeout === null) {
                deferred.resolve(r);
            }
        }, function (r) {
            result = r;
            rejected = true;
            if (timeout === null) {
                deferred.reject(r);
            }
        });
        return deferred.promise;
    }
    utils.delayPromise = delayPromise;
    function convertToNQT(amountNXT) {
        if (typeof amountNXT == 'undefined') {
            return '0';
        }
        amountNXT = String(amountNXT).replace(/,/g, '');
        var parts = amountNXT.split(".");
        var amount = parts[0];
        if (parts.length == 1) {
            var fraction;
            fraction = "00000000";
        }
        else if (parts.length == 2) {
            if (parts[1].length <= 8) {
                var fraction = parts[1];
            }
            else {
                var fraction = parts[1].substring(0, 8);
            }
        }
        else {
            throw "Invalid input";
        }
        for (var i = fraction.length; i < 8; i++) {
            fraction += "0";
        }
        var result = amount + "" + fraction;
        if (!/^\d+$/.test(result)) {
            throw "Invalid input.";
        }
        result = result.replace(/^0+/, "");
        if (result === "") {
            result = "0";
        }
        return result;
    }
    utils.convertToNQT = convertToNQT;
    function formatQNT(quantity, decimals, returnNullZero) {
        var asfloat = utils.convertToQNTf(quantity, decimals);
        var cf = utils.commaFormat(asfloat);
        var parts = cf.split('.');
        var ret;
        if (!parts[1])
            ret = parts[0] + "." + "0".repeat(decimals);
        else if (parts[1].length > decimals) {
            var i = parts[1].length - 1;
            while (parts[1].length > decimals) {
                if (parts[1][i] == "0") {
                    parts[1] = parts[i].slice(0, -1);
                    i--;
                    continue;
                }
                break;
            }
            ret = parts[0] + "." + parts[1];
        }
        else
            ret = parts[0] + "." + parts[1] + "0".repeat(decimals - parts[1].length);
        return returnNullZero && !ret.match(/[^0\.]/) ? null : ret;
    }
    utils.formatQNT = formatQNT;
    function trimDecimals(formatted, decimals) {
        var parts = formatted.split(".");
        if (!parts[1])
            parts[1] = "0".repeat(decimals);
        else
            parts[1] = parts[1].substr(0, decimals);
        if (parts[1].length < decimals)
            parts[1] += "0".repeat(decimals - parts[1].length);
        return parts[0] + "." + parts[1];
    }
    utils.trimDecimals = trimDecimals;
    function convertToQNTf(quantity, decimals) {
        decimals = decimals || 8;
        if (typeof quantity == 'undefined') {
            return '0';
        }
        if (quantity.length < decimals) {
            for (var i = quantity.length; i < decimals; i++) {
                quantity = "0" + quantity;
            }
        }
        var afterComma = "";
        if (decimals) {
            afterComma = "." + quantity.substring(quantity.length - decimals);
            quantity = quantity.substring(0, quantity.length - decimals);
            if (!quantity) {
                quantity = "0";
            }
            afterComma = afterComma.replace(/0+$/, "");
            if (afterComma == ".") {
                afterComma = "";
            }
        }
        return quantity + afterComma;
    }
    utils.convertToQNTf = convertToQNTf;
    function calculateTotalOrderPriceQNT(quantityQNT, priceQNT) {
        return new Big(quantityQNT).times(new Big(priceQNT).div(new Big(100000000))).round().toString();
    }
    utils.calculateTotalOrderPriceQNT = calculateTotalOrderPriceQNT;
    var ConvertToQNTError = (function () {
        function ConvertToQNTError(message, code) {
            this.message = message;
            this.code = code;
            this.name = "ConvertToQNTError";
        }
        return ConvertToQNTError;
    }());
    utils.ConvertToQNTError = ConvertToQNTError;
    function convertToQNT(quantity) {
        var decimals = 8;
        var parts = quantity.split(".");
        var qnt = parts[0];
        if (parts.length == 1) {
            if (decimals) {
                for (var i = 0; i < decimals; i++) {
                    qnt += "0";
                }
            }
        }
        else if (parts.length == 2) {
            var fraction = parts[1];
            if (fraction.length > decimals) {
                throw new ConvertToQNTError("Fraction can only have " + decimals + " decimals max.", 1);
            }
            else if (fraction.length < decimals) {
                for (var i = fraction.length; i < decimals; i++) {
                    fraction += "0";
                }
            }
            qnt += fraction;
        }
        else {
            throw new ConvertToQNTError("Incorrect input", 2);
        }
        if (!/^\d+$/.test(qnt)) {
            throw new ConvertToQNTError("Invalid input. Only numbers and a dot are accepted.", 3);
        }
        return qnt.replace(/^0+/, "");
    }
    utils.convertToQNT = convertToQNT;
    function getByteLen(value) {
        var byteLen = 0;
        for (var i = 0; i < value.length; i++) {
            var c = value.charCodeAt(i);
            byteLen += c < (1 << 7) ? 1 :
                c < (1 << 11) ? 2 :
                    c < (1 << 16) ? 3 :
                        c < (1 << 21) ? 4 :
                            c < (1 << 26) ? 5 :
                                c < (1 << 31) ? 6 : Number.NaN;
        }
        return byteLen;
    }
    utils.getByteLen = getByteLen;
    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait || 100);
            if (callNow)
                func.apply(context, args);
        };
    }
    utils.debounce = debounce;
    ;
    function repeatWhile(delay, cb) {
        var fn = function () {
            if (cb()) {
                clearInterval(interval);
            }
        };
        var interval = setInterval(fn, delay);
    }
    utils.repeatWhile = repeatWhile;
    function emptyToNull(input) {
        return (angular.isString(input) && input.trim().length == 0) ? null : input;
    }
    utils.emptyToNull = emptyToNull;
})(utils || (utils = {}));
var ARDORCryptoService = (function () {
    function ARDORCryptoService($window, user) {
        this.$window = $window;
        this.user = user;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
    }
    ARDORCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var walletType = { addresses: [] };
            var publicKey = _this.nxtCrypto.getPublicKey(seedOrPrivateKey);
            var address = _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'ARDOR');
            var accountId = _this.nxtCrypto.getAccountId(publicKey);
            walletType.addresses[0] = { address: address, privateKey: seedOrPrivateKey, accountId: accountId };
            resolve(walletType);
        });
    };
    ARDORCryptoService.prototype.refreshAdressBalances = function (wallet) {
        var userAccount = wallet.addresses[0].accountId;
        return new Promise(function (resolve, reject) {
            var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
            ardorBlockExplorerService.getTransactions(userAccount, 0, 10).then(function (transactions) {
                if (transactions.length != 0) {
                    ardorBlockExplorerService.getBalance(userAccount).then(function (balance) {
                        wallet.addresses[0].balance = new Big(utils.convertToQNTf(balance)).toFixed(8);
                        wallet.addresses[0].inUse = true;
                        ardorBlockExplorerService.getAccountAssets(userAccount).then(function (accountAssets) {
                            wallet.addresses[0].tokensBalances = [];
                            var promises = [];
                            accountAssets.forEach(function (asset) {
                                var promise = ardorBlockExplorerService.getAssetInfo(asset.asset).then(function (assetInfo) {
                                    wallet.addresses[0].tokensBalances.push({
                                        symbol: assetInfo ? assetInfo.name : '',
                                        name: assetInfo ? assetInfo.name : '',
                                        decimals: assetInfo.decimals,
                                        balance: utils.formatQNT(asset.unconfirmedQuantityQNT, assetInfo.decimals),
                                        address: asset.asset
                                    });
                                });
                                promises.push(promise);
                            });
                            Promise.all(promises).then(function () { return resolve(true); });
                            if (accountAssets.length === 0)
                                resolve(true);
                        });
                    });
                }
                else {
                    resolve(false);
                }
            });
        });
    };
    ARDORCryptoService = __decorate([
        Service('ardorCryptoService'),
        Inject('$window', 'user'),
        __metadata("design:paramtypes", [Object, UserService])
    ], ARDORCryptoService);
    return ARDORCryptoService;
}());
var AbiDecoderService = (function () {
    function AbiDecoderService(web3, $window) {
        this.web3 = web3;
        this.$window = $window;
        this.state = {
            savedABIs: [],
            methodIDs: {}
        };
        this.Web3 = $window.heatlibs.Web3;
        this.SolidityCoder = $window.heatlibs.__SolidityCoder;
    }
    AbiDecoderService.prototype.getABIs = function () {
        return this.state.savedABIs;
    };
    AbiDecoderService.prototype.addABI = function (abiArray) {
        var _this = this;
        if (Array.isArray(abiArray)) {
            abiArray.map(function (abi) {
                if (abi.name) {
                    var signature = new (_this.Web3)().sha3(abi.name + "(" + abi.inputs.map(function (input) { return input.type; }).join(",") + ")");
                    if (abi.type == "event") {
                        _this.state.methodIDs[signature.slice(2)] = abi;
                    }
                    else {
                        _this.state.methodIDs[signature.slice(2, 10)] = abi;
                    }
                }
            });
            this.state.savedABIs = this.state.savedABIs.concat(abiArray);
        }
        else {
            throw new Error("Expected ABI array, got " + typeof abiArray);
        }
    };
    AbiDecoderService.prototype.removeABI = function (abiArray) {
        var _this = this;
        if (Array.isArray(abiArray)) {
            abiArray.map(function (abi) {
                if (abi.name) {
                    var signature = new (_this.Web3)().sha3(abi.name + "(" + abi.inputs.map(function (input) { return input.type; }).join(",") + ")");
                    if (abi.type == "event") {
                        if (_this.state.methodIDs[signature.slice(2)]) {
                            delete _this.state.methodIDs[signature.slice(2)];
                        }
                    }
                    else {
                        if (_this.state.methodIDs[signature.slice(2, 10)]) {
                            delete _this.state.methodIDs[signature.slice(2, 10)];
                        }
                    }
                }
            });
        }
        else {
            throw new Error("Expected ABI array, got " + typeof abiArray);
        }
    };
    AbiDecoderService.prototype.getMethodIDs = function () {
        return this.state.methodIDs;
    };
    AbiDecoderService.prototype.decodeMethod = function (data) {
        var methodID = data.slice(2, 10);
        var abiItem = this.state.methodIDs[methodID];
        if (abiItem) {
            var params = abiItem.inputs.map(function (item) { return item.type; });
            var decoded = this.SolidityCoder.decodeParams(params, data.slice(10));
            return {
                name: abiItem.name,
                params: decoded.map(function (param, index) {
                    var _this = this;
                    var parsedParam = param;
                    var isUint = abiItem.inputs[index].type.indexOf("uint") == 0;
                    var isInt = abiItem.inputs[index].type.indexOf("int") == 0;
                    if (isUint || isInt) {
                        var isArray = Array.isArray(param);
                        if (isArray) {
                            parsedParam = param.map(function (val) { return new (_this.Web3)().toBigNumber(val).toString(); });
                        }
                        else {
                            parsedParam = new (this.Web3)().toBigNumber(param).toString();
                        }
                    }
                    return {
                        name: abiItem.inputs[index].name,
                        value: parsedParam,
                        type: abiItem.inputs[index].type
                    };
                })
            };
        }
    };
    AbiDecoderService.prototype.padZeros = function (address) {
        var formatted = address;
        if (address.indexOf('0x') != -1) {
            formatted = address.slice(2);
        }
        if (formatted.length < 40) {
            while (formatted.length < 40)
                formatted = "0" + formatted;
        }
        return "0x" + formatted;
    };
    AbiDecoderService = __decorate([
        Service('abiDecoder'),
        Inject('web3', '$window'),
        __metadata("design:paramtypes", [Web3Service, Object])
    ], AbiDecoderService);
    return AbiDecoderService;
}());
var AbstractDataProvider = (function () {
    function AbstractDataProvider() {
        this.providers = [];
        this.isLoading = false;
    }
    AbstractDataProvider.prototype.createProvider = function ($scope) {
        var _this = this;
        var provider = new DataProvider($scope);
        provider.data = this.getInitialData();
        this.providers.push(provider);
        $scope.$on('$destroy', function () { _this.destroyProvider(provider); });
        if (!this.isLoading) {
            provider.update(this.data);
        }
        return provider;
    };
    AbstractDataProvider.prototype.destroyProvider = function (provider) {
        this.providers = this.providers.filter(function (p) { return p != provider; });
    };
    AbstractDataProvider.prototype.refresh = function () {
        var _this = this;
        this.providers.forEach(function (provider) { provider.refreshBegin(); });
        this.isLoading = true;
        this.getData().then(function (data) {
            _this.isLoading = false;
            _this.data = data;
            _this.providers.forEach(function (provider) { provider.update(data); });
        });
    };
    return AbstractDataProvider;
}());
var DataProvider = (function () {
    function DataProvider($scope) {
        this.$scope = $scope;
        this.loading = true;
    }
    DataProvider.prototype.update = function (data) {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.loading = false;
            _this.data = data;
        });
    };
    DataProvider.prototype.refreshBegin = function () {
        this.loading = true;
        this.$scope.$evalAsync(angular.noop);
    };
    return DataProvider;
}());
var ArdorAssetInfoService = (function () {
    function ArdorAssetInfoService(heat, $q, ardorBlockExplorerService) {
        this.heat = heat;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.cache = {};
        this.cache["ardor"] = {
            id: "ardor",
            description: "IGNIS Cryptocurrency based on ARDOR platform",
            descriptionUrl: "",
            decimals: 8,
            symbol: "IGNIS",
            name: "IGNIS",
            certified: true,
            timestamp: 100149557,
            issuer: "ARDOR",
            issuerPublicName: "ARDOR"
        };
    }
    ArdorAssetInfoService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.ardorBlockExplorerService.getAssetInfo(asset).then(function (data) {
                var info = {
                    id: asset,
                    description: null,
                    descriptionUrl: data.descriptionUrl,
                    decimals: data.decimals,
                    symbol: data.name,
                    name: data.name,
                    certified: false,
                    timestamp: data.timestamp,
                    issuer: data.account,
                    issuerPublicName: data.accountPublicName
                };
                _this.cache[asset] = info;
                deferred.resolve(info);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    ArdorAssetInfoService = __decorate([
        Service('ardorAssetInfo'),
        Inject('heat', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [HeatService, Function, ArdorBlockExplorerService])
    ], ArdorAssetInfoService);
    return ArdorAssetInfoService;
}());
var ArdorBlockExplorerService = (function () {
    function ArdorBlockExplorerService($q, http) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.getSocketUrl = function () {
            return _this.url;
        };
        this.getBlockchainStatus = function () {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainStatus").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data) {
                    deferred.resolve(data);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactions = function (account, firstIndex, lastIndex) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainTransactions&account=" + account + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex + "&chain=1").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions) {
                    deferred.resolve(data.transactions);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainTransactions&account=" + account + "&lastIndex=-1&chain=1").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions)
                    deferred.resolve(data.transactions.length);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendArdr = function (txObject) {
            var deferred = _this.$q.defer();
            _this.http.post(_this.url + txObject, {}).then(function (ret) {
                var userService = heat.$inject.get('user');
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                var attachment = JSON.stringify(data.transactionJSON.attachment);
                var signature = heat.crypto.signBytes(data.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = data.unsignedTransactionBytes.substr(0, 192) + signature + data.unsignedTransactionBytes.substr(320);
                _this.http.post(_this.url + "nxt?requestType=broadcastTransaction&transactionBytes=" + payload + "&prunableAttachmentJSON=" + attachment, {}).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data.errorDescription) {
                        deferred.reject(data.errorDescription);
                    }
                    deferred.resolve({ txId: data.transaction });
                });
            }, function (err) {
                deferred.reject(err.errorDescription);
            });
            return deferred.promise;
        };
        this.getTransactionStatus = function (fullHash) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getTransaction&fullHash=" + fullHash + "&chain=1").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (!data.errorDescription)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (tx) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAccountAssets&account=" + tx).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.accountAssets)
                    deferred.resolve(data.accountAssets);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getBalance = function (account, chain) {
            if (chain === void 0) { chain = 1; }
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBalance&account=" + account + "&chain=" + chain).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data.unconfirmedBalanceNQT);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getPublicKeyFromAddress = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAccountPublicKey&account=" + account).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.publicKey)
                    deferred.resolve(data.publicKey);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAssetInfo = function (asset) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAsset&asset=" + asset).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.name)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendTransactionWithSecret = function (endpoint) {
            var deferred = _this.$q.defer();
            _this.http.post(_this.url + "nxt?requestType=" + endpoint, {}).then(function (ret) {
                var data = JSON.parse(JSON.stringify(ret));
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                deferred.resolve({ txId: data.transaction });
            });
            return deferred.promise;
        };
        this.setUrl();
    }
    ArdorBlockExplorerService.prototype.setUrl = function (url) {
        if (url === void 0) { url = 'https://bitnode.heatwallet.com:27876/'; }
        console.log("This is url", url);
        this.url = url;
    };
    ArdorBlockExplorerService.prototype.getTradesCount = function (ardorAsset, account) {
        var deferred = this.$q.defer();
        var url = account ? this.url + "nxt?requestType=getTrades&chain=2&ardorAsset=" + ardorAsset + "&firstIndex=0&lastIndex=-1&account=" + account : this.url + "nxt?requestType=getTrades&chain=2&asset=" + ardorAsset + "&firstIndex=0&lastIndex=-1";
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.trades)
                deferred.resolve(data.trades.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getTrades = function (ardorAsset, firstIndex, lastIndex, account) {
        var deferred = this.$q.defer();
        var url = account ? this.url + "nxt?requestType=getTrades&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex + "&account=" + account : this.url + "nxt?requestType=getTrades&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.trades)
                deferred.resolve(data.trades);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAskOrdersCount = function (ardorAsset) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAskOrders&chain=2&asset=" + ardorAsset + "&firstIndex=0&lastIndex=-1";
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders)
                deferred.resolve(data.askOrders.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAskOrders = function (ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAskOrders&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders)
                deferred.resolve(data.askOrders);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getBidOrdersCount = function (ardorAsset) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getBidOrders&chain=2&asset=" + ardorAsset + "&firstIndex=0&lastIndex=-1";
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders)
                deferred.resolve(data.bidOrders.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getBidOrders = function (ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getBidOrders&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders)
                deferred.resolve(data.bidOrders);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getMyPendingOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var promises = [];
        var deferred = this.$q.defer();
        promises.push(this.getAccountCurrentAskOrders(account, ardorAsset, firstIndex, lastIndex));
        promises.push(this.getAccountCurrentBidOrders(account, ardorAsset, firstIndex, lastIndex));
        var myPendingOrders = [];
        Promise.all(promises).then(function (values) {
            values.forEach(function (value) {
                myPendingOrders = myPendingOrders.concat(value);
            });
            deferred.resolve(myPendingOrders);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getMyPendingOrdersCount = function (account, ardorAsset) {
        var promises = [];
        var deferred = this.$q.defer();
        promises.push(this.getAccountCurrentAskOrdersCount(account, ardorAsset));
        promises.push(this.getAccountCurrentBidOrdersCount(account, ardorAsset));
        var myPendingOrdersCount = 0;
        Promise.all(promises).then(function (values) {
            values.forEach(function (value) {
                myPendingOrdersCount += value;
            });
            deferred.resolve(myPendingOrdersCount);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentBidOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAccountCurrentBidOrders&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex + "&account=" + account;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders)
                deferred.resolve(data.bidOrders);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentBidOrdersCount = function (account, ardorAsset) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAccountCurrentBidOrders&chain=2&asset=" + ardorAsset + "&firstIndex=0&lastIndex=-1&account=" + account;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.bidOrders)
                deferred.resolve(data.bidOrders.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentAskOrders = function (account, ardorAsset, firstIndex, lastIndex) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAccountCurrentAskOrders&chain=2&asset=" + ardorAsset + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex + "&account=" + account;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders)
                deferred.resolve(data.askOrders);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAccountCurrentAskOrdersCount = function (account, ardorAsset) {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAccountCurrentAskOrders&chain=2&asset=" + ardorAsset + "&firstIndex=0&lastIndex=-1&account=" + account;
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.askOrders)
                deferred.resolve(data.askOrders.length);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService.prototype.getAllAssets = function () {
        var deferred = this.$q.defer();
        var url = this.url + "nxt?requestType=getAllAssets&firstIndex=0&lastIndex=-1";
        this.http.get(url).then(function (response) {
            var data = angular.isString(response) ? JSON.parse(response) : response;
            if (data.assets)
                deferred.resolve(data.assets);
            else
                deferred.reject(data.errorDescription);
        });
        return deferred.promise;
    };
    ArdorBlockExplorerService = __decorate([
        Service('ardorBlockExplorerService'),
        Inject('$q', 'http'),
        __metadata("design:paramtypes", [Function, HttpService])
    ], ArdorBlockExplorerService);
    return ArdorBlockExplorerService;
}());
var ArdorPendingTransactionsService = (function () {
    function ArdorPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    ArdorPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('ardrPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]), fullHash = parts[4];
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time, fullHash: fullHash });
            }
        }
    };
    ArdorPendingTransactionsService.prototype.add = function (address, txId, timestamp, fullHash) {
        window.localStorage.setItem("ardrPendingTxn:" + address + ":" + txId + ":" + timestamp + ":" + fullHash, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    ArdorPendingTransactionsService.prototype.remove = function (address, txId, timestamp, fullHash) {
        window.localStorage.removeItem("ardrPendingTxn:" + address + ":" + txId + ":" + timestamp + ":" + fullHash);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    ArdorPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    ArdorPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    ArdorPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    ArdorPendingTransactionsService = __decorate([
        Service('ardorPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], ArdorPendingTransactionsService);
    return ArdorPendingTransactionsService;
}());
var AssetInfoService = (function () {
    function AssetInfoService(heat, $q, assetCertification, http) {
        this.heat = heat;
        this.$q = $q;
        this.assetCertification = assetCertification;
        this.http = http;
        this.certifiedSymbols = {
            "btc": "5592059897546023466",
            "fimk": "8593933499455210945",
            "gnt": "12638687347417181640",
            "xrp": "3861265706988762530",
            "nxt": "12723185826655406325",
            "ardr": "17622812277075597103"
        };
        this.cache = {};
        this.cache["0"] = {
            id: "0",
            description: "HEAT Cryptocurrency",
            descriptionUrl: "",
            decimals: 8,
            symbol: "HEAT",
            name: "HEAT Cryptocurrency",
            certified: true,
            timestamp: 100149557,
            issuer: "8150091319858025343",
            issuerPublicName: "HEAT blockchain Genesis account"
        };
    }
    AssetInfoService.prototype.getDisplaySymbol = function (asset, symbol) {
        var lowerCaseSymbol = symbol.toLowerCase();
        if (angular.isString(this.certifiedSymbols[lowerCaseSymbol])) {
            if (this.certifiedSymbols[lowerCaseSymbol] != asset) {
                return symbol.slice(0, -1) + '-';
            }
        }
        return symbol;
    };
    AssetInfoService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.heat.api.getAssetProperties(asset, "0", 1).then(function (data) {
                var properties = _this.parseProperties(data.properties, {
                    symbol: asset.substring(0, 4),
                    name: asset,
                    certified: false
                });
                var info = {
                    id: asset,
                    description: null,
                    descriptionUrl: data.descriptionUrl,
                    decimals: data.decimals,
                    symbol: _this.getDisplaySymbol(asset, properties.symbol || ''),
                    name: properties.name,
                    certified: false,
                    timestamp: data.timestamp,
                    issuer: data.account,
                    issuerPublicName: data.accountPublicName
                };
                _this.cache[asset] = info;
                _this.assetCertification.getInfo(asset).then(function (certificationData) {
                    if (certificationData.certified) {
                        info.symbol = certificationData.symbol;
                        info.name = certificationData.name;
                        info.certified = certificationData.certified;
                    }
                    deferred.resolve(info);
                }, deferred.reject);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AssetInfoService.prototype.parseProperties = function (properties, fallback) {
        try {
            var json = JSON.parse(properties);
            return {
                symbol: json[0],
                name: json[1],
                certified: false
            };
        }
        catch (e) {
        }
        return fallback;
    };
    AssetInfoService.prototype.stringifyProperties = function (properties) {
        return JSON.stringify([properties.symbol, properties.name]);
    };
    AssetInfoService.prototype.getAssetDescription = function (info) {
        var deferred = this.$q.defer();
        var noDescription = "No description available ...";
        if (angular.isString(info.description) || !info.descriptionUrl) {
            deferred.resolve(info.description || noDescription);
        }
        else {
            this.http.get(info.descriptionUrl).then(function (text) {
                info.description = text;
                deferred.resolve(text);
            }, function () {
                deferred.resolve(noDescription);
            });
        }
        return deferred.promise;
    };
    AssetInfoService = __decorate([
        Service('assetInfo'),
        Inject('heat', '$q', 'assetCertification', 'http'),
        __metadata("design:paramtypes", [HeatService, Function, AssetCertificationService,
            HttpService])
    ], AssetInfoService);
    return AssetInfoService;
}());
var AssetCertificationService = (function () {
    function AssetCertificationService(heat, $q, settings) {
        this.heat = heat;
        this.$q = $q;
        this.settings = settings;
        this.cache = {};
        this.cache["0"] = {
            asset: "0",
            certified: true,
            symbol: "HEAT",
            name: "HEAT Currency",
            certifierAccount: this.settings.get(SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT)
        };
    }
    AssetCertificationService.prototype.getInfo = function (asset) {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.cache[asset])) {
            deferred.resolve(this.cache[asset]);
        }
        else {
            this.heat.api.getAssetCertification(asset, this.settings.get(SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT)).then(function (data) {
                _this.cache[asset] = data;
                deferred.resolve(_this.cache[asset]);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    AssetCertificationService = __decorate([
        Service('assetCertification'),
        Inject('heat', '$q', 'settings'),
        __metadata("design:paramtypes", [HeatService, Function, SettingsService])
    ], AssetCertificationService);
    return AssetCertificationService;
}());
var BtcBlockExplorerService = (function () {
    function BtcBlockExplorerService(http, $q, btcBlockExplorerHeatNodeService, btcBlockExplorer3rdPartyService, $interval) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.btcBlockExplorerHeatNodeService = btcBlockExplorerHeatNodeService;
        this.btcBlockExplorer3rdPartyService = btcBlockExplorer3rdPartyService;
        this.$interval = $interval;
        this.refresh = function () {
            return _this.btcBlockExplorerHeatNodeService.isBlockchainSyncing().then(function () {
                _this.btcProvider = _this.btcBlockExplorerHeatNodeService;
            }, function () {
                _this.btcProvider = _this.btcBlockExplorer3rdPartyService;
            });
        };
        this.getBalance = function (address) {
            return _this.btcProvider.getBalance(address);
        };
        this.getTransactions = function (address, from, to) {
            return _this.btcProvider.getTransactions(address, from, to);
        };
        this.getAddressInfo = function (address) {
            var deferred = _this.$q.defer();
            _this.btcProvider.getAddressInfo(address).then(function (info) {
                var data = Update3rdPartyAPIResponsesUtil.updateBTCGetAddressInfo(info, _this.btcProvider);
                deferred.resolve(data);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getEstimatedFee = function () {
            return _this.btcProvider.getEstimatedFee();
        };
        this.getTxInfo = function (txId) {
            var deferred = _this.$q.defer();
            _this.btcProvider.getTxInfo(txId).then(function (info) {
                var data = Update3rdPartyAPIResponsesUtil.updateBTCGetTxInfo(info, _this.btcProvider);
                deferred.resolve(data);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.broadcast = function (rawTx) {
            return _this.btcProvider.broadcast(rawTx);
        };
        this.getUnspentUtxos = function (from) {
            return _this.btcProvider.getUnspentUtxos(from);
        };
        var interval = $interval(function () { _this.refresh(); }, 60 * 1000, 0, false);
    }
    BtcBlockExplorerService = __decorate([
        Service('btcBlockExplorerService'),
        Inject('http', '$q', 'btcBlockExplorerHeatNodeService', 'btcBlockExplorer3rdPartyService', '$interval'),
        __metadata("design:paramtypes", [HttpService, Function, BtcBlockExplorerHeatNodeService,
            BtcBlockExplorer3rdPartyService, Function])
    ], BtcBlockExplorerService);
    return BtcBlockExplorerService;
}());
var BitcoinMessagesService = (function () {
    function BitcoinMessagesService() {
        this.messages = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    BitcoinMessagesService.prototype.readLocalStorage = function () {
        this.messages = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('btcMessages:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], message = parts[3] + ":" + parts[4];
                this.messages[addr] = this.messages[addr] || [];
                this.messages[addr].push({ txId: txId, message: message });
            }
        }
    };
    BitcoinMessagesService.prototype.add = function (address, txId, message) {
        window.localStorage.setItem("btcMessages:" + address + ":" + txId + ":" + message, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    BitcoinMessagesService.prototype.remove = function (address, txId, message) {
        window.localStorage.removeItem("btcMessages:" + address + ":" + txId + ":" + message);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    BitcoinMessagesService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    BitcoinMessagesService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    BitcoinMessagesService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    BitcoinMessagesService = __decorate([
        Service('bitcoinMessagesService'),
        __metadata("design:paramtypes", [])
    ], BitcoinMessagesService);
    return BitcoinMessagesService;
}());
var BitcoinPendingTransactionsService = (function () {
    function BitcoinPendingTransactionsService($q, http, settings, btcBlockExplorerService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    BitcoinPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('btcPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    BitcoinPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("btcPendingTxn:" + address + ":" + txId + ":" + timestamp, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    BitcoinPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("btcPendingTxn:" + address + ":" + txId + ":" + timestamp);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    BitcoinPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    BitcoinPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    BitcoinPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    BitcoinPendingTransactionsService = __decorate([
        Service('bitcoinPendingTransactions'),
        Inject('$q', 'http', 'settings', 'btcBlockExplorerService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            BtcBlockExplorerService])
    ], BitcoinPendingTransactionsService);
    return BitcoinPendingTransactionsService;
}());
var BitcoreService = (function () {
    function BitcoreService($window) {
        this.bitcore = $window.heatlibs.bitcore;
        this.bip39 = $window.heatlibs.bip39;
    }
    BitcoreService_1 = BitcoreService;
    BitcoreService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.bip39.validateMnemonic(seedOrPrivateKey)) {
                var walletType = _this.getNWalletsFromMnemonics(seedOrPrivateKey, 20);
                if (walletType.addresses.length === 20) {
                    resolve(walletType);
                }
            }
            else if (_this.bitcore.PrivateKey.isValid(seedOrPrivateKey)) {
                try {
                    var privateKey = _this.bitcore.PrivateKey.fromWIF(seedOrPrivateKey);
                    var address = privateKey.toAddress();
                    var walletType = { addresses: [] };
                    walletType.addresses[0] = { address: address.toString(), privateKey: privateKey.toString() };
                    resolve(walletType);
                }
                catch (e) {
                    resolve();
                }
            }
            else {
                reject();
            }
        });
    };
    BitcoreService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getBitcoinWallet(mnemonic, i);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    BitcoreService.prototype.refreshAdressBalances = function (wallet) {
        var addresses = wallet.addresses.map(function (a) { return a.address; });
        function processNext() {
            return new Promise(function (resolve, reject) {
                var address = addresses[0];
                addresses.shift();
                var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
                btcBlockExplorerService.refresh().then(function () {
                    btcBlockExplorerService.getAddressInfo(address).then(function (info) {
                        var walletAddress = wallet.addresses.find(function (x) { return x.address == address; });
                        if (!walletAddress)
                            return;
                        walletAddress.inUse = info.txApperances != 0;
                        if (!walletAddress.inUse) {
                            resolve(false);
                            return;
                        }
                        walletAddress.balance = info.balanceSat / 100000000 + "";
                        resolve(true);
                    }, function () {
                        resolve(false);
                    });
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve);
                    }, 100);
                }
                else {
                    resolve();
                }
            });
        };
        return new Promise(function (resolve) {
            recurseToNext(resolve);
        });
    };
    BitcoreService.prototype.signTransaction = function (txObject, uncheckedSerialize) {
        var _this = this;
        if (uncheckedSerialize === void 0) { uncheckedSerialize = false; }
        var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        return new Promise(function (resolve, reject) {
            btcBlockExplorerService.getUnspentUtxos(txObject.from).then(function (utxos) {
                try {
                    var tx = _this.bitcore.Transaction();
                    tx.from(utxos);
                    tx.to(txObject.to, txObject.amount);
                    tx.change(txObject.from);
                    tx.fee(txObject.fee);
                    tx.sign(txObject.privateKey);
                    var rawTx = void 0;
                    if (uncheckedSerialize)
                        rawTx = tx.uncheckedSerialize();
                    else
                        rawTx = tx.serialize();
                    resolve(rawTx);
                }
                catch (err) {
                    reject(err);
                }
            }, function (err) {
                reject(err);
            });
        });
    };
    BitcoreService.prototype.sendBitcoins = function (txObject) {
        var _this = this;
        var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        return new Promise(function (resolve, reject) {
            _this.signTransaction(txObject).then(function (rawTx) {
                btcBlockExplorerService.broadcast(rawTx).then(function (txId) {
                    resolve({ txId: txId.txId, message: '' });
                }, function (error) {
                    reject(error);
                });
            });
        });
    };
    BitcoreService.prototype.getBitcoinWallet = function (mnemonic, index) {
        if (index === void 0) { index = 0; }
        var seedHex = this.bip39.mnemonicToSeedHex(mnemonic);
        var HDPrivateKey = this.bitcore.HDPrivateKey;
        var hdPrivateKey = HDPrivateKey.fromSeed(seedHex, 'mainnet');
        var derived = hdPrivateKey.derive(BitcoreService_1.BIP44 + index);
        var address = derived.privateKey.toAddress();
        var privateKey = derived.privateKey.toWIF();
        return {
            address: address.toString(),
            privateKey: privateKey.toString()
        };
    };
    var BitcoreService_1;
    BitcoreService.BIP44 = "m/44'/0'/0'/0/";
    BitcoreService = BitcoreService_1 = __decorate([
        Service('bitcoreService'),
        Inject('$window'),
        __metadata("design:paramtypes", [Object])
    ], BitcoreService);
    return BitcoreService;
}());
var BtcBlockExplorer3rdPartyService = (function () {
    function BtcBlockExplorer3rdPartyService(http, $q, $window) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.$window = $window;
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getAddressInfo(address).then(function (response) {
                var parsed = angular.isString(response) ? JSON.parse(response) : response;
                deferred.resolve(parsed.final_balance);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactions = function (address, from, to) {
            var pageNum = 0;
            pageNum = (to / 10) - 1;
            var getTransactionsApi = "https://blockexplorer.com/api/txs/?address=" + address + "&pageNum=" + pageNum;
            var deferred = _this.$q.defer();
            _this.http.get(getTransactionsApi).then(function (response) {
                var parsed = angular.isString(response) ? JSON.parse(response) : response;
                deferred.resolve(parsed.txs);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getAddressInfo = function (address) {
            var getTransactionsApi = BtcBlockExplorer3rdPartyService_1.endPoint + "/addrs/" + address + "?token=" + BtcBlockExplorer3rdPartyService_1.token;
            var deferred = _this.$q.defer();
            _this.http.get(getTransactionsApi).then(function (response) {
                var parsed = angular.isString(response) ? JSON.parse(response) : response;
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getEstimatedFee = function () {
            var getEstimatedFeeApi = "https://bitcoinfees.earn.com/api/v1/fees/list";
            var deferred = _this.$q.defer();
            var fee = 20;
            _this.http.get(getEstimatedFeeApi).then(function (response) {
                var parsed = angular.isString(response) ? JSON.parse(response) : response;
                parsed.fees.forEach(function (feeObject) {
                    if (feeObject.maxDelay == 1) {
                        fee = feeObject.minFee;
                    }
                });
                if (!fee)
                    fee = 20;
                deferred.resolve(fee);
            }, function () {
                deferred.resolve(fee);
            });
            return deferred.promise;
        };
        this.getTxInfo = function (txId) {
            var getTxInfoApi = BtcBlockExplorer3rdPartyService_1.endPoint + "/tx/" + txId + "?token=" + BtcBlockExplorer3rdPartyService_1.token;
            var deferred = _this.$q.defer();
            _this.http.get(getTxInfoApi).then(function (response) {
                var parsed = angular.isString(response) ? JSON.parse(response) : response;
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.broadcast = function (rawTx) {
            return new Promise(function (resolve, reject) {
                _this.http.post("https://insight.bitpay.com/api/tx/send", { rawtx: rawTx }).then(function (response) {
                    var txId = response ? response['txid'] : null;
                    resolve({ txId: txId });
                }, function (error) {
                    reject(error);
                });
            });
        };
        BtcBlockExplorer3rdPartyService_1.endPoint = 'https://api.blockcypher.com/v1/btc/main';
        this.bitcore = $window.heatlibs.bitcore;
    }
    BtcBlockExplorer3rdPartyService_1 = BtcBlockExplorer3rdPartyService;
    BtcBlockExplorer3rdPartyService.prototype.getUnspentUtxos = function (addresses) {
        var _this = this;
        var Address = this.bitcore.Address;
        var Transaction = this.bitcore.Transaction;
        var UnspentOutput = Transaction.UnspentOutput;
        return new Promise(function (resolve, reject) {
            if (!Array.isArray(addresses)) {
                addresses = [addresses];
            }
            addresses = addresses.map(function (address) { return new Address(address); });
            _this.http.post("https://insight.bitpay.com/api/addrs/utxo", {
                addrs: addresses.map(function (address) { return address.toString(); }).join(',')
            }).then(function (response) {
                try {
                    resolve(response.map(function (unspent) { return new UnspentOutput(unspent); }));
                }
                catch (ex) {
                    reject(ex);
                }
            }, function (error) {
                reject(error);
            });
        });
    };
    var BtcBlockExplorer3rdPartyService_1;
    BtcBlockExplorer3rdPartyService.token = 'd7995959366d4369976aabb3355c7216';
    BtcBlockExplorer3rdPartyService = BtcBlockExplorer3rdPartyService_1 = __decorate([
        Service('btcBlockExplorer3rdPartyService'),
        Inject('http', '$q', '$window'),
        __metadata("design:paramtypes", [HttpService, Function, Object])
    ], BtcBlockExplorer3rdPartyService);
    return BtcBlockExplorer3rdPartyService;
}());
var BtcBlockExplorerHeatNodeService = (function () {
    function BtcBlockExplorerHeatNodeService(http, $q, $window) {
        var _this = this;
        this.http = http;
        this.$q = $q;
        this.$window = $window;
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.getAddressInfo(address).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                deferred.resolve(parsed.balanceSat + parsed.unconfirmedBalanceSat);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactions = function (address, from, to) {
            var getTransactionsApi = BtcBlockExplorerHeatNodeService_1.endPoint + "/addrs/" + address + "/txs?from=" + from + "&to=" + to;
            var deferred = _this.$q.defer();
            _this.http.get(getTransactionsApi).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                deferred.resolve(parsed.items);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getAddressInfo = function (address) {
            var getTransactionsApi = BtcBlockExplorerHeatNodeService_1.endPoint + "/addr/" + address;
            var deferred = _this.$q.defer();
            _this.http.get(getTransactionsApi).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getEstimatedFee = function () {
            var getEstimatedFeeApi = "https://bitcoinfees.earn.com/api/v1/fees/list";
            var deferred = _this.$q.defer();
            var fee = 20;
            _this.http.get(getEstimatedFeeApi).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                parsed.fees.forEach(function (feeObject) {
                    if (feeObject.maxDelay == 1) {
                        fee = feeObject.minFee;
                    }
                });
                if (!fee)
                    fee = 20;
                deferred.resolve(fee);
            }, function () {
                deferred.resolve(fee);
            });
            return deferred.promise;
        };
        this.getTxInfo = function (txId) {
            var getTxInfoApi = BtcBlockExplorerHeatNodeService_1.endPoint + "/tx/" + txId;
            var deferred = _this.$q.defer();
            _this.http.get(getTxInfoApi).then(function (response) {
                var parsed = utils.parseResponse(response);
                if (parsed.heatUtilParsingError)
                    deferred.reject();
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.getLatestBlockHash = function () {
            var getLatestBlockHash = BtcBlockExplorerHeatNodeService_1.endPoint + "/status?q=getLastBlockHash";
            var deferred = _this.$q.defer();
            _this.http.get(getLatestBlockHash).then(function (response) {
                var parsed = utils.parseResponse(response);
                deferred.resolve(parsed.lastblockhash);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.isBlockchainSyncing = function () {
            var deferred = _this.$q.defer();
            _this.getLatestBlockHash().then(function (blockHash) {
                _this.getBlockByHash(blockHash).then(function (response) {
                    var parsed = utils.parseResponse(response);
                    if (utils.isTimeWithinThreasholdLimit(parsed.time))
                        deferred.resolve();
                    else
                        deferred.reject();
                });
            });
            return deferred.promise;
        };
        this.getBlockByHash = function (blockHash) {
            var getBlockByHash = BtcBlockExplorerHeatNodeService_1.endPoint + "/block/" + blockHash;
            var deferred = _this.$q.defer();
            _this.http.get(getBlockByHash).then(function (response) {
                var parsed = utils.parseResponse(response);
                deferred.resolve(parsed);
            }, function () {
                deferred.reject();
            });
            return deferred.promise;
        };
        this.broadcast = function (rawTx) {
            return new Promise(function (resolve, reject) {
                _this.http.post(BtcBlockExplorerHeatNodeService_1.endPoint + "/tx/send", { rawtx: rawTx }).then(function (response) {
                    var txId = response ? response['txid'] : null;
                    resolve({ txId: txId });
                }, function (error) {
                    reject(error);
                });
            });
        };
        BtcBlockExplorerHeatNodeService_1.endPoint = 'https://bitnode.heatwallet.com/insight-api';
        this.bitcore = $window.heatlibs.bitcore;
    }
    BtcBlockExplorerHeatNodeService_1 = BtcBlockExplorerHeatNodeService;
    BtcBlockExplorerHeatNodeService.prototype.getUnspentUtxos = function (addresses) {
        var _this = this;
        var Address = this.bitcore.Address;
        var Transaction = this.bitcore.Transaction;
        var UnspentOutput = Transaction.UnspentOutput;
        return new Promise(function (resolve, reject) {
            if (!Array.isArray(addresses)) {
                addresses = [addresses];
            }
            addresses = addresses.map(function (address) { return new Address(address); });
            _this.http.post(BtcBlockExplorerHeatNodeService_1.endPoint + "/addrs/utxo", {
                addrs: addresses.map(function (address) { return address.toString(); }).join(',')
            }).then(function (response) {
                try {
                    resolve(response.map(function (unspent) { return new UnspentOutput(unspent); }));
                }
                catch (ex) {
                    reject(ex);
                }
            }, function (error) {
                reject(error);
            });
        });
    };
    var BtcBlockExplorerHeatNodeService_1;
    BtcBlockExplorerHeatNodeService = BtcBlockExplorerHeatNodeService_1 = __decorate([
        Service('btcBlockExplorerHeatNodeService'),
        Inject('http', '$q', '$window'),
        __metadata("design:paramtypes", [HttpService, Function, Object])
    ], BtcBlockExplorerHeatNodeService);
    return BtcBlockExplorerHeatNodeService;
}());
var ClipboardService = (function () {
    function ClipboardService($q, $mdToast) {
        this.$q = $q;
        this.$mdToast = $mdToast;
    }
    ClipboardService.prototype.copy = function (element) {
        var deferred = this.$q.defer();
        window.getSelection().removeAllRanges();
        var range = document.createRange();
        range.selectNode(element);
        window.getSelection().addRange(range);
        try {
            if (document.execCommand('copy')) {
                window.getSelection().removeAllRanges();
                deferred.resolve();
            }
            else {
                deferred.reject();
            }
        }
        catch (e) {
            deferred.reject();
        }
        return deferred.promise;
    };
    ClipboardService.prototype.copyText = function (text) {
        var tempInput = document.createElement("input");
        tempInput.style = "position: absolute; left: -1000px; top: -1000px";
        tempInput.value = text;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand("copy");
        document.body.removeChild(tempInput);
    };
    ClipboardService.prototype.copyWithUI = function (element, successMessage) {
        var _this = this;
        return this.copy(element).then(function () {
            _this.$mdToast.show(_this.$mdToast.simple()
                .textContent(successMessage)
                .hideDelay(5000));
        }, function () {
            _this.$mdToast.show(_this.$mdToast.simple()
                .textContent("Press CTRL+C to copy")
                .hideDelay(10000));
        });
    };
    ClipboardService = __decorate([
        Service('clipboard'),
        Inject('$q', '$mdToast'),
        __metadata("design:paramtypes", [Function, Object])
    ], ClipboardService);
    return ClipboardService;
}());
var OpenDevToolsMode;
(function (OpenDevToolsMode) {
    OpenDevToolsMode[OpenDevToolsMode["right"] = 0] = "right";
    OpenDevToolsMode[OpenDevToolsMode["bottom"] = 1] = "bottom";
    OpenDevToolsMode[OpenDevToolsMode["undocked"] = 2] = "undocked";
    OpenDevToolsMode[OpenDevToolsMode["detach"] = 3] = "detach";
})(OpenDevToolsMode || (OpenDevToolsMode = {}));
var ElectronService = (function () {
    function ElectronService(env) {
        this.enabled = false;
        this.enabled = env.type == EnvType.NODEJS;
    }
    ElectronService.prototype.getMainWindowWebContents = function () {
        try {
            return require('electron').remote.webContents.getAllWebContents()[0];
        }
        catch (e) {
            if (this.enabled)
                throw e;
            console.log("Do not access the `electron` service in browser env", e);
        }
    };
    ElectronService.prototype.openDevTools = function (option) {
        this.enabled && this.getMainWindowWebContents().openDevTools({ mode: option });
    };
    ElectronService.prototype.toggleDevTools = function () {
        this.enabled && this.getMainWindowWebContents().toggleDevTools();
    };
    ElectronService.prototype.isDevToolsOpened = function () {
        return this.enabled && this.getMainWindowWebContents().isDevToolsOpened();
    };
    ElectronService.prototype.reload = function () {
        this.enabled && this.getMainWindowWebContents().reload();
    };
    ElectronService = __decorate([
        Service('electron'),
        Inject('env'),
        __metadata("design:paramtypes", [EnvService])
    ], ElectronService);
    return ElectronService;
}());
var EnvType;
(function (EnvType) {
    EnvType[EnvType["NODEJS"] = 0] = "NODEJS";
    EnvType[EnvType["BROWSER"] = 1] = "BROWSER";
})(EnvType || (EnvType = {}));
var EnvService = (function () {
    function EnvService() {
        try {
            if (typeof window['require'] == 'function' && window['require']('child_process')) {
                this.type = EnvType.NODEJS;
            }
            else {
                this.type = EnvType.BROWSER;
            }
        }
        catch (e) {
            this.type = EnvType.BROWSER;
        }
    }
    EnvService = __decorate([
        Service('env'),
        __metadata("design:paramtypes", [])
    ], EnvService);
    return EnvService;
}());
var EthTransactionParserService = (function () {
    function EthTransactionParserService($q, abiDecoder, http, settings, ethplorer) {
        this.$q = $q;
        this.abiDecoder = abiDecoder;
        this.http = http;
        this.settings = settings;
        this.ethplorer = ethplorer;
        this.erc20Abi = [{ "constant": true, "inputs": [], "name": "name", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "approve", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_from", "type": "address" }, { "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "version", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "balance", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_to", "type": "address" }, { "name": "_value", "type": "uint256" }], "name": "transfer", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "_spender", "type": "address" }, { "name": "_value", "type": "uint256" }, { "name": "_extraData", "type": "bytes" }], "name": "approveAndCall", "outputs": [{ "name": "success", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "_owner", "type": "address" }, { "name": "_spender", "type": "address" }], "name": "allowance", "outputs": [{ "name": "remaining", "type": "uint256" }], "payable": false, "type": "function" }, { "inputs": [{ "name": "_initialAmount", "type": "uint256" }, { "name": "_tokenName", "type": "string" }, { "name": "_decimalUnits", "type": "uint8" }, { "name": "_tokenSymbol", "type": "string" }], "type": "constructor" }, { "payable": false, "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_from", "type": "address" }, { "indexed": true, "name": "_to", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "_owner", "type": "address" }, { "indexed": true, "name": "_spender", "type": "address" }, { "indexed": false, "name": "_value", "type": "uint256" }], "name": "Approval", "type": "event" }];
        this.etherDeltaAbi = [{ "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }, { "name": "amount", "type": "uint256" }], "name": "trade", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }], "name": "order", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "bytes32" }], "name": "orderFills", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "cancelOrder", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "amount", "type": "uint256" }], "name": "withdraw", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "token", "type": "address" }, { "name": "amount", "type": "uint256" }], "name": "depositToken", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "amountFilled", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "address" }], "name": "tokens", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeMake_", "type": "uint256" }], "name": "changeFeeMake", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeMake", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeRebate_", "type": "uint256" }], "name": "changeFeeRebate", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeAccount", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }, { "name": "amount", "type": "uint256" }, { "name": "sender", "type": "address" }], "name": "testTrade", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeAccount_", "type": "address" }], "name": "changeFeeAccount", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeRebate", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "feeTake_", "type": "uint256" }], "name": "changeFeeTake", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "admin_", "type": "address" }], "name": "changeAdmin", "outputs": [], "payable": false, "type": "function" }, { "constant": false, "inputs": [{ "name": "token", "type": "address" }, { "name": "amount", "type": "uint256" }], "name": "withdrawToken", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "bytes32" }], "name": "orders", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "feeTake", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": false, "inputs": [], "name": "deposit", "outputs": [], "payable": true, "type": "function" }, { "constant": false, "inputs": [{ "name": "accountLevelsAddr_", "type": "address" }], "name": "changeAccountLevelsAddr", "outputs": [], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "accountLevelsAddr", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "token", "type": "address" }, { "name": "user", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [], "name": "admin", "outputs": [{ "name": "", "type": "address" }], "payable": false, "type": "function" }, { "constant": true, "inputs": [{ "name": "tokenGet", "type": "address" }, { "name": "amountGet", "type": "uint256" }, { "name": "tokenGive", "type": "address" }, { "name": "amountGive", "type": "uint256" }, { "name": "expires", "type": "uint256" }, { "name": "nonce", "type": "uint256" }, { "name": "user", "type": "address" }, { "name": "v", "type": "uint8" }, { "name": "r", "type": "bytes32" }, { "name": "s", "type": "bytes32" }], "name": "availableVolume", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "type": "function" }, { "inputs": [{ "name": "admin_", "type": "address" }, { "name": "feeAccount_", "type": "address" }, { "name": "accountLevelsAddr_", "type": "address" }, { "name": "feeMake_", "type": "uint256" }, { "name": "feeTake_", "type": "uint256" }, { "name": "feeRebate_", "type": "uint256" }], "payable": false, "type": "constructor" }, { "payable": false, "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "expires", "type": "uint256" }, { "indexed": false, "name": "nonce", "type": "uint256" }, { "indexed": false, "name": "user", "type": "address" }], "name": "Order", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "expires", "type": "uint256" }, { "indexed": false, "name": "nonce", "type": "uint256" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "v", "type": "uint8" }, { "indexed": false, "name": "r", "type": "bytes32" }, { "indexed": false, "name": "s", "type": "bytes32" }], "name": "Cancel", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "tokenGet", "type": "address" }, { "indexed": false, "name": "amountGet", "type": "uint256" }, { "indexed": false, "name": "tokenGive", "type": "address" }, { "indexed": false, "name": "amountGive", "type": "uint256" }, { "indexed": false, "name": "get", "type": "address" }, { "indexed": false, "name": "give", "type": "address" }], "name": "Trade", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "token", "type": "address" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "amount", "type": "uint256" }, { "indexed": false, "name": "balance", "type": "uint256" }], "name": "Deposit", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "name": "token", "type": "address" }, { "indexed": false, "name": "user", "type": "address" }, { "indexed": false, "name": "amount", "type": "uint256" }, { "indexed": false, "name": "balance", "type": "uint256" }], "name": "Withdraw", "type": "event" }];
        this.abiDecoder.addABI(this.erc20Abi);
        this.abiDecoder.addABI(this.etherDeltaAbi);
    }
    EthTransactionParserService.prototype.parse = function (transactions) {
        var _this = this;
        var result = [];
        transactions.forEach(function (transaction) {
            if (!transaction)
                return;
            var extended = transaction;
            result.push(extended);
            var tokenInfo = _this.ethplorer.tokenInfoCache[transaction.to];
            if (tokenInfo) {
                extended.abi = {
                    symbol: tokenInfo.symbol,
                    name: tokenInfo.name,
                    decimals: tokenInfo.decimals,
                    address: tokenInfo.address,
                    decodedData: null
                };
                try {
                    extended.abi.decodedData = _this.abiDecoder.decodeMethod(transaction.input);
                }
                catch (e) {
                    console.log(e);
                }
            }
        });
        return result;
    };
    EthTransactionParserService = __decorate([
        Service('ethTransactionParser'),
        Inject('$q', 'abiDecoder', 'http', 'settings', 'ethplorer'),
        __metadata("design:paramtypes", [Function, AbiDecoderService,
            HttpService,
            SettingsService,
            EthplorerService])
    ], EthTransactionParserService);
    return EthTransactionParserService;
}());
var EthereumPendingTransactionsService = (function () {
    function EthereumPendingTransactionsService($q, http, settings, web3, ethplorer) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.web3 = web3;
        this.ethplorer = ethplorer;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    EthereumPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('ethPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txHash = parts[2], timestamp = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txHash: txHash, timestamp: timestamp });
            }
        }
    };
    EthereumPendingTransactionsService.prototype.add = function (address, txHash, timestamp) {
        window.localStorage.setItem("ethPendingTxn:" + address + ":" + txHash + ":" + timestamp, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    EthereumPendingTransactionsService.prototype.remove = function (address, txHash, timestamp) {
        window.localStorage.removeItem("ethPendingTxn:" + address + ":" + txHash + ":" + timestamp);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    EthereumPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    EthereumPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    EthereumPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    EthereumPendingTransactionsService = __decorate([
        Service('ethereumPendingTransactions'),
        Inject('$q', 'http', 'settings', 'web3', 'ethplorer'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            Web3Service,
            EthplorerService])
    ], EthereumPendingTransactionsService);
    return EthereumPendingTransactionsService;
}());
var EthplorerTransactionPaginator = (function () {
    function EthplorerTransactionPaginator(address, ethplorer) {
        this.address = address;
        this.ethplorer = ethplorer;
        this.pool = [];
        this.endReached = false;
        this.$q = this.ethplorer.$q;
    }
    EthplorerTransactionPaginator.prototype.getNextBatch = function () {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.endReached) {
            deferred.resolve(false);
        }
        else {
            var timestamp = this.pool.length ? this.pool[this.pool.length - 1].timestamp : 0;
            this.ethplorer.getAddressTransactions(this.address, timestamp).then(function (transactions) {
                transactions.forEach(function (txn) {
                    if (!_this.pool.find(function (tx) { return tx.hash == txn.hash; })) {
                        _this.pool.push(txn);
                    }
                });
                _this.endReached = transactions.length != 50;
                deferred.resolve(!_this.endReached);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.ensurePoolLength = function (minLength) {
        var _this = this;
        var deferred = this.$q.defer();
        if (this.pool.length > minLength) {
            deferred.resolve(this.pool.length);
        }
        else {
            this.getNextBatch().then(function (hasMore) {
                if (_this.pool.length - 1 > minLength || !hasMore) {
                    deferred.resolve(_this.pool.length);
                }
                else {
                    _this.getNextBatch().then(function (hasMore) {
                        if (_this.pool.length - 1 > minLength || !hasMore) {
                            deferred.resolve(_this.pool.length);
                        }
                        else {
                            _this.getNextBatch().then(function (hasMore) {
                                deferred.resolve(_this.pool.length);
                            }, deferred.reject);
                        }
                    }, deferred.reject);
                }
            }, deferred.reject);
        }
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.getCount = function () {
        var deferred = this.$q.defer();
        this.ethplorer.getEthplorerTransactionCount(this.address).then(function (count) {
            deferred.resolve(Math.min(count, 1000));
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerTransactionPaginator.prototype.getItems = function (from, to) {
        var _this = this;
        var deferred = this.$q.defer();
        this.ensurePoolLength(to - 1).then(function (poolLength) {
            var result = [];
            for (var i = from; i < to; i++) {
                result.push(_this.pool[i]);
            }
            deferred.resolve(result);
        }, deferred.reject);
        return deferred.promise;
    };
    return EthplorerTransactionPaginator;
}());
var EthplorerService = (function () {
    function EthplorerService($q, http, settingsService, web3) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.settingsService = settingsService;
        this.web3 = web3;
        this.tokenInfoCache = {};
        this.cachedGetCachedAddressInfo = null;
        http.get('https://raw.githubusercontent.com/dmdeklerk/ethereum-lists/master/dist/tokens/eth/tokens-eth.min.json').then(function (response) {
            var array = angular.isString(response) ? JSON.parse(response) : response;
            array.forEach(function (x) {
                _this.tokenInfoCache[x.address] = {
                    address: x.address,
                    totalSupply: 0,
                    name: x.name,
                    symbol: x.symbol,
                    decimals: x.decimals
                };
            });
        });
    }
    EthplorerService.prototype.createPaginator = function (address) {
        return new EthplorerTransactionPaginator(address, this);
    };
    EthplorerService.prototype.getErc20Tokens = function (address) {
        var deferred = this.$q.defer();
        this.getCachedAddressInfo(address).then(function (response) {
            deferred.resolve(response);
        }, function (err) {
            console.log(err);
            deferred.resolve([]);
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getEthplorerTransactionCount = function (address) {
        var deferred = this.$q.defer();
        this.getCachedAddressInfo(address).then(function (info) {
            deferred.resolve(info.countTxs);
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerService.prototype.getBalance = function (address) {
        var deferred = this.$q.defer();
        this.getCachedAddressInfo(address).then(function (info) {
            deferred.resolve(info.ETH.balance);
        }, deferred.reject);
        return deferred.promise;
    };
    EthplorerService.prototype.getCachedAddressInfo = function (address) {
        var _this = this;
        if (this.cachedGetCachedAddressInfo)
            return this.cachedGetCachedAddressInfo;
        var deferred = this.$q.defer();
        this.cachedGetCachedAddressInfo = deferred.promise;
        this.getAddressInfo(address).then(deferred.resolve, deferred.reject);
        this.cachedGetCachedAddressInfo.finally(function () {
            setTimeout(function () {
                _this.cachedGetCachedAddressInfo = null;
            }, 5 * 1000);
        });
        return this.cachedGetCachedAddressInfo;
    };
    EthplorerService.prototype.getAddressInfo = function (address) {
        var _this = this;
        var deferred = this.$q.defer();
        var url = "https://api.ethplorer.io/getAddressInfo/" + address + "?apiKey=lwA5173TDKj60";
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: " + JSON.stringify(parsed));
                deferred.reject(parsed.error);
            }
            else {
                var info = parsed;
                if (info.tokens) {
                    info.tokens.forEach(function (token) {
                        if (token.tokenInfo) {
                            _this.tokenInfoCache[token.tokenInfo.address] = token.tokenInfo;
                        }
                    });
                }
                deferred.resolve(info);
            }
        }, function () {
            console.log("HTTP reject for " + url);
            deferred.reject(null);
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getAddressTransactions = function (address, timestamp, showZeroValues) {
        var deferred = this.$q.defer();
        showZeroValues = showZeroValues || 1;
        var url = "https://api.ethplorer.io/getAddressTransactions/" + address + "?apiKey=lwA5173TDKj60&limit=50&timestamp=" + timestamp + "&showZeroValues=" + showZeroValues;
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: " + JSON.stringify(parsed));
                deferred.resolve([]);
            }
            else {
                deferred.resolve(parsed);
            }
        }, function () {
            console.log("HTTP reject for " + url);
            deferred.resolve([]);
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getAddressHistory = function (address, timestamp) {
        var deferred = this.$q.defer();
        var url = "https://api.ethplorer.io/getAddressHistory/" + address + "?apiKey=lwA5173TDKj60&limit=10&timestamp=" + timestamp;
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: " + JSON.stringify(parsed));
                deferred.resolve([]);
            }
            else {
                deferred.resolve(parsed.operations);
            }
        }, function () {
            console.log("HTTP reject for " + url);
            deferred.resolve([]);
        });
        return deferred.promise;
    };
    EthplorerService.prototype.getTxInfo = function (txHash) {
        var deferred = this.$q.defer();
        var url = "https://api.ethplorer.io/getTxInfo/" + txHash + "?apiKey=lwA5173TDKj60";
        this.http.get(url)
            .then(function (response) {
            var parsed = angular.isString(response) ? JSON.parse(response) : response;
            if (parsed.error) {
                console.log("Ethplorer Error: " + JSON.stringify(parsed));
                deferred.reject(parsed.error);
            }
            else {
                deferred.resolve(parsed);
            }
        }, function (error) {
            console.log("HTTP reject for " + url);
            deferred.reject(error);
        });
        return deferred.promise;
    };
    EthplorerService = __decorate([
        Service('ethplorer'),
        Inject('$q', 'http', 'settings', 'web3'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            Web3Service])
    ], EthplorerService);
    return EthplorerService;
}());
var FIMKCryptoService = (function () {
    function FIMKCryptoService($window, mofoSocketService, $rootScope) {
        this.$window = $window;
        this.mofoSocketService = mofoSocketService;
        this.$rootScope = $rootScope;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
    }
    FIMKCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var walletType = { addresses: [] };
            walletType.addresses[0] = { address: _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'FIM'), privateKey: seedOrPrivateKey };
            resolve(walletType);
        });
    };
    FIMKCryptoService.prototype.refreshAdressBalances = function (wallet) {
        var address = wallet.addresses[0].address;
        return new Promise(function (resolve, reject) {
            var mofoSocketService = heat.$inject.get('mofoSocketService');
            mofoSocketService.getTransactions(address).then(function (transactions) {
                mofoSocketService.getAccount(address).then(function (info) {
                    wallet.addresses[0].inUse = true;
                    var balance = parseInt(info.unconfirmedBalanceNQT) / 100000000;
                    var formattedBalance = new Big(balance + "");
                    var balanceUnconfirmed = new Big(formattedBalance).toFixed(8);
                    wallet.addresses[0].balance = balanceUnconfirmed;
                    mofoSocketService.getAccountAssets(address).then(function (accountAssets) {
                        wallet.addresses[0].tokensBalances = [];
                        accountAssets.forEach(function (asset) {
                            wallet.addresses[0].tokensBalances.push({
                                symbol: asset ? asset.name : '',
                                name: asset ? asset.name : '',
                                decimals: asset.decimals,
                                balance: utils.formatQNT(asset.unconfirmedQuantityQNT, asset.decimals),
                                address: asset.asset
                            });
                        });
                        resolve(true);
                    });
                });
            }, function (err) {
                resolve(false);
            });
        });
    };
    FIMKCryptoService = __decorate([
        Service('fimkCryptoService'),
        Inject('$window', 'mofoSocketService', '$rootScope'),
        __metadata("design:paramtypes", [Object, MofoSocketService, Object])
    ], FIMKCryptoService);
    return FIMKCryptoService;
}());
var FimkPendingTransactionsService = (function () {
    function FimkPendingTransactionsService($q, http, settings, mofoSocketService) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.mofoSocketService = mofoSocketService;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    FimkPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('fimkPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    FimkPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("fimkPendingTxn:" + address + ":" + txId + ":" + timestamp, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    FimkPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("fimkPendingTxn:" + address + ":" + txId + ":" + timestamp);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    FimkPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    FimkPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    FimkPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    FimkPendingTransactionsService = __decorate([
        Service('fimkPendingTransactions'),
        Inject('$q', 'http', 'settings', 'mofoSocketService'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService,
            MofoSocketService])
    ], FimkPendingTransactionsService);
    return FimkPendingTransactionsService;
}());
var HttpService = (function () {
    function HttpService($http, env, $q) {
        this.$http = $http;
        this.env = env;
        this.$q = $q;
        this.throttled = ['https://blockexplorer.com', 'https://api.ethplorer.io', 'https://insight.bitpay.com'];
        this.queues = [];
        for (var i = 0; i < this.throttled.length; i++)
            this.queues.push([]);
    }
    HttpService.prototype.waitTurn = function (url, promise) {
        var index = -1;
        for (var i = 0; i < this.throttled.length; i++) {
            if (url.startsWith(this.throttled[i])) {
                index = i;
                break;
            }
        }
        if (index == -1) {
            var deferred_2 = this.$q.defer();
            deferred_2.resolve();
            return deferred_2.promise;
        }
        var queue = this.queues[index];
        var nextRequest = queue[queue.length - 1];
        var request = {
            url: url,
            promise: promise
        };
        queue.push(request);
        request.promise.finally(function () {
            var i = queue.indexOf(request);
            if (i != -1)
                queue.splice(i, 1);
        });
        var deferred = this.$q.defer();
        if (nextRequest) {
            nextRequest.promise.finally(deferred.resolve);
        }
        else {
            deferred.resolve();
        }
        return deferred.promise;
    };
    HttpService.prototype.get = function (url) {
        var _this = this;
        var deferred = this.$q.defer();
        var promise = deferred.promise;
        this.waitTurn(url, promise).then(function () {
            if (_this.env.type == EnvType.BROWSER) {
                _this.browserHttpGet(url, deferred.resolve, deferred.reject);
            }
            else {
                _this.nodeHttpGet(url, deferred.resolve, deferred.reject);
            }
        });
        return promise;
    };
    HttpService.prototype.browserHttpGet = function (url, onSuccess, onFailure) {
        this.$http.get(url, {
            headers: {
                'Content-Type': 'application/text'
            }
        }).then(function (response) { onSuccess(response.data); }, function (response) { onFailure(response.data); });
    };
    HttpService.prototype.nodeHttpGet = function (url, onSuccess, onFailure) {
        var _url = require('url').parse(url);
        var options = {
            hostname: _url.hostname, port: _url.port, path: _url.path, method: 'GET',
            headers: {
                'Content-Type': 'application/text'
            }
        };
        var http = require(_url.protocol.indexOf('https') == 0 ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) {
                body.push(chunk);
            });
            res.on('end', function () {
                onSuccess(body.join(''));
            });
        });
        req.on('error', function (e) {
            onFailure(e);
        });
        req.end();
    };
    HttpService.prototype.post = function (url, data) {
        var deferred = this.$q.defer();
        if (this.env.type == EnvType.BROWSER) {
            this.browserHttpPost(url, data, deferred.resolve, deferred.reject);
        }
        else {
            var a = document.createElement('a');
            a.href = url;
            var hostname = a.hostname;
            var isHttps = a.protocol == 'https:';
            var port = a.port ? parseInt(a.port) : (isHttps ? 443 : 80);
            var path = a.pathname;
            this.nodeHttpPost(isHttps, hostname, port, path, data, deferred.resolve, deferred.reject);
        }
        return deferred.promise;
    };
    HttpService.prototype.browserHttpPost = function (url, data, onSuccess, onFailure) {
        this.$http({
            method: 'POST',
            url: url,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            transformRequest: function (obj) {
                var str = [];
                for (var p in obj)
                    str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                return str.join("&");
            },
            data: data
        }).then(function (response) { onSuccess(response.data); }, function (response) { onFailure(response.data); });
    };
    HttpService.prototype.nodeHttpPost = function (isHttps, hostname, port, path, request, onSuccess, onFailure) {
        var querystring = require('querystring');
        var body = querystring.stringify(request);
        var options = {
            hostname: hostname, port: port, path: path, method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                "Content-Length": body.length
            }
        };
        var http = require(isHttps ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) { body.push(chunk); });
            res.on('end', function () {
                onSuccess(JSON.parse(body.join('')));
            });
        });
        req.on('error', function (e) { onFailure(e); });
        req.write(body);
        req.end();
    };
    HttpService = __decorate([
        Service('http'),
        Inject('$http', 'env', '$q'),
        __metadata("design:paramtypes", [Function, EnvService, Function])
    ], HttpService);
    return HttpService;
}());
var IotaBlockExplorerService = (function () {
    function IotaBlockExplorerService($q, http, $window) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.$window = $window;
        this.cachedGetCachedAccountInfo = new Map();
        this.getTransactions = function (seed, startKeyIndex, security) {
            if (startKeyIndex === void 0) { startKeyIndex = 0; }
            if (security === void 0) { security = 2; }
            var deferred = _this.$q.defer();
            _this.api.getAccountData(seed, { startKeyIndex: startKeyIndex, security: security }).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transfers) {
                    deferred.resolve(data);
                }
                else
                    deferred.reject("Unable to fetch IOTA address data");
            });
            return deferred.promise;
        };
        this.getCachedAccountInfo = function (seed, startKeyIndex, security) {
            if (startKeyIndex === void 0) { startKeyIndex = 0; }
            if (security === void 0) { security = 2; }
            if (_this.cachedGetCachedAccountInfo.get(seed))
                return _this.cachedGetCachedAccountInfo.get(seed);
            var deferred = _this.$q.defer();
            _this.cachedGetCachedAccountInfo.set(seed, deferred.promise);
            _this.getTransactions(seed).then(deferred.resolve, deferred.reject);
            _this.cachedGetCachedAccountInfo.get(seed).finally(function () {
                setTimeout(function () {
                    _this.cachedGetCachedAccountInfo.set(seed, null);
                }, 30 * 1000);
            });
            return _this.cachedGetCachedAccountInfo.get(seed);
        };
        this.getAccountInfo = function (seed, startKeyIndex, security) {
            if (startKeyIndex === void 0) { startKeyIndex = 0; }
            if (security === void 0) { security = 2; }
            var deferred = _this.$q.defer();
            _this.getCachedAccountInfo(seed, startKeyIndex, security).then(function (info) {
                deferred.resolve(info);
            }, deferred.reject);
            return deferred.promise;
        };
        this.sendIota = function (seed, transfers) {
            var deferred = _this.$q.defer();
            var depth = 3;
            var minWeightMagnitude = 9;
            _this.api.prepareTransfers(seed, transfers)
                .then(function (trytes) { return _this.api.sendTrytes(trytes, depth, minWeightMagnitude); })
                .then(function (bundle) { return deferred.resolve(bundle); })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.getBalance = function (address) {
            var deferred = _this.$q.defer();
            _this.api.getBalances([address], 100)
                .then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                deferred.resolve(data.balances[0]);
            })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.getAddressBundles = function (address) {
            var deferred = _this.$q.defer();
            _this.api.getBundlesFromAddresses([address])
                .then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                deferred.resolve(data);
            })
                .catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.checkAddressReuse = function (address) {
            var deferred = _this.$q.defer();
            _this.getAddressBundles(address).then(function (bundles) {
                bundles.forEach(function (transactions) {
                    transactions.forEach(function (tx) {
                        if (tx.address === address && tx.value < 0) {
                            deferred.resolve(true);
                            return true;
                        }
                    });
                });
                deferred.resolve(false);
            }).catch(function (err) {
                deferred.reject(err);
            });
            return deferred.promise;
        };
        this.iotaCore = $window.heatlibs.IotaCore;
        this.setUrl();
    }
    IotaBlockExplorerService.prototype.setUrl = function (url) {
        if (url === void 0) { url = 'https://nodes.thetangle.org:443'; }
        this.url = url;
        this.api = this.iotaCore.composeAPI({
            provider: 'https://nodes.thetangle.org:443'
        });
    };
    IotaBlockExplorerService = __decorate([
        Service('iotaBlockExplorerService'),
        Inject('$q', 'http', '$window'),
        __metadata("design:paramtypes", [Function, HttpService, Object])
    ], IotaBlockExplorerService);
    return IotaBlockExplorerService;
}());
var IotaCoreService = (function () {
    function IotaCoreService($window) {
        this.iotaCore = $window.heatlibs.IotaCore;
        this.converter = $window.heatlibs.IotaConverter;
        this.signing = $window.heatlibs.IotaSigning;
        this.bip39 = $window.heatlibs.bip39;
    }
    IotaCoreService.prototype.unlock = function (seed) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var walletType = _this.getNWalletsFromMnemonics(seed, 1);
            resolve(walletType);
        });
    };
    IotaCoreService.prototype.getNWalletsFromMnemonics = function (mnemonic, keyCount) {
        var walletType = { addresses: [] };
        for (var i = 0; i < keyCount; i++) {
            var wallet = this.getWallet(mnemonic, i, 2);
            walletType.addresses[i] = { address: wallet.address, privateKey: wallet.privateKey, index: i, balance: "0", inUse: false };
        }
        return walletType;
    };
    IotaCoreService.prototype.getWallet = function (mnemonic, index, securityLevel) {
        if (index === void 0) { index = 0; }
        if (securityLevel === void 0) { securityLevel = 2; }
        var address = this.iotaCore.generateAddress(mnemonic, 0, 2, false);
        return {
            address: address,
            privateKey: mnemonic
        };
    };
    IotaCoreService.prototype.refreshAdressBalances = function (wallet) {
        return new Promise(function (resolve, reject) {
            var walletAddress = wallet.addresses[0];
            var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
            iotaBlockExplorerService.getAccountInfo(walletAddress.privateKey).then(function (info) {
                walletAddress.inUse = true;
                walletAddress.balance = info.balance + "";
                resolve(true);
            }, function () {
                resolve(false);
            });
        });
    };
    IotaCoreService = __decorate([
        Service('iotaCoreService'),
        Inject('$window'),
        __metadata("design:paramtypes", [Object])
    ], IotaCoreService);
    return IotaCoreService;
}());
var IotaPendingTransactionsService = (function () {
    function IotaPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    IotaPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('iotaPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    IotaPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("iotaPendingTxn:" + address + ":" + txId + ":" + timestamp, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    IotaPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("iotaPendingTxn:" + address + ":" + txId + ":" + timestamp);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    IotaPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    IotaPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    IotaPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    IotaPendingTransactionsService = __decorate([
        Service('iotaPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], IotaPendingTransactionsService);
    return IotaPendingTransactionsService;
}());
var LightwalletService = (function () {
    function LightwalletService(web3Service, userService, settingsService, $rootScope, ethplorer, $window) {
        this.web3Service = web3Service;
        this.userService = userService;
        this.settingsService = settingsService;
        this.$rootScope = $rootScope;
        this.ethplorer = ethplorer;
        this.$window = $window;
        this.lightwallet = $window.heatlibs.lightwallet;
    }
    LightwalletService_1 = LightwalletService;
    LightwalletService.prototype.generateRandomSeed = function () {
        return this.lightwallet.keystore.generateRandomSeed();
    };
    LightwalletService.prototype.validSeed = function (seed) {
        return this.lightwallet.keystore.isSeedValid(seed);
    };
    LightwalletService.prototype.validPrivateKey = function (privKey) {
        return utils.isHex(privKey) && privKey.length > 32;
    };
    LightwalletService.prototype.unlock = function (seedOrPrivateKey, password) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promise;
            if (_this.validSeed(seedOrPrivateKey)) {
                promise = _this.getEtherWallet(seedOrPrivateKey, password || "");
            }
            else if (_this.validPrivateKey(seedOrPrivateKey)) {
                promise = _this.getEtherWalletFromPrivateKey(seedOrPrivateKey, password || "");
            }
            else {
                reject();
            }
            promise.then(function (wallet) {
                resolve(wallet);
            }).catch(function () {
                reject();
            });
        });
    };
    LightwalletService.prototype.refreshAdressBalances = function (wallet) {
        var addresses = wallet.addresses.map(function (a) { return a.address; });
        function processNext() {
            return new Promise(function (resolve, reject) {
                var address = addresses[0];
                addresses.shift();
                var ethplorer = heat.$inject.get('ethplorer');
                ethplorer.getAddressInfo(address).then(function (info) {
                    var walletAddress = wallet.addresses.find(function (x) { return x.address == address; });
                    if (!walletAddress)
                        return;
                    walletAddress.inUse = info.countTxs != 0;
                    if (!walletAddress.inUse) {
                        resolve(false);
                        return;
                    }
                    walletAddress.balance = info.ETH.balance + "";
                    walletAddress.tokensBalances = [];
                    if (info.tokens) {
                        info.tokens.forEach(function (token) {
                            var tokenInfo = ethplorer.tokenInfoCache[token.tokenInfo.address];
                            var decimals = tokenInfo ? tokenInfo.decimals : 8;
                            var amount = token.balance ? new Big(token.balance + "").toFixed() : "0";
                            walletAddress.tokensBalances.push({
                                symbol: tokenInfo ? tokenInfo.symbol : '',
                                name: tokenInfo ? tokenInfo.name : '',
                                decimals: decimals,
                                balance: utils.formatQNT(amount, decimals),
                                address: token.tokenInfo.address
                            });
                        });
                    }
                    resolve(true);
                }, function () {
                    resolve(false);
                });
            });
        }
        var recurseToNext = function recurseToNext(resolve) {
            processNext().then(function (hasMore) {
                if (hasMore) {
                    setTimeout(function () {
                        recurseToNext(resolve);
                    }, 100);
                }
                else {
                    resolve();
                }
            });
        };
        return new Promise(function (resolve) {
            recurseToNext(resolve);
        });
    };
    LightwalletService.prototype.sendEther = function (from, to, value) {
        this.web3Service.sendEther(from, to, value);
    };
    LightwalletService.prototype.getEtherWallet = function (seed, password) {
        var _this = this;
        var that = this;
        return new Promise(function (resolve, reject) {
            try {
                _this.lightwallet.keystore.createVault({
                    password: password,
                    seedPhrase: seed,
                    hdPathString: LightwalletService_1.BIP44
                }, function (err, ks) {
                    if (err) {
                        reject();
                        return;
                    }
                    var HookedWeb3Provider = _this.$window.heatlibs.HookedWeb3Provider;
                    var web3Provider = new HookedWeb3Provider({
                        host: _this.settingsService.get(SettingsService.WEB3PROVIDER),
                        transaction_signer: ks
                    });
                    _this.web3Service.web3.setProvider(web3Provider);
                    ks.passwordProvider = function (callback) {
                        callback(null, password);
                    };
                    ks.keyFromPassword(password, function (err, pwDerivedKey) {
                        if (err) {
                            reject();
                            return;
                        }
                        try {
                            var keyCount = 20;
                            ks.generateNewAddress(pwDerivedKey, keyCount);
                            var addresses = ks.getAddresses();
                            var wallet = { addresses: [] };
                            for (var i = 0; i < keyCount; i++) {
                                var walletAddress = addresses[i];
                                var privateKey = ks.exportPrivateKey(walletAddress, pwDerivedKey);
                                wallet.addresses[i] = { address: walletAddress, privateKey: privateKey, index: i, balance: "0", inUse: false };
                            }
                            resolve(wallet);
                        }
                        catch (e) {
                            console.error(e);
                            reject();
                        }
                    });
                });
            }
            catch (e) {
                console.error(e);
                reject();
            }
        });
    };
    LightwalletService.prototype.getEtherWalletFromPrivateKey = function (privkeyHex, password) {
        var _this = this;
        var that = this;
        return new Promise(function (resolve, reject) {
            try {
                _this.lightwallet.keystore.createVault({
                    password: password,
                    seedPhrase: _this.lightwallet.keystore.generateRandomSeed(),
                    hdPathString: LightwalletService_1.BIP44
                }, function (err, ks) {
                    if (err) {
                        reject();
                        return;
                    }
                    var HookedWeb3Provider = _this.$window.heatlibs.HookedWeb3Provider;
                    var web3Provider = new HookedWeb3Provider({
                        host: _this.settingsService.get(SettingsService.WEB3PROVIDER),
                        transaction_signer: ks
                    });
                    _this.web3Service.web3.setProvider(web3Provider);
                    ks.passwordProvider = function (callback) {
                        callback(null, password);
                    };
                    ks.keyFromPassword(password, function (err, pwDerivedKey) {
                        if (err) {
                            reject();
                            return;
                        }
                        try {
                            var encPrivKey = this.heatlibs.lightwallet.keystore._encryptKey(privkeyHex, pwDerivedKey);
                            var keyObj = {
                                privKey: privkeyHex,
                                encPrivKey: encPrivKey
                            };
                            var address = this.heatlibs.lightwallet.keystore._computeAddressFromPrivKey(keyObj.privKey);
                            ks.encPrivKeys[address] = keyObj.encPrivKey;
                            ks.addresses.push(address);
                            var addresses = ks.getAddresses();
                            var wallet = { addresses: [] };
                            for (var i = 0; i < addresses.length; i++) {
                                var walletAddress = addresses[i];
                                var privateKey = ks.exportPrivateKey(walletAddress, pwDerivedKey);
                                wallet.addresses[i] = { address: walletAddress, privateKey: privateKey, index: i, balance: "0", inUse: false };
                            }
                            resolve(wallet);
                        }
                        catch (e) {
                            console.error(e);
                            reject();
                        }
                    });
                });
            }
            catch (e) {
                console.error(e);
                reject();
            }
        });
    };
    var LightwalletService_1;
    LightwalletService.BIP44 = "m/44'/60'/0'/0";
    LightwalletService = LightwalletService_1 = __decorate([
        Service('lightwalletService'),
        Inject('web3', 'user', 'settings', '$rootScope', 'ethplorer', '$window'),
        __metadata("design:paramtypes", [Web3Service,
            UserService,
            SettingsService, Object, EthplorerService, Object])
    ], LightwalletService);
    return LightwalletService;
}());
var LocalKeyStoreService = (function () {
    function LocalKeyStoreService(storage, walletFile) {
        this.walletFile = walletFile;
        this.rememberedPasswords = {};
        this.store = storage.namespace("keystore", null, true);
    }
    LocalKeyStoreService.prototype.rememberPassword = function (account, password) {
        this.rememberedPasswords[account] = password;
    };
    LocalKeyStoreService.prototype.getPasswordForAccount = function (account) {
        return this.rememberedPasswords[account];
    };
    LocalKeyStoreService.prototype.testnet = function () {
        return heat.isTestnet ? '.testnet' : '';
    };
    LocalKeyStoreService.prototype.add = function (key) {
        this.rememberPassword(key.account, key.pincode);
        this.store.put("key." + key.account + this.testnet(), this.encode(key));
        this.store.put("name." + key.account + this.testnet(), key.name);
    };
    LocalKeyStoreService.prototype.addRaw = function (key) {
        var key1 = "key." + key.account + (key.isTestnet ? '.testnet' : '');
        var key2 = "name." + key.account + (key.isTestnet ? '.testnet' : '');
        if (this.store.get(key1))
            return false;
        this.store.put(key1, key.contents);
        this.store.put(key2, key.name || '');
        return true;
    };
    LocalKeyStoreService.prototype.list = function () {
        var test = heat.isTestnet ? /key\.\d+\.testnet$/ : /key\.\d+$/;
        return this.store.keys().
            filter(function (keyName) { return test.test(keyName); }).
            map(function (keyName) { return keyName.substring("key.".length).replace(/\.testnet$/, ""); });
    };
    LocalKeyStoreService.prototype.keyName = function (account) {
        return this.store.get("name." + account + this.testnet());
    };
    LocalKeyStoreService.prototype.remove = function (account) {
        this.store.remove("key." + account + this.testnet());
        this.store.remove("name." + account + this.testnet());
    };
    LocalKeyStoreService.prototype.encode = function (key) {
        var payload = JSON.stringify({
            account: key.account,
            secretPhrase: key.secretPhrase,
            pincode: key.pincode,
            name: key.name
        });
        var message = heat.crypto.passphraseEncrypt(payload, key.pincode);
        return message.encode();
    };
    LocalKeyStoreService.prototype.decode = function (encoded, passphrase) {
        var message = heat.crypto.PassphraseEncryptedMessage.decode(encoded);
        var json_str = heat.crypto.passphraseDecrypt(message, passphrase);
        var json = JSON.parse(json_str);
        return {
            account: json['account'],
            secretPhrase: json['secretPhrase'],
            pincode: json['pincode'],
            name: json['name'],
            publicKey: heat.crypto.secretPhraseToPublicKey(json['secretPhrase'])
        };
    };
    LocalKeyStoreService.prototype.load = function (account, passphrase) {
        var contents = this.store.get("key." + account + this.testnet());
        try {
            var result = this.decode(contents, passphrase);
            this.rememberPassword(account, passphrase);
            return result;
        }
        catch (e) {
            console.log(e);
        }
    };
    LocalKeyStoreService.prototype.listLocalKeyEntries = function () {
        var _this = this;
        var entries = [];
        this.store.keys().forEach(function (keyName) {
            var match = keyName.match(/key\.(\d+)(\.testnet)?/);
            if (match) {
                var isTestnet = match[2] == '.testnet';
                var account = match[1];
                var name_1 = _this.store.get("name." + account + (isTestnet ? '.testnet' : ''));
                var contents = _this.store.get(keyName);
                entries.push({
                    account: account,
                    contents: contents,
                    name: name_1,
                    isTestnet: isTestnet
                });
            }
        });
        return entries;
    };
    LocalKeyStoreService.prototype.export = function () {
        var wallet = {
            version: 1,
            entries: []
        };
        this.listLocalKeyEntries().forEach(function (entry) {
            wallet.entries.push({
                account: entry.account,
                contents: entry.contents,
                isTestnet: entry.isTestnet,
                name: entry.name
            });
        });
        return wallet;
    };
    LocalKeyStoreService.prototype.import = function (wallet) {
        var _this = this;
        var added = [];
        wallet.entries.forEach(function (entry) {
            var localKeyEntry = {
                account: entry.account,
                contents: entry.contents,
                isTestnet: entry.isTestnet,
                name: entry.name
            };
            if (_this.addRaw(localKeyEntry)) {
                added.push(localKeyEntry);
            }
        });
        return added;
    };
    LocalKeyStoreService = __decorate([
        Service('localKeyStore'),
        Inject('storage', 'walletFile'),
        __metadata("design:paramtypes", [StorageService, WalletFileService])
    ], LocalKeyStoreService);
    return LocalKeyStoreService;
}());
var NXTCryptoService = (function () {
    function NXTCryptoService($window) {
        this.$window = $window;
        this.nxtCrypto = $window.heatlibs.nxtCrypto;
    }
    NXTCryptoService.prototype.unlock = function (seedOrPrivateKey) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var walletType = { addresses: [] };
            walletType.addresses[0] = { address: _this.nxtCrypto.getAccountRSFromSecretPhrase(seedOrPrivateKey, 'NXT'), privateKey: seedOrPrivateKey };
            resolve(walletType);
        });
    };
    NXTCryptoService.prototype.refreshAdressBalances = function (wallet) {
        var address = wallet.addresses[0].address;
        return new Promise(function (resolve, reject) {
            var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
            nxtBlockExplorerService.getAccount(wallet.addresses[0].address).then(function (data) {
                wallet.addresses[0].balance = new Big(utils.convertToQNTf(data.unconfirmedBalanceNQT)).toFixed(8);
                wallet.addresses[0].inUse = true;
                nxtBlockExplorerService.getAccountAssets(address).then(function (accountAssets) {
                    wallet.addresses[0].tokensBalances = [];
                    var promises = [];
                    accountAssets.forEach(function (asset) {
                        var promise = nxtBlockExplorerService.getAssetInfo(asset.asset).then(function (assetInfo) {
                            wallet.addresses[0].tokensBalances.push({
                                symbol: assetInfo ? assetInfo.name : '',
                                name: assetInfo ? assetInfo.name : '',
                                decimals: assetInfo.decimals,
                                balance: utils.formatQNT(asset.unconfirmedQuantityQNT, assetInfo.decimals),
                                address: asset.asset
                            });
                        });
                        promises.push(promise);
                    });
                    Promise.all(promises).then(function () { return resolve(true); });
                    if (accountAssets.length === 0)
                        resolve(true);
                });
            }, function (err) {
                resolve(false);
            });
        });
    };
    NXTCryptoService = __decorate([
        Service('nxtCryptoService'),
        Inject('$window'),
        __metadata("design:paramtypes", [Object])
    ], NXTCryptoService);
    return NXTCryptoService;
}());
var NxtBlockExplorerService = (function () {
    function NxtBlockExplorerService($q, http) {
        var _this = this;
        this.$q = $q;
        this.http = http;
        this.getSocketUrl = function () {
            return _this.url;
        };
        this.getBlockchainStatus = function () {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainStatus").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data) {
                    deferred.resolve(data);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactions = function (account, firstIndex, lastIndex) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainTransactions&account=" + account + "&firstIndex=" + firstIndex + "&lastIndex=" + lastIndex).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions) {
                    deferred.resolve(data.transactions);
                }
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBlockchainTransactions&account=" + account + "&lastIndex=-1").then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.transactions)
                    deferred.resolve(data.transactions.length);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccount = function (address) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAccount&account=" + address).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.sendNxt = function (txObject) {
            var deferred = _this.$q.defer();
            _this.http.post(_this.url + txObject, {}).then(function (ret) {
                var userService = heat.$inject.get('user');
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.errorDescription) {
                    deferred.reject(data.errorDescription);
                }
                var signature = heat.crypto.signBytes(data.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = data.unsignedTransactionBytes.substr(0, 192) + signature + data.unsignedTransactionBytes.substr(320);
                _this.http.post(_this.url + "nxt?requestType=broadcastTransaction&transactionBytes=" + payload, {}).then(function (ret) {
                    var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                    if (data.errorDescription) {
                        deferred.reject(data.errorDescription);
                    }
                    deferred.resolve({ txId: data.transaction });
                });
            }, function (err) {
                deferred.reject(err.errorDescription);
            });
            return deferred.promise;
        };
        this.getTransactionStatus = function (transactionId) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getTransaction&transaction=" + transactionId).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (!data.errorDescription)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (tx) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAccountAssets&account=" + tx).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.accountAssets)
                    deferred.resolve(data.accountAssets);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getBalance = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getBalance&account=" + account).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.unconfirmedBalanceNQT)
                    deferred.resolve(data.unconfirmedBalanceNQT);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getPublicKeyFromAddress = function (account) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAccountPublicKey&account=" + account).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.publicKey)
                    deferred.resolve(data.publicKey);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.getAssetInfo = function (asset) {
            var deferred = _this.$q.defer();
            _this.http.get(_this.url + "nxt?requestType=getAsset&asset=" + asset).then(function (ret) {
                var data = JSON.parse(typeof ret === "string" ? ret : JSON.stringify(ret));
                if (data.name)
                    deferred.resolve(data);
                else
                    deferred.reject(data.errorDescription);
            });
            return deferred.promise;
        };
        this.setUrl();
    }
    NxtBlockExplorerService.prototype.setUrl = function (url) {
        if (url === void 0) { url = 'https://bitnode.heatwallet.com:7876/'; }
        this.url = url;
    };
    NxtBlockExplorerService = __decorate([
        Service('nxtBlockExplorerService'),
        Inject('$q', 'http'),
        __metadata("design:paramtypes", [Function, HttpService])
    ], NxtBlockExplorerService);
    return NxtBlockExplorerService;
}());
var NxtPendingTransactionsService = (function () {
    function NxtPendingTransactionsService($q, http, settings) {
        this.$q = $q;
        this.http = http;
        this.settings = settings;
        this.pending = {};
        this.listeners = [];
        this.readLocalStorage();
    }
    NxtPendingTransactionsService.prototype.readLocalStorage = function () {
        this.pending = {};
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            if (key.startsWith('nxtPendingTxn:')) {
                var parts = key.split(':'), addr = parts[1], txId = parts[2], time = parseInt(parts[3]);
                this.pending[addr] = this.pending[addr] || [];
                this.pending[addr].push({ txId: txId, time: time });
            }
        }
    };
    NxtPendingTransactionsService.prototype.add = function (address, txId, timestamp) {
        window.localStorage.setItem("nxtPendingTxn:" + address + ":" + txId + ":" + timestamp, "1");
        this.readLocalStorage();
        this.notifyListeners(false);
    };
    NxtPendingTransactionsService.prototype.remove = function (address, txId, timestamp) {
        window.localStorage.removeItem("nxtPendingTxn:" + address + ":" + txId + ":" + timestamp);
        this.readLocalStorage();
        this.notifyListeners(true);
    };
    NxtPendingTransactionsService.prototype.addListener = function (func) {
        this.removeListener(func);
        this.listeners.push(func);
    };
    NxtPendingTransactionsService.prototype.removeListener = function (func) {
        this.listeners = this.listeners.filter(function (fn) { return fn !== func; });
    };
    NxtPendingTransactionsService.prototype.notifyListeners = function (removed) {
        this.listeners.forEach(function (fn) { return fn(removed); });
    };
    NxtPendingTransactionsService = __decorate([
        Service('nxtPendingTransactions'),
        Inject('$q', 'http', 'settings'),
        __metadata("design:paramtypes", [Function, HttpService,
            SettingsService])
    ], NxtPendingTransactionsService);
    return NxtPendingTransactionsService;
}());
var PanelService = (function () {
    function PanelService($mdPanel) {
        this.$mdPanel = $mdPanel;
    }
    PanelService.prototype.show = function (template, locals) {
        var position = this.$mdPanel.newPanelPosition().absolute().center();
        var config = {
            attachTo: angular.element(document.body),
            controller: function () { },
            controllerAs: 'vm',
            disableParentScroll: true,
            template: template,
            hasBackdrop: false,
            panelClass: 'demo-dialog-example',
            position: position,
            trapFocus: false,
            zIndex: 30,
            clickOutsideToClose: true,
            escapeToClose: true,
            focusOnOpen: true,
            locals: locals
        };
        this.$mdPanel.open(config);
    };
    PanelService = __decorate([
        Service('panel'),
        Inject('$mdPanel'),
        __metadata("design:paramtypes", [Object])
    ], PanelService);
    return PanelService;
}());
var RenderService = (function () {
    function RenderService() {
    }
    RenderService.prototype.render = function (rawText, renderers) {
        var text = rawText;
        renderers.forEach(function (renderer) {
            text = renderer.toHtml(text);
        });
        return text;
    };
    RenderService = __decorate([
        Service('render')
    ], RenderService);
    return RenderService;
}());
var SecretGeneratorService = (function () {
    function SecretGeneratorService($q, settings, lightwalletService) {
        this.$q = $q;
        this.settings = settings;
        this.lightwalletService = lightwalletService;
    }
    SecretGeneratorService.prototype.generate = function (langCode) {
        var deferred = this.$q.defer();
        deferred.resolve(this.lightwalletService.generateRandomSeed());
        return deferred.promise;
    };
    SecretGeneratorService = __decorate([
        Service('secretGenerator'),
        Inject('$q', 'settings', 'lightwalletService'),
        __metadata("design:paramtypes", [Function, SettingsService,
            LightwalletService])
    ], SecretGeneratorService);
    return SecretGeneratorService;
}());
var ServerService = (function (_super) {
    __extends(ServerService, _super);
    function ServerService($rootScope, $q, $interval, $timeout, settings, $mdToast) {
        var _this = _super.call(this) || this;
        _this.$rootScope = $rootScope;
        _this.$q = $q;
        _this.$interval = $interval;
        _this.$timeout = $timeout;
        _this.settings = settings;
        _this.$mdToast = $mdToast;
        _this.stopServerSignalFile = 'resources/heatledger/stopserver.signal';
        _this.serverStoppedSignalFile = 'resources/heatledger/serverstopped.signal';
        _this.MAX_CONSOLE_LINE_LENGTH = 20000;
        _this.isRunning = false;
        _this.isReady = false;
        _this.buffer = [" "];
        var onbeforeunload = function () {
            window.onbeforeunload = null;
            if (_this.isRunning) {
                _this.applicationShutdown().then(function () {
                    window.close();
                });
                $timeout(function () {
                    _this.stopServer();
                }, 2000);
                $timeout(function () {
                    window.close();
                }, 8000);
                return "dont close";
            }
        };
        window.onbeforeunload = onbeforeunload;
        return _this;
    }
    ServerService.prototype.initOsDepends = function () {
        var os = this.getOS();
        var path = require('path');
        if (os == 'WIN') {
            this.cwd = path.join(__dirname, '..', 'heatledger');
            this.command = path.join('bin', 'heatledger.bat');
        }
        if (os == 'MAC') {
            this.cwd = path.join(__dirname, '..', 'heatledger');
            this.command = path.join('bin', 'heatledger');
        }
        if (os == 'LINUX') {
            this.cwd = path.join(__dirname, '..', 'heatledger');
            this.command = path.join('bin', 'heatledger');
        }
        var embeddedInWalletSignalFilePath = 'resources/heatledger/embeddedinwallet.signal';
        var fs = require('fs');
        if (!fs.existsSync(embeddedInWalletSignalFilePath)) {
            fs.writeFile(embeddedInWalletSignalFilePath, '', { flag: 'w' }, function (err) {
                if (err)
                    console.error(err);
            });
        }
    };
    ServerService.prototype.getAppDir = function (dirName) {
        var path = require('path');
        var dir = path.join(__dirname, '..', 'heatledger', dirName);
        return path.resolve(dir);
    };
    ServerService.prototype.startServer = function () {
        var _this = this;
        console.log('ServerService::start server');
        if (this.isRunning) {
            throw new Error('Server starting or already up, check server.isRunning before calling this method');
        }
        this.initOsDepends();
        var spawn = require('child-process-promise').spawn;
        this.isRunning = true;
        this.log("[SERVER] command >> " + this.command);
        this.log("[SERVER] cwd     >> " + this.cwd);
        this.getUserDataDirFromMainProcess().then(function (userDataDir) {
            var env = process.env;
            if (userDataDir) {
                var path = require('path');
                env['HEAT_WALLET_BLOCKCHAINDIR'] = path.join(userDataDir, 'blockchain');
                env['HEAT_WALLET_BLOCKCHAINDIR_TEST'] = path.join(userDataDir, 'blockchain-test');
            }
            var promise = spawn(_this.command, [], {
                cwd: _this.cwd,
                env: env
            });
            _this.childProcess = promise.childProcess;
            _this.log("[SERVER] pid     >> " + _this.childProcess.pid);
            _this.childProcess.stdout.on('data', function (data) {
                _this.log(data.toString());
            });
            _this.childProcess.stderr.on('data', function (data) {
                _this.log(data.toString());
            });
            promise.then(function () {
                _this.log("[SPAWN] DONE!");
                _this.$rootScope.$evalAsync(function () {
                    _this.isRunning = false;
                    _this.isReady = false;
                    if (_this.needsRecoveryRestart()) {
                        _this.$timeout(function () {
                            _this.startServer();
                        }, 2000, true);
                    }
                });
            })
                .catch(function (err) {
                var message = angular.isObject(err) ? (err.message || '') : '';
                _this.log("[SPAWN EXIT] " + message, err);
                _this.$rootScope.$evalAsync(function () {
                    _this.isRunning = false;
                    _this.isReady = false;
                    if (_this.needsRecoveryRestart()) {
                        _this.$timeout(function () {
                            _this.startServer();
                        }, 2000, true);
                    }
                });
            });
        });
    };
    ServerService.prototype.getUserDataDirFromMainProcess = function () {
        var ipcRenderer = require('electron').ipcRenderer;
        return new Promise(function (resolve) {
            var timeout = setTimeout(resolve, 2000);
            ipcRenderer.on('userData-is-here-reply', function (event, arg) {
                clearTimeout(timeout);
                resolve(arg);
            });
            ipcRenderer.send('userData-is-where-request', '');
        });
    };
    ServerService.prototype.log = function (msg, error) {
        var _this = this;
        if ((!msg || msg.trim().length == 0) && !error)
            return;
        if (error)
            console.log(msg, error);
        else if (this.settings.get(SettingsService.LOG_HEAT_SERVER_ALL))
            console.log(msg);
        if (!this.isReady) {
            if (msg.indexOf('** HEAT SERVER READY **') != -1) {
                this.$rootScope.$evalAsync(function () {
                    _this.isReady = true;
                });
            }
        }
        var lines = msg.split(/(\r?\n)/g);
        for (var i = 0; i < lines.length; i++) {
            if (lines[i].match(/\S/)) {
                lines[i] = new String(lines[i]);
                this.buffer.splice(this.buffer.length - 1, 0, lines[i]);
                if (this.buffer.length > this.MAX_CONSOLE_LINE_LENGTH) {
                    this.buffer.splice(0, this.buffer.length - this.MAX_CONSOLE_LINE_LENGTH);
                }
            }
        }
        this.emit('output');
    };
    ServerService.prototype.stopServer = function () {
        var _this = this;
        if (!this.isRunning)
            throw new Error('Server already stopped, check server.isRunning before calling this method');
        this.$mdToast.show(this.$mdToast.simple().textContent("Please wait while the HEAT server will be stopped").hideDelay(10000));
        var fs = require('fs');
        this.clearSignalFiles();
        var finalStopAction = function () {
            _this.clearSignalFiles();
            var kill = require('tree-kill');
            kill(pid, 'SIGTERM');
        };
        var pid = this.childProcess.pid;
        fs.writeFile(this.stopServerSignalFile, '', { flag: 'w' }, function (err) {
            if (err) {
                finalStopAction();
                console.error(err);
            }
        });
        var initStopTime = Date.now();
        var promise = this.$interval(function () {
            if (_this.isRunning) {
                var expired = Date.now() - initStopTime > 60 * 1000;
                if (fs.existsSync(_this.serverStoppedSignalFile) || expired) {
                    if (expired)
                        console.error('The waiting time has expired, the server process is stopped forcibly');
                    _this.$interval.cancel(promise);
                    finalStopAction();
                }
            }
        }, 2000, 40);
    };
    ServerService.prototype.clearSignalFiles = function () {
        var fs = require('fs');
        if (fs.existsSync(this.serverStoppedSignalFile))
            fs.unlinkSync(this.serverStoppedSignalFile);
        if (fs.existsSync(this.stopServerSignalFile))
            fs.unlinkSync(this.stopServerSignalFile);
    };
    ServerService.prototype.getOS = function () {
        if (navigator.appVersion.indexOf("Win") != -1)
            return 'WIN';
        if (navigator.appVersion.indexOf("Mac") != -1)
            return 'MAC';
        if (navigator.appVersion.indexOf("X11") != -1)
            return 'LINUX';
        if (navigator.appVersion.indexOf("Linux") != -1)
            return 'LINUX';
        throw new Error('Could not detect OS');
    };
    ServerService.prototype.applicationShutdown = function () {
        var _this = this;
        var deferred = this.$q.defer();
        dialogs.shutdown(null);
        this.$interval(function () {
            if (!_this.isRunning) {
                deferred.resolve();
            }
        }, 2000);
        return deferred.promise;
    };
    ServerService.prototype.needsRecoveryRestart = function () {
        var end = this.buffer.length - 30;
        for (var i = this.buffer.length; i > end; --i) {
            if ((this.buffer[i] + "").indexOf("To complete storage recovery process please restart") != -1) {
                return true;
            }
        }
        return false;
    };
    ServerService = __decorate([
        Service('server'),
        Inject('$rootScope', '$q', '$interval', '$timeout', 'settings', '$mdToast'),
        __metadata("design:paramtypes", [Object, Function, Function, Function, SettingsService, Object])
    ], ServerService);
    return ServerService;
}(EventEmitter));
var SettingsService = (function () {
    function SettingsService(env, http) {
        this.env = env;
        this.http = http;
        this.VERSION = "%BUILD_OVERRIDE_VERSION%";
        this.BUILD = "%BUILD_OVERRIDE_BUILD%";
        this.settings = {};
        this.applyFailoverConfig();
        this.settings[SettingsService_1.DATEFORMAT_DEFAULT] = 'yyyy-mm-dd HH:MM:ss';
        this.settings[SettingsService_1.TIMEFORMAT_DEFAULT] = 'HH:MM:ss';
        this.settings[SettingsService_1.APPLICATION_NAME] = 'HEAT';
        this.settings[SettingsService_1.APPLICATION_VERSION] = this.VERSION;
        this.settings[SettingsService_1.APPLICATION_BUILD] = this.BUILD;
        this.settings[SettingsService_1.SOCKET_RPC_TIMEOUT] = 30 * 1000;
        this.settings[SettingsService_1.SOCKET_RECONNECT_DELAY] = 2000;
        this.settings[SettingsService_1.LOG_API_ERRORS] = true;
        this.settings[SettingsService_1.LOG_API_ALL] = false;
        this.settings[SettingsService_1.LOG_NOTIFY_ALL] = false;
        this.settings[SettingsService_1.DICE_WORD_FOLDER] = "dice-words";
        this.settings[SettingsService_1.DICE_WORD_SUPPORTED_LANG] = {
            "de": ["de.txt", "677da2d5148342780f3cd1b09eaf489fac4ba00fe1083ba3296d41bdf088f471"],
            "en": ["en.txt", "b329cea782bdd8b1de49bbb9fbdef9e8230e15eb08f0d7952613992246c38f96"],
            "fi": ["fi.txt", "62323e0dc9ee39e191c98a361f20aa1417cb58da2eb5e40b9008d7973017d138"],
            "fr": ["fr.txt", "9f6e8d4845ff178cdfe8215976adeaab9e9ebaa88ab2e8ca4de14cc7a1e1989c"],
            "it": ["it.txt", "9a14dadd488e0fba95597c0b892320145d563a8b0554911af485179e91211847"],
            "jp": ["jp.txt", "b9a5e099990617e058315f98def2ff5cd1be2d65178511d93c22153f20b6d164"],
            "nl": ["nl.txt", "67b8baf68345041b029dd72fc51d1bd71c806587979d4ba7542c2534f1612168"],
            "pl": ["pl.txt", "3822db4a595364dd44f8791f523c3482d4f1276ef31bb64e10d2cd2bb4e40a99"],
            "sv": ["sv.txt", "87d1bf55193c95c03aa8e0d221dfaa94ccd8d6ea153b3d735eac235d592273fe"]
        };
        this.settings[SettingsService_1.HEAT_RPC_TIMEOUT] = 30 * 1000;
        this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://heatwallet.com:7755/ws/";
        this.settings[SettingsService_1.HEAT_WEBSOCKET_LOCAL] = "ws://localhost:7755/ws/";
        this.settings[SettingsService_1.LOG_HEAT_ERRORS] = true;
        this.settings[SettingsService_1.LOG_HEAT_ALL] = false;
        this.settings[SettingsService_1.LOG_HEAT_NOTIFY_ALL] = true;
        this.settings[SettingsService_1.LOG_HEAT_SERVER_ALL] = false;
        this.settings[SettingsService_1.HEAT_HOST_REMOTE] = "https://heatwallet.com";
        this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "7734";
        this.settings[SettingsService_1.HEAT_HOST_LOCAL] = "http://localhost";
        this.settings[SettingsService_1.HEAT_PORT_LOCAL] = "7733";
        this.settings[SettingsService_1.HEATLEDGER_CERTIFIER_ACCOUNT] = '2243498237075721643';
        this.settings[SettingsService_1.HEATLEDGER_BTC_ASSET] = '5592059897546023466';
        this.settings[SettingsService_1.HEATLEDGER_NAME_ASSIGNER] = '14439304480879065693';
        this.settings[SettingsService_1.TRANSACTION_PROCESSING_VISUALIZATION] = 111;
        this.settings[SettingsService_1.CAPTCHA_SITE_KEY] = "6Le7pBITAAAAANPHWrIsoP_ZvlxWr0bSjOPrlszc";
        this.settings[SettingsService_1.CAPTCHA_POPUP] = "https://heatwallet.com/captcha.html";
        this.settings[SettingsService_1.ETHPLORER_INFO_URL] = "https://api.ethplorer.io/getAddressInfo/:address?apiKey=lwA5173TDKj60";
        this.settings[SettingsService_1.ETHERSCAN_BALANCES_URL] = "https://api.etherscan.io/api?module=account&action=balancemulti&address=:addresses&tag=latest&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_TRANSACTION_URL] = "https://api.etherscan.io/api?module=account&action=txlist&address=:address&startblock=0&endblock=99999999&page=:page&offset=:offset&sort=desc&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_CONTRACT_ABI] = "https://api.etherscan.io/api?module=contract&action=getabi&address=:address&apikey=:apiToken";
        this.settings[SettingsService_1.ETHERSCAN_API_TOKEN] = "S54GZXNCVGEAVCF1AQZZ8A8WDMQ9811HW9";
        this.settings[SettingsService_1.WEB3PROVIDER] = "https://mainnet.infura.io/OT4wn16VtAydG2y9NVna";
        this.settings[SettingsService_1.ETH_TX_GAS_PRICE] = 20000000000;
        this.settings[SettingsService_1.ETH_TX_GAS_REQUIRED] = 21000;
        this.settings[SettingsService_1.BIP44_WALLET] = "m/44'/60'/0'/0";
        if (heat.isTestnet) {
            this.settings[SettingsService_1.HEAT_HOST_REMOTE] = "https://alpha.heatledger.com";
            this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "7734";
            this.settings[SettingsService_1.HEATLEDGER_CERTIFIER_ACCOUNT] = '4729421738299387565';
            this.settings[SettingsService_1.HEATLEDGER_BTC_ASSET] = '2801534132504071984';
            this.settings[SettingsService_1.HEATLEDGER_NAME_ASSIGNER] = '0000000';
            this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://alpha.heatledger.com:7755/ws/";
        }
        if (heat.isBetanet) {
            this.settings[SettingsService_1.HEAT_PORT_REMOTE] = "7762";
            this.settings[SettingsService_1.HEAT_PORT_LOCAL] = "7761";
            this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE] = "wss://heatwallet.com:7763/ws/";
            this.settings[SettingsService_1.HEAT_WEBSOCKET_LOCAL] = "ws://localhost:7763/ws/";
        }
        this.settings[SettingsService_1.HEAT_HOST] = this.settings[SettingsService_1.HEAT_HOST_REMOTE];
        this.settings[SettingsService_1.HEAT_PORT] = this.settings[SettingsService_1.HEAT_PORT_REMOTE];
        this.settings[SettingsService_1.HEAT_WEBSOCKET] = this.settings[SettingsService_1.HEAT_WEBSOCKET_REMOTE];
    }
    SettingsService_1 = SettingsService;
    SettingsService.getFailoverDescriptor = function () {
        if (!SettingsService_1.FAILOVER_DESCRIPTOR)
            SettingsService_1.FAILOVER_DESCRIPTOR = {
                heightDeltaThreshold: 2,
                balancesMismatchesThreshold: 0.9,
                balancesEqualityThreshold: 0.8,
                connectedPeersThreshold: 0.8,
                knownServers: []
            };
        return SettingsService_1.FAILOVER_DESCRIPTOR;
    };
    SettingsService.forceServerPriority = function (host, port) {
        var portNum = parseInt(port);
        for (var _i = 0, _a = SettingsService_1.getFailoverDescriptor().knownServers; _i < _a.length; _i++) {
            var server = _a[_i];
            if (server.host == host && server.port == portNum) {
                server.originalPriority = server.priority;
                server.priority = 0;
            }
            else {
                if (server.originalPriority)
                    server.priority = server.originalPriority;
            }
        }
    };
    SettingsService.prototype.get = function (id) {
        return this.settings[id];
    };
    SettingsService.prototype.put = function (id, value) {
        return this.settings[id] = value;
    };
    SettingsService.prototype.setCurrentServer = function (server) {
        this.settings[SettingsService_1.HEAT_HOST] = server.host;
        this.settings[SettingsService_1.HEAT_PORT] = server.port;
        this.settings[SettingsService_1.HEAT_WEBSOCKET] = server.websocket;
    };
    SettingsService.prototype.applyFailoverConfig = function () {
        var _this = this;
        var resolveFailoverDescriptor = function (json) {
            if (heat.isTestnet)
                SettingsService_1.FAILOVER_DESCRIPTOR = json.testnet;
            else if (heat.isBetanet)
                SettingsService_1.FAILOVER_DESCRIPTOR = json.betanet;
            else
                SettingsService_1.FAILOVER_DESCRIPTOR = json.mainnet;
            _this.settings[SettingsService_1.HEAT_WEBRTC_WEBSOCKET] = SettingsService_1.FAILOVER_DESCRIPTOR.signalingUrl;
        };
        if (this.env.type == EnvType.BROWSER) {
            this.http.get('failover-config.json').then(function (json) {
                resolveFailoverDescriptor(json);
            }, function (reason) {
                console.log("Cannot load 'failover-config.json': " + reason ? reason : "");
            });
        }
        else if (this.env.type == EnvType.NODEJS) {
            var fs = require('fs');
            fs.readFile('failover-config.json', function (err, data) {
                if (err) {
                    console.log("Cannot load 'failover-config.json': " + err);
                    throw err;
                }
                var json = JSON.parse(data);
                resolveFailoverDescriptor(json);
            });
        }
    };
    var SettingsService_1;
    SettingsService.EMBEDDED_HEATLEDGER_VERSION = "%BUILD_OVERRIDE_HEATLEDGER_VERSION%";
    SettingsService.DATEFORMAT_DEFAULT = 'settings.dateformat_default';
    SettingsService.TIMEFORMAT_DEFAULT = 'settings.timeformat_default';
    SettingsService.APPLICATION_NAME = 'settings.application_name';
    SettingsService.APPLICATION_VERSION = 'settings.application_version';
    SettingsService.APPLICATION_BUILD = 'settings.application_build';
    SettingsService.SOCKET_RPC_TIMEOUT = 'settings.socket_rpc_timeout';
    SettingsService.SOCKET_RECONNECT_DELAY = 'settings.socket_reconnect_delay';
    SettingsService.LOG_API_ERRORS = 'settings.log_api_errors';
    SettingsService.LOG_API_ALL = 'settings.log_api_all';
    SettingsService.LOG_NOTIFY_ALL = 'settings.log_notify_all';
    SettingsService.DICE_WORD_FOLDER = 'settings.dice_word_folder';
    SettingsService.DICE_WORD_SUPPORTED_LANG = 'settings.dice_word_supported_lang';
    SettingsService.TRANSACTION_PROCESSING_VISUALIZATION = 'settings.transaction_processing_visualization';
    SettingsService.CAPTCHA_SITE_KEY = 'settings.captcha_site_key';
    SettingsService.CAPTCHA_POPUP = 'settings.captcha_popup';
    SettingsService.HEAT_RPC_TIMEOUT = 'settings.heat_rpc_timeout';
    SettingsService.HEAT_WEBSOCKET_REMOTE = 'settings.heat_websocket_remote';
    SettingsService.HEAT_WEBSOCKET_LOCAL = 'settings.heat_websocket_local';
    SettingsService.HEAT_WEBSOCKET = 'settings.heat_websocket';
    SettingsService.HEAT_WEBRTC_WEBSOCKET = 'settings.heat_webrtc_websocket';
    SettingsService.LOG_HEAT_ERRORS = 'settings.log_heat_errors';
    SettingsService.LOG_HEAT_ALL = 'settings.log_heat_all';
    SettingsService.LOG_HEAT_NOTIFY_ALL = 'settings.log_heat_notify_all';
    SettingsService.LOG_HEAT_SERVER_ALL = 'settings.log_heat_server_all';
    SettingsService.HEAT_HOST = 'settings.heat_host';
    SettingsService.HEAT_PORT = 'settings.heat_port';
    SettingsService.HEAT_HOST_REMOTE = 'settings.heat_host_remote';
    SettingsService.HEAT_PORT_REMOTE = 'settings.heat_port_remote';
    SettingsService.HEAT_HOST_LOCAL = 'settings.heat_host_local';
    SettingsService.HEAT_PORT_LOCAL = 'settings.heat_port_local';
    SettingsService.HEATLEDGER_CERTIFIER_ACCOUNT = 'settings.heatledger_certifier_account';
    SettingsService.HEATLEDGER_BTC_ASSET = 'settings.heatledger_btc_asset';
    SettingsService.HEATLEDGER_NAME_ASSIGNER = 'settings.heatledger_name_assigner';
    SettingsService.ETHPLORER_INFO_URL = 'settings.ethplorer_get_info_url';
    SettingsService.ETHERSCAN_BALANCES_URL = 'settings.etherscan_get_balances_url';
    SettingsService.ETHERSCAN_TRANSACTION_URL = 'settings.etherscan_get_transactions_url';
    SettingsService.ETHERSCAN_CONTRACT_ABI = 'settings.etherscan_get_contract_abi';
    SettingsService.ETHERSCAN_API_TOKEN = 'settings.etherscan_api.token';
    SettingsService.WEB3PROVIDER = 'settings.web3_provider';
    SettingsService.BIP44_WALLET = 'settings.bip44_wallet';
    SettingsService.ETH_TX_GAS_PRICE = 'settings.gas_price';
    SettingsService.ETH_TX_GAS_REQUIRED = 'settings.gas';
    SettingsService = SettingsService_1 = __decorate([
        Service('settings'),
        Inject('env', 'http'),
        __metadata("design:paramtypes", [EnvService,
            HttpService])
    ], SettingsService);
    return SettingsService;
}());
var StatusService = (function () {
    function StatusService() {
    }
    StatusService.prototype.contains = function (status, flag) {
        return Boolean(status & flag);
    };
    StatusService.READ = 1;
    StatusService.TRASHED = 2;
    StatusService.REPLIED = 4;
    StatusService.STARRED = 8;
    StatusService = __decorate([
        Service('status')
    ], StatusService);
    return StatusService;
}());
var StorageService = (function () {
    function StorageService() {
        this.stores = {};
    }
    StorageService.prototype.namespace = function (namespace, $scope, globalScope) {
        var _this = this;
        var store = new Store(namespace, this);
        if ($scope) {
            $scope.$on('$destroy', function () {
                _this.removeStore(store);
            });
        }
        this.addStore(store);
        if (!angular.isDefined(globalScope) || !globalScope) {
            this.user = this.user || heat.$inject.get('user');
            if (this.user.unlocked) {
                if (this.user.key)
                    store.enable(this.user.key.account);
                else
                    store.enable(this.user.account);
            }
            else {
                var closure = function () {
                    _this.user.removeListener(UserService.EVENT_UNLOCKED, closure);
                    if (_this.user.key)
                        store.enable(_this.user.key.account);
                    else
                        store.enable(_this.user.account);
                };
                this.user.on(UserService.EVENT_UNLOCKED, closure);
            }
        }
        else {
            store.enable();
        }
        return store;
    };
    StorageService.prototype.addStore = function (store) {
        (this.stores[store.namespace] = this.stores[store.namespace] || []).push(store);
    };
    StorageService.prototype.removeStore = function (store) {
        if (angular.isArray(this.stores[store.namespace])) {
            this.stores[store.namespace] = this.stores[store.namespace].filter(function (s) { return s != store; });
            if (this.stores[store.namespace].length == 0) {
                delete this.stores[store.namespace];
            }
        }
        store.removeAllListeners();
    };
    StorageService.prototype.emit = function (namespace, event) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var ns = this.stores[namespace];
        if (angular.isArray(ns)) {
            ns.forEach(function (store) {
                store.emit.apply(store, [event].concat(args));
            });
        }
    };
    StorageService = __decorate([
        Service('storage')
    ], StorageService);
    return StorageService;
}());
var Store = (function (_super) {
    __extends(Store, _super);
    function Store(namespace, storage) {
        var _this = _super.call(this) || this;
        _this.namespace = namespace;
        _this.storage = storage;
        _this.enabled = false;
        if (!angular.isString(namespace) || !utils.emptyToNull(namespace))
            throw new Error('Illegal argument, namespace must be a non-empty string');
        return _this;
    }
    Store.prototype.enable = function (userScope) {
        this.prefix = this.namespace + ".";
        if (angular.isDefined(userScope)) {
            this.prefix = userScope + "." + this.prefix;
        }
        this.enabled = true;
    };
    Store.prototype.disable = function () {
        this.enabled = false;
    };
    Store.prototype.ensureIsEnabled = function () {
        if (!this.enabled) {
            throw new Error('Store not enabled. Are you accessing a user scoped Store without a user being signed in?');
        }
    };
    Store.prototype.clear = function () {
        var _this = this;
        this.forEach(function (namespacedKey) { _this.remove(namespacedKey); });
    };
    Store.prototype.remove = function (path) {
        this.ensureIsEnabled();
        var key = this.prefix + path;
        localStorage.removeItem(key);
        this.storage.emit(this.namespace, Store.EVENT_REMOVE, key);
    };
    Store.prototype.put = function (path, val) {
        this.ensureIsEnabled();
        var key = this.prefix + path, value = JSON.stringify(val);
        localStorage.setItem(key, value);
        this.storage.emit(this.namespace, Store.EVENT_PUT, key, value);
    };
    Store.prototype.get = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getObject = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getNumber = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getBoolean = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.getString = function (path, defaultValue) {
        return this.read(path, defaultValue);
    };
    Store.prototype.forEach = function (callbackFn) {
        var _this = this;
        this.keys().forEach(function (namespacedKey) {
            if (callbackFn.length > 1)
                callbackFn(namespacedKey, _this.get(namespacedKey), _this.prefix + namespacedKey);
            else
                callbackFn(namespacedKey);
        });
    };
    Store.prototype.keys = function () {
        var keys = [];
        var fullyQualifiedKey, namespacedKey;
        for (var i = 0; i < localStorage.length; i++) {
            fullyQualifiedKey = localStorage.key(i);
            if (fullyQualifiedKey.indexOf(this.prefix) == 0) {
                namespacedKey = fullyQualifiedKey.substring(this.prefix.length);
                keys.push(namespacedKey);
            }
        }
        return keys;
    };
    Store.prototype.read = function (path, defaultValue) {
        this.ensureIsEnabled();
        var text = localStorage.getItem(this.prefix + path);
        if (angular.isString(text)) {
            try {
                return JSON.parse(text);
            }
            catch (e) {
                console.error("Could not read localStorage key '" + path + "', throws", e);
            }
        }
        return angular.isDefined(defaultValue) ? defaultValue : null;
    };
    Store.EVENT_PUT = 'put';
    Store.EVENT_REMOVE = 'remove';
    return Store;
}(EventEmitter));
var TrollboxService = (function () {
    function TrollboxService($rootScope, heat, user) {
        this.$rootScope = $rootScope;
        this.heat = heat;
        this.user = user;
        this.host = "https://heatwallet.com";
        this.port = 7734;
        this.wss = "wss://heatwallet.com:7755/ws/";
        this.subscriber = heat.createSubscriber(this.wss);
    }
    TrollboxService.prototype.join = function (name) {
        this.name = name;
    };
    TrollboxService.prototype.getMessages = function () {
        var fromSlack = this.heat.getRaw(this.host, this.port, '/microservice/trollbox/messages');
        return [fromSlack];
    };
    TrollboxService.prototype.sendMessage = function (message) {
        return this.heat.postRaw(this.host, this.port, '/microservice/trollbox/send', {
            username: this.name,
            message: message,
            publicKey: this.user.publicKey,
            signature: heat.crypto.signBytes(converters.stringToHexString("hello"), converters.stringToHexString(this.user.secretPhrase))
        });
    };
    TrollboxService.prototype.subscribe = function (callback, $scope) {
        return this.subscriber.microservice({ 'microservice': 'trollbox.service' }, callback, $scope);
    };
    TrollboxService = __decorate([
        Service('trollbox'),
        Inject('$rootScope', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, HeatService,
            UserService])
    ], TrollboxService);
    return TrollboxService;
}());
var Update3rdPartyAPIResponsesUtil = (function () {
    function Update3rdPartyAPIResponsesUtil() {
    }
    Update3rdPartyAPIResponsesUtil.updateBTCGetAddressInfo = function (info, btcProvider) {
        if (btcProvider instanceof BtcBlockExplorer3rdPartyService) {
            var transactions_1 = new Set();
            if (info.txrefs) {
                info.txrefs.forEach(function (txref) {
                    transactions_1.add(txref.tx_hash);
                });
            }
            info.transactions = Array.from(transactions_1);
            info.txApperances = info.final_n_tx;
            info.balanceSat = info.final_balance;
            return info;
        }
        return info;
    };
    Update3rdPartyAPIResponsesUtil.updateBTCGetTxInfo = function (info, btcProvider) {
        if (btcProvider instanceof BtcBlockExplorer3rdPartyService) {
            info.blockheight = info.block_height;
            return info;
        }
        return info;
    };
    Update3rdPartyAPIResponsesUtil = __decorate([
        Service('update3rdPartyAPIResponsesUtil')
    ], Update3rdPartyAPIResponsesUtil);
    return Update3rdPartyAPIResponsesUtil;
}());
var UserService = (function (_super) {
    __extends(UserService, _super);
    function UserService($q, $window, localKeyStore, settings, $location, $rootScope) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.$window = $window;
        _this.localKeyStore = localKeyStore;
        _this.settings = settings;
        _this.$location = $location;
        _this.$rootScope = $rootScope;
        _this.unlocked = false;
        _this.currency = null;
        return _this;
    }
    UserService_1 = UserService;
    Object.defineProperty(UserService.prototype, "secretPhrase", {
        get: function () {
            return this.__secretPhrase;
        },
        set: function (s) {
            this.__secretPhrase = s;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "publicKey", {
        get: function () {
            return this.__publicKey;
        },
        set: function (p) {
            this.__publicKey = p;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "account", {
        get: function () {
            return this.__acount;
        },
        set: function (a) {
            this.__acount = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserService.prototype, "key", {
        get: function () {
            return this.__key;
        },
        set: function (k) {
            this.__key = k;
        },
        enumerable: true,
        configurable: true
    });
    UserService.prototype.refresh = function () {
        var _this = this;
        var deferred = this.$q.defer();
        var assigner = this.settings.get(SettingsService.HEATLEDGER_NAME_ASSIGNER);
        var heatService = heat.$inject.get('heat');
        heatService.api.getTransactionsFromTo(assigner, this.account, 0, 10).then(function (transactions) {
            for (var i = 0; i < transactions.length; i++) {
                var rawText = heatService.getHeatMessageContents(transactions[i]);
                if (rawText) {
                    if (_this.tryParseRegistrationMessage(rawText)) {
                        return;
                    }
                }
            }
        }).finally(deferred.resolve);
        return deferred.promise;
    };
    UserService.prototype.unlock = function (secretPhrase, key, bip44Compatible, currency) {
        var _this = this;
        var deferred = this.$q.defer();
        this.$rootScope.$evalAsync(function () {
            _this.$rootScope.$evalAsync(function () {
                if (key)
                    _this.key = key;
                if (!currency) {
                    var address = heat.crypto.getAccountId(secretPhrase);
                    currency = new HEATCurrency(secretPhrase, address);
                }
                _this.currency = currency;
                _this.bip44Compatible = bip44Compatible || false;
                _this.secretPhrase = secretPhrase;
                _this.publicKey = heat.crypto.secretPhraseToPublicKey(secretPhrase);
                _this.account = heat.crypto.getAccountId(secretPhrase);
                _this.unlocked = true;
                _this.accountName = '[no name]';
                _this.refresh().then(function () {
                    deferred.resolve();
                    _this.emit(UserService_1.EVENT_UNLOCKED);
                });
            });
        });
        return deferred.promise;
    };
    UserService.prototype.lock = function (noreload) {
        this.key = null;
        this.secretPhrase = null;
        this.unlocked = false;
        this.account = null;
        this.currency = null;
        this.bip44Compatible = false;
        this.emit(UserService_1.EVENT_LOCKED);
        if (noreload)
            return;
        window.location.reload(true);
    };
    UserService.prototype.requireLogin = function () {
        if (!this.unlocked) {
            this.$location.path('login');
        }
    };
    UserService.prototype.tryParseRegistrationMessage = function (rawText) {
        var regexp = /You have chosen the (public|private) user name `(.*)`/m;
        var match = rawText.match(regexp);
        if (match) {
            this.accountNameIsPrivate = match[1] == 'private';
            this.accountName = match[2];
            if (this.key && this.key.name != this.accountName) {
                this.key.name = this.accountName;
                this.localKeyStore.add(this.key);
            }
            return true;
        }
        return false;
    };
    var UserService_1;
    UserService.EVENT_UNLOCKED = 'unlocked';
    UserService.EVENT_LOCKED = 'locked';
    UserService = UserService_1 = __decorate([
        Service('user'),
        Inject('$q', '$window', 'localKeyStore', 'settings', '$location', '$rootScope'),
        __metadata("design:paramtypes", [Object, Object, LocalKeyStoreService,
            SettingsService, Object, Object])
    ], UserService);
    return UserService;
}(EventEmitter));
var WalletFileService = (function () {
    function WalletFileService() {
    }
    WalletFileService.prototype.createFromText = function (contents) {
        return this.decode(contents);
    };
    WalletFileService.prototype.encode = function (walletFile) {
        return JSON.stringify(walletFile, null, 2);
    };
    WalletFileService.prototype.decode = function (contents) {
        var data = this.parseJSON(contents);
        if (!data)
            return null;
        var version = data.version;
        if (!angular.isNumber(version))
            return null;
        if (version != 1)
            return null;
        var entries = data.entries;
        if (!angular.isArray(entries))
            return null;
        var walletFile = {
            version: version,
            entries: []
        };
        entries.forEach(function (entry) {
            if (angular.isString(entry.contents)) {
                walletFile.entries.push(entry);
            }
        });
        return walletFile;
    };
    WalletFileService.prototype.parseJSON = function (contents) {
        try {
            var json = JSON.parse(contents);
            if (angular.isObject(json))
                return json;
        }
        catch (e) {
            console.log('Could not parse wallet file', e);
        }
    };
    WalletFileService = __decorate([
        Service('walletFile')
    ], WalletFileService);
    return WalletFileService;
}());
var Web3Service = (function () {
    function Web3Service($q, userService, settingsService, $window) {
        var _this = this;
        this.$q = $q;
        this.userService = userService;
        this.settingsService = settingsService;
        this.$window = $window;
        this.getTransactionCount = function (from) {
            return new Promise(function (resolve, reject) {
                _this.web3.eth.getTransactionCount(from, function (error, result) {
                    if (error)
                        reject(error);
                    resolve(_this.web3.toHex(result));
                });
            });
        };
        this.getGasEstimate = function (_from, _to, _data) {
            return new Promise(function (resolve, reject) {
                _this.web3.eth.estimateGas({ from: _from, data: _data, to: _to }, function (error, result) {
                    if (error)
                        reject(error);
                    resolve(_this.web3.toHex(result));
                });
            });
        };
        this.getGasPrice = function () {
            return new Promise(function (resolve, reject) {
                _this.web3.eth.getGasPrice(function (error, result) {
                    if (error)
                        reject(error);
                    resolve(result.toString());
                });
            });
        };
        var Web3 = $window.heatlibs.Web3;
        this.web3 = new Web3(new Web3.providers.HttpProvider(this.settingsService.get(SettingsService.WEB3PROVIDER)));
    }
    Web3Service.prototype.parseInput = function (input) {
        return this.web3.toAscii(input);
    };
    Web3Service.prototype.getBalanceOf = function (address) {
        var _this = this;
        var deferred = this.$q.defer();
        this.web3.eth.getBalance(address, function (err, balance) {
            if (err)
                deferred.reject(err);
            else
                deferred.resolve(_this.web3.fromWei(balance));
        });
        return deferred.promise;
    };
    Web3Service.prototype.sendEther = function (_from, _to, _value) {
        var _this = this;
        var data = {
            from: _from,
            to: _to,
            value: _value,
            gasPrice: this.settingsService.get(SettingsService.ETH_TX_GAS_PRICE),
            gas: this.settingsService.get(SettingsService.ETH_TX_GAS_REQUIRED)
        };
        return new Promise(function (resolve, reject) {
            _this.web3.eth.sendTransaction(data, function (err, txHash) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve({
                        txHash: txHash
                    });
                }
            });
        });
    };
    Web3Service = __decorate([
        Service('web3'),
        Inject('$q', 'user', 'settings', '$window'),
        __metadata("design:paramtypes", [Function, UserService,
            SettingsService, Object])
    ], Web3Service);
    return Web3Service;
}());
var MofoSocketService = (function () {
    function MofoSocketService($q, $timeout, $interval, $rootScope) {
        var _this = this;
        this.$q = $q;
        this.$timeout = $timeout;
        this.$interval = $interval;
        this.$rootScope = $rootScope;
        this.mofoSocket = function (url) {
            if (url === void 0) { url = 'wss://cloud.mofowallet.org:7986/ws/'; }
            if (_this.url == url && _this.socket !== undefined) {
                return new Promise(function (resolve, reject) {
                    resolve(_this.socket);
                });
            }
            return _this.createSocket(url);
        };
        this.getSocketUrl = function () {
            return _this.url;
        };
        this.createSocket = function (url) {
            return new Promise(function (resolve, reject) {
                _this.url = url;
                _this.socket = new WebSocket(url);
                _this.socket.onclose = function (evt) { _this.onclose(evt); reject(); };
                _this.socket.onopen = function (evt) { _this.onopen(evt); resolve(_this.socket); };
                _this.socket.onerror = function (evt) { _this.onmessage(evt); };
                _this.socket.onmessage = function (evt) { _this.onmessage(evt); };
            });
        };
        this._send = function (argv) {
            if (_this.socket && _this.socket.readyState == 1) {
                var message = JSON.stringify(argv);
                _this.socket.send(message);
            }
        };
        this.onopen = function (event) {
            console.log('WEBSOCKET - onopen ' + new Date(), { socket: _this.socket, event: event });
            if (_this.alive_cb)
                _this.$interval.cancel(_this.alive_cb);
            _this.alive_cb = _this.$interval(_this._createKeepAliveIntervalHandler(), 10000);
        };
        this._createKeepAliveIntervalHandler = function () {
            return function () {
                _this._send('ping');
            };
        };
        this.onclose = function (event) {
            console.log('WEBSOCKET - onclose ' + new Date(), { socket: _this.socket, event: event });
        };
        this.onerror = function (event) {
            console.log('WEBSOCKET - onerror REMOVE BAD URL [' + _this.url + ']' + new Date(), { event: event });
        };
        this.onmessage = function (event) {
            var message = event.data;
            if (message == "pong" || !message) {
                return;
            }
            try {
                var data = JSON.parse(message);
            }
            catch (e) {
                console.log('WEBSOCKET - JSON parse error', { socket: _this.socket, event: event });
                return;
            }
            if (!Array.isArray(data)) {
                throw new Error('WEBSOCKET - Expected an array');
            }
            var op = data[0];
            if (op == "response") {
                _this.$rootScope.$broadcast(data[1], data[2]);
            }
            else {
                throw new Error('WEBSOCKET - Unsupported operation');
            }
        };
        this.getTransactions = function (account, timestamp) {
            if (timestamp === void 0) { timestamp = 0; }
            var deferred = _this.$q.defer();
            _this._send(['call', 'getTransactions', 'getActivity', { account: account }]);
            _this.$rootScope.$on('getTransactions', function (event, opts) {
                if (opts.transactions)
                    deferred.resolve(opts.transactions);
                else
                    deferred.reject();
            });
            return deferred.promise;
        };
        this.getTransactionsCount = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getTransactionsCount', 'getActivity', { account: account }]);
            _this.$rootScope.$on('getTransactionsCount', function (event, opts) {
                deferred.resolve(15);
            });
            return deferred.promise;
        };
        this.getAccount = function (address) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getFIMKAccount', 'getAccount', { account: address }]);
            _this.$rootScope.$on('getFIMKAccount', function (event, opts) {
                if (opts.unconfirmedBalanceNQT) {
                    deferred.resolve(opts);
                }
                else if (opts.errorDescription == "Unknown account") {
                    deferred.resolve("0.00000000");
                }
                else {
                    deferred.reject(opts.errorDescription);
                }
            });
            return deferred.promise;
        };
        this.sendFim = function (txObject) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'sendMoney', 'callAPIFunction', txObject]);
            _this.$rootScope.$on('sendMoney', function (event, opts) {
                if (!opts.unsignedTransactionBytes) {
                    deferred.reject(opts.errorDescription);
                }
                var userService = heat.$inject.get('user');
                var signature = heat.crypto.signBytes(opts.unsignedTransactionBytes, converters.stringToHexString(userService.secretPhrase));
                var payload = opts.unsignedTransactionBytes.substr(0, 192) + signature + opts.unsignedTransactionBytes.substr(320);
                _this._send(['call', 'broadcastTransaction', 'callAPIFunction', { requestType: 'broadcastTransaction', transactionBytes: payload }]);
                _this.$rootScope.$on('broadcastTransaction', function (event, opts) {
                    if (opts.errorCode) {
                        deferred.reject(opts.errorDescription);
                    }
                    else {
                        deferred.resolve({ txId: opts.transaction });
                    }
                });
            });
            return deferred.promise;
        };
        this.getRecentTx = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getRecentTransactions', 'getRecentTransactions', { accounts: [account] }]);
            _this.$rootScope.$on('getRecentTransactions', function (event, opts) {
                if (!opts.errorCode) {
                    deferred.resolve(opts);
                }
                else {
                    deferred.reject(opts.error);
                }
            });
            return deferred.promise;
        };
        this.getAccountAssets = function (account) {
            var deferred = _this.$q.defer();
            _this._send(['call', 'getAccountAssets', 'callAPIFunction', { requestType: 'getAccountAssets', account: account }]);
            _this.$rootScope.$on('getAccountAssets', function (event, opts) {
                if (!opts.errorCode) {
                    deferred.resolve(opts.accountAssets);
                }
                else {
                    deferred.reject(opts.error);
                }
            });
            return deferred.promise;
        };
    }
    MofoSocketService = __decorate([
        Service('mofoSocketService'),
        Inject('$q', '$timeout', '$interval', '$rootScope'),
        __metadata("design:paramtypes", [Function, Function, Function, Object])
    ], MofoSocketService);
    return MofoSocketService;
}());
var LoginComponent = (function () {
    function LoginComponent($scope, $q, user, $location, heat, localKeyStore, secretGenerator, clipboard, $mdToast, env, settings, walletFile, panel, lightwalletService) {
        this.$scope = $scope;
        this.$q = $q;
        this.user = user;
        this.$location = $location;
        this.heat = heat;
        this.localKeyStore = localKeyStore;
        this.secretGenerator = secretGenerator;
        this.clipboard = clipboard;
        this.$mdToast = $mdToast;
        this.env = env;
        this.settings = settings;
        this.walletFile = walletFile;
        this.panel = panel;
        this.lightwalletService = lightwalletService;
        this.bip44Compatible = false;
        this.page = '';
        this.localKeys = [];
        this.key = null;
        this.hasWhitespace = /^\s+|\s+$/gm;
        this.availableAPIServers = [];
        this.pageAddCalculatedAccountId = 'Enter secret phrase to see account id';
        this.pageAddWalletInvalid = false;
        this.pageSigninWrongPincode = false;
        this.pageCreateNameType = 'public';
        this.pageCreateUserName = '';
        this.pageCreateLoading = false;
        try {
            this.isFileSaverSupported = !!new Blob;
        }
        catch (e) { }
        this.useExternalCaptcha = env.type != EnvType.BROWSER;
        this.generateNewSecretPhrase();
        this.initLocalKeys();
        if (this.localKeys.length != 0) {
            this.pageSigninAccount = this.localKeys[0].account;
            this.page = 'signin';
        }
        else {
            this.page = 'create';
        }
        new ClipboardJS('#copy-secret');
    }
    LoginComponent.prototype.initLocalKeys = function () {
        var _this = this;
        this.localKeys = this.localKeyStore.list().map(function (account) {
            return {
                name: _this.localKeyStore.keyName(account),
                account: account
            };
        });
    };
    LoginComponent.prototype.apiServerChanged = function () {
        var parts = this.apiServer.split(":");
        this.settings.put(SettingsService.HEAT_PORT, parts.splice(-1, 1)[0]);
        this.settings.put(SettingsService.HEAT_HOST, parts.join(''));
    };
    LoginComponent.prototype.pageAddRemoveSecretPhraseHiddenChars = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageAddSecretPhrase = _this.pageAddSecretPhrase.replace(/^\s+/, "").replace(/\s+$/, "");
            _this.pageAddSecretPhraseChanged();
        });
    };
    LoginComponent.prototype.pageAddLogin = function () {
        var _this = this;
        this.user.unlock(this.pageAddSecretPhrase, undefined, this.lightwalletService.validSeed(this.pageAddSecretPhrase)).then(function () {
            _this.$location.path("explorer-account/" + _this.user.account + "/transactions");
        });
    };
    LoginComponent.prototype.pageAddSecretPhraseChanged = function () {
        var _this = this;
        this.pageAddPublicKey = heat.crypto.secretPhraseToPublicKey(this.pageAddSecretPhrase);
        this.pageAddAccount = heat.crypto.getAccountIdFromPublicKey(this.pageAddPublicKey);
        this.pageAddSecretPhraseHasHiddenChars = this.hasWhitespace.test(this.pageAddSecretPhrase);
        this.bip44Compatible = this.lightwalletService.validSeed(this.pageAddSecretPhrase);
        this.$scope.$evalAsync(function () {
            _this.pageAddCalculatedAccountId = _this.pageAddAccount;
        });
    };
    LoginComponent.prototype.pageAddAddSecretPhrase = function () {
        var _this = this;
        var key = {
            account: this.pageAddAccount,
            secretPhrase: this.pageAddSecretPhrase,
            pincode: this.pageAddPincode,
            name: '',
            publicKey: heat.crypto.secretPhraseToPublicKey(this.pageAddSecretPhrase)
        };
        this.localKeyStore.add(key);
        this.user.unlock(this.pageAddSecretPhrase, key, this.lightwalletService.validSeed(this.pageAddSecretPhrase)).then(function () {
            _this.$location.path("explorer-account/" + _this.user.account + "/transactions");
        });
    };
    LoginComponent.prototype.pageAddFileInputChange = function (files) {
        var _this = this;
        if (files && files[0]) {
            var reader_1 = new FileReader();
            reader_1.onload = function () {
                _this.$scope.$evalAsync(function () {
                    _this.pageAddWalletInvalid = true;
                    var fileContents = reader_1.result;
                    _this.pageAddWallet = _this.walletFile.createFromText(fileContents);
                    if (_this.pageAddWallet) {
                        _this.pageAddWalletInvalid = false;
                    }
                });
            };
            reader_1.readAsText(files[0]);
        }
    };
    LoginComponent.prototype.pageAddWalletImportContinue = function () {
        var _this = this;
        var addedKeys = this.localKeyStore.import(this.pageAddWallet);
        this.initLocalKeys();
        var message = "Imported " + addedKeys.length + " keys into this device";
        this.$mdToast.show(this.$mdToast.simple().textContent(message).hideDelay(5000));
        this.$scope.$evalAsync(function () {
            _this.page = '';
        });
    };
    LoginComponent.prototype.pageSinginLogin = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageSigninWrongPincode = false;
            var key = _this.localKeyStore.load(_this.pageSigninAccount, _this.pageSigninPincode);
            if (key) {
                _this.user.unlock(key.secretPhrase, key, _this.lightwalletService.validSeed(key.secretPhrase)).then(function () {
                    _this.$location.path("explorer-account/" + _this.user.account + "/transactions");
                });
            }
            else {
                _this.pageSigninWrongPincode = true;
            }
        });
    };
    LoginComponent.prototype.createAccount = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pageCreateLoading = true;
            _this.pageCreateError = null;
        });
        var isprivate = this.pageCreateNameType != 'public';
        var fullNameUTF8 = this.pageCreateUserName.trim();
        var nameHashStr = heat.crypto.fullNameToHash(fullNameUTF8);
        var publicKey = this.pageCreatePublicKey;
        var input = isprivate ?
            converters.stringToHexString(nameHashStr + this.pageCreateAccount) :
            converters.stringToHexString(fullNameUTF8 + nameHashStr + this.pageCreateAccount);
        heat.crypto.SHA256.init();
        heat.crypto.SHA256.update(converters.hexStringToByteArray(input));
        var message = converters.byteArrayToHexString(heat.crypto.SHA256.getBytes());
        var signatureArg = heat.crypto.signBytes(message, converters.stringToHexString(this.pageCreateSecretPhrase));
        if (!heat.crypto.verifyBytes(signatureArg, message, publicKey)) {
            throw new Error("Cant verify own signature");
        }
        this.heat.api.registerAccountName(this.pageCreatePublicKey, this.pageCreateRecaptchaResponse, fullNameUTF8, isprivate, signatureArg).then(function (transaction) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateLoading = false;
                _this.page = 'createSuccess';
            });
        }, function (error) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateLoading = false;
                _this.pageCreateError = error.description;
            });
        });
    };
    LoginComponent.prototype.isValidPincode = function (pincode) {
        return /^[a-zA-Z0-9_.-]{4,15}$/.test(pincode);
    };
    LoginComponent.prototype.generateNewSecretPhrase = function () {
        var _this = this;
        this.secretGenerator.generate('en').then(function (secretPhrase) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateSecretPhrase = secretPhrase;
                _this.pageCreatePublicKey = heat.crypto.secretPhraseToPublicKey(secretPhrase);
                _this.pageCreateAccount = heat.crypto.getAccountIdFromPublicKey(_this.pageCreatePublicKey);
                _this.bip44Compatible = _this.lightwalletService.validSeed(secretPhrase);
            });
        });
    };
    LoginComponent.prototype.printPassphrase = function () {
        var html = '<html><head>' +
            '<style type="text/css">html{font-family:GillSans,Calibri,Trebuchet,sans-serif;}</style>' +
            '</head><body>' + this.templateHTML() + '</body></html>';
        var popup = window.open("data:text/html;base64," + btoa(html), '_blank', 'toolbar=0,location=0,menubar=0');
        popup.print();
        popup.close();
    };
    LoginComponent.prototype.savePassphrase = function () {
        var blob = new Blob([this.templateText()], { type: "text/plain;charset=utf-8" });
        saveAs(blob, "heatledger-" + this.pageCreateUserName + "-" + this.pageCreateAccount + ".txt");
    };
    LoginComponent.prototype.showPassphrase = function () {
        this.panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <textarea rows=\"2\" flex ng-bind=\"vm.secretPhrase\" readonly ng-trim=\"false\"></textarea>\n        </md-input-container>\n      </div>\n    ", {
            secretPhrase: this.pageCreateSecretPhrase
        });
    };
    LoginComponent.prototype.templateText = function () {
        return [
            'When stored the passphrase in this document will forever give you access to your HEAT funds.',
            '',
            "Account: " + this.pageCreateUserName + " (" + this.pageCreateAccount + ")",
            '',
            'Passphrase:',
            this.pageCreateSecretPhrase,
            '',
            "Publickey:",
            this.pageCreatePublicKey,
            '',
            'https://heatwallet.com'
        ].join('\r\n');
    };
    LoginComponent.prototype.templateHTML = function () {
        return [
            '<h1>HEAT Paper Wallet</h1>',
            '',
            'When stored the passphrase in this document will forever give you access to your HEAT funds.',
            '',
            "Paper wallet for <b>" + this.pageCreateUserName + "</b> (" + this.pageCreateAccount + ")",
            '',
            'Passphrase:',
            "<u>" + this.pageCreateSecretPhrase + "</u>",
            '',
            "Publickey:",
            this.pageCreatePublicKey,
            '',
            '<a href="https://heatwallet.com" target="_blank">https://heatwallet.com</a>'
        ].join('<br>');
    };
    LoginComponent.prototype.createLocalAccount = function () {
        var _this = this;
        var key = {
            account: this.pageCreateAccount,
            secretPhrase: this.pageCreateSecretPhrase,
            pincode: this.pageCreatePincode,
            name: this.pageCreateUserName,
            publicKey: heat.crypto.secretPhraseToPublicKey(this.pageAddSecretPhrase)
        };
        this.localKeyStore.add(key);
        this.user.unlock(this.pageCreateSecretPhrase, key, this.lightwalletService.validSeed(this.pageCreateSecretPhrase)).then(function () {
            _this.$location.path('new');
        });
    };
    LoginComponent.prototype.doChallenge = function () {
        var _this = this;
        this.showChallenge().then(function (response) {
            _this.$scope.$evalAsync(function () {
                _this.pageCreateRecaptchaResponse = response;
            });
        });
    };
    LoginComponent.prototype.showChallenge = function () {
        var _this = this;
        var deferred = this.$q.defer();
        if (angular.isDefined(this.pageCreateRecaptchaWindow)) {
            this.pageCreateRecaptchaWindow.close();
            this.pageCreateRecaptchaWindow = null;
        }
        var url = this.settings.get(SettingsService.CAPTCHA_POPUP);
        this.pageCreateRecaptchaWindow = window.open(url, "New Window", "width=600,height=600,resizable=1,modal=1");
        var resolved = false;
        window.addEventListener("message", function (event) {
            try {
                var data = JSON.parse(event.data);
                switch (data.messageType) {
                    case "token": {
                        if (angular.isString(data.message.response)) {
                            resolved = true;
                            deferred.resolve(data.message.response);
                            _this.pageCreateRecaptchaWindow.close();
                        }
                        break;
                    }
                    case "beforeunload": {
                        if (!resolved) {
                            resolved = true;
                            deferred.resolve(null);
                        }
                    }
                }
            }
            catch (e) {
                console.log('Postmessage parse error', e);
            }
        }, false);
        return deferred.promise;
    };
    LoginComponent = __decorate([
        RouteConfig('/login'),
        Component({
            selector: 'login',
            template: "\n    <div layout=\"column\" flex layout-align=\"start center\">\n      <div layout=\"column\" layout-padding class=\"outer-container\">\n        <div layout=\"column\" layout-align=\"start center\" layout-padding>\n          <img src=\"assets/heatwallet.png\" class=\"wallet\">\n        </div>\n        <div layout=\"column\" flex>\n\n          <!-- SIGNIN, CREATE & ADD buttons -->\n          <div layout=\"column\" flex ng-if=\"!vm.page\">\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='signin'\" aria-label=\"Sign in\" ng-show=\"vm.localKeys.length\">\n                <md-tooltip md-direction=\"bottom\">Sign in with your Password (or Pin Code)</md-tooltip>\n                Sign in\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create';vm.generateNewSecretPhrase()\" aria-label=\"Create\">\n                <md-tooltip md-direction=\"bottom\">Create a new account</md-tooltip>\n                Create\n              </md-button>\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Add\">\n                <md-tooltip md-direction=\"bottom\">Add existing account</md-tooltip>\n                Add\n              </md-button>\n            </div>\n          </div>\n\n          <!-- SIGNIN page (dropdown shows keys in wallet, must enter pin) -->\n          <div layout=\"column\" flex ng-if=\"vm.page=='signin'\">\n            <div layout=\"column\" flex>\n              <md-input-container>\n                <label>Account</label>\n                <md-select ng-model=\"vm.pageSigninAccount\" ng-change=\"vm.pageSigninPincode=null;\">\n                  <md-option ng-repeat=\"key in vm.localKeys\" value=\"{{key.account}}\">{{key.name||key.account}}</md-option>\n                </md-select>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex ng-show=\"vm.pageSigninAccount\">\n                <label>Password (or Pin Code)</label>\n                <input type=\"password\" ng-model=\"vm.pageSigninPincode\" required name=\"pincode\" maxlength=\"15\">\n              </md-input-container>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\" ng-show=\"vm.pageSigninWrongPincode\">\n              <b>sorry, buts that the wrong pincode</b>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">Options</md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageSinginLogin()\"\n                ng-disabled=\"!vm.pageSigninPincode||!vm.pageSigninAccount\" aria-label=\"Continue in\">Sign in</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (0) -->\n          <div layout=\"column\" flex ng-if=\"vm.page=='create'\">\n            <div layout=\"row\" flex layout-align=\"center center\">\n              <md-input-container flex>\n                <label>User name</label>\n                <input ng-model=\"vm.pageCreateUserName\" required name=\"username\" maxlength=\"100\" input-append=\"@heatwallet.com\">\n              </md-input-container>\n              <md-input-container flex style=\"max-width:120px !important\">\n                <md-icon md-font-set=\"regular-font\">@heatwallet.com</md-icon>\n                <input style=\"visibility: hidden;\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Secret phrase</label>\n                <textarea rows=\"2\" flex ng-model=\"vm.pageCreateSecretPhrase\" readonly ng-trim=\"false\" id=\"create-new-textarea\"></textarea>\n                <!--copy to clipboard using clipboard.js, see https://www.npmjs.com/package/clipboard-->\n                <md-icon id=\"copy-secret\" data-clipboard-target=\"#create-new-textarea\" md-font-library=\"material-icons\" class=\"clickable-icon\">\n                  <md-tooltip md-direction=\"right\">Copy to clipboard</md-tooltip>content_copy\n                </md-icon>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Password (or Pin Code) (required)</label>\n                <input type=\"password\" ng-model=\"vm.pageCreatePincode\" required name=\"pincode\" maxlength=\"15\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-radio-group ng-model=\"vm.pageCreateNameType\">\n                <md-radio-button value=\"public\" class=\"md-primary\">\n                  Publicly searchable email account id\n                </md-radio-button>\n                <md-radio-button value=\"private\" class=\"md-primary\">\n                  Private email account id (sender must know it)\n                </md-radio-button>\n              </md-radio-group>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">Options</md-button>\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.generateNewSecretPhrase()\" aria-label=\"Other\">\n                Renew pass\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create1'\"\n                ng-disabled=\"!vm.pageCreateUserName||!vm.pageCreateSecretPhrase||!vm.isValidPincode(vm.pageCreatePincode)\"\n                aria-label=\"Continue\">Continue</md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <br>\n              <span class=\"account-preview\">{{vm.pageCreateAccount}}</span>\n              <br>\n              <span>BIP44 compatible = <b>{{vm.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n            </div>\n          </div>\n\n          <!-- CREATE page (1) -->\n          <div layout=\"column\" flex ng-if=\"vm.page.indexOf('create')!=-1\" ng-show=\"vm.page=='create1'\" layout-padding>\n            <div layout=\"column\" flex>\n              <p>Although we have absolutely nothing against robots, we still would like to know if you are one.</p>\n            </div>\n            <div layout=\"row\" flex layout-align=\"center center\">\n              <no-captcha ng-if=\"!vm.useExternalCaptcha\" g-recaptcha-response=\"vm.pageCreateRecaptchaResponse\" expired-callback=\"vm.recaptchaExpired()\"></no-captcha>\n              <md-button ng-if=\"vm.useExternalCaptcha\" ng-click=\"vm.doChallenge()\" class=\"md-raised md-primary\" ng-disabled=\"vm.pageCreateRecaptchaResponse\">Click here</md-button>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='create'\" aria-label=\"Back\">Back</md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.createAccount();vm.page='create2'\" ng-disabled=\"!vm.pageCreateRecaptchaResponse\"\n                aria-label=\"Continue\">Create Account</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (2) -->\n          <div layout=\"column\" flex ng-if=\"vm.page.indexOf('create')!=-1\" ng-show=\"vm.page=='create2'\">\n            <div layout=\"column\" flex layout-padding ng-show=\"vm.pageCreateLoading\">\n              <div layout=\"row\" layout-align=\"space-around\">\n                <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n              </div>\n              <span>Creating your account, making it extra special for you.</span>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.pageCreateError\">\n              <span>Something went wrong it seems</span>\n              <span>This is what we got back from our blockchain minions:</span>\n              <span><b>{{vm.pageCreateError}}</b></span>\n              <md-button class=\"md-raised md-primary\" ng-click=\"vm.page='create'\" aria-label=\"Back\">Try again</md-button>\n            </div>\n          </div>\n\n          <!-- CREATE page (3 - success page) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='createSuccess'\">\n            <div layout=\"column\" flex layout-align=\"start center\">\n              <h2>Congratulations, it worked!</h2>\n              <div>We advise you print or write down your HEAT secret passprase, if lost you will loose access to your HEAT.<br>\n              Please pick one or more methods to back up your passphrase listed below.</div>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button ng-click=\"vm.printPassphrase()\">\n                <md-icon md-font-library=\"material-icons\">print</md-icon>\n                &nbsp;&nbsp;Print\n              </md-button>\n              <md-button ng-click=\"vm.savePassphrase()\" ng-if=\"vm.isFileSaverSupported\">\n                <md-icon md-font-library=\"material-icons\">save</md-icon>\n                &nbsp;&nbsp;Save\n              </md-button>\n              <md-button ng-click=\"vm.showPassphrase()\">\n                <md-icon md-font-library=\"material-icons\">content_copy</md-icon>\n                &nbsp;&nbsp;Copy\n              </md-button>\n              <md-button ng-click=\"vm.showPassphrase=!vm.showPassphrase\">\n                <md-icon md-font-library=\"material-icons\">arrow_drop_down_circle</md-icon>\n                &nbsp;&nbsp;{{vm.showPassphrase?'Hide':'Reveal'}}\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.showPassphrase\">\n              <p>Passphrase for {{vm.pageCreateUserName}} ({{vm.pageCreateAccount}}):</p>\n              <p><code id=\"claim2-passphrase\">{{vm.pageCreateSecretPhrase}}</code></p>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-checkbox ng-model=\"vm.passphraseBackedUp\" aria-label=\"I have backed up my passphrase\">\n              I have safely backed up my passphrase\n              </md-checkbox>\n              <md-button class=\"md-raised md-primary\" ng-click=\"vm.createLocalAccount($event)\" ng-disabled=\"!vm.passphraseBackedUp\">Continue</md-button>\n            </div>\n          </div>\n\n          <!-- ADD page (choose add secret phrase or open wallet file) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='add'\">\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page=''\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='addSecret'\" aria-label=\"Add secret phrase\">\n                <md-tooltip md-direction=\"bottom\">Add single key through secret phrase</md-tooltip>\n                Secret Phrase\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.page='addWallet'\" aria-label=\"Open wallet file\">\n                <md-tooltip md-direction=\"bottom\">Load wallet file</md-tooltip>\n                Wallet File\n              </md-button>\n            </div>\n          </div>\n\n          <!-- ADD page (adds single secret phrase) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='addSecret'\">\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Secret phrase</label>\n                <textarea rows=\"2\" flex ng-model=\"vm.pageAddSecretPhrase\" ng-trim=\"false\" ng-change=\"vm.pageAddSecretPhraseChanged()\"></textarea>\n              </md-input-container>\n            </div>\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <label>Password (or Pin Code) (required)</label>\n                <input type=\"password\" ng-model=\"vm.pageAddPincode\" required name=\"pincode\" maxlength=\"5\">\n              </md-input-container>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddAddSecretPhrase()\" ng-disabled=\"!vm.pageAddSecretPhrase||!vm.pageAddPincode\" aria-label=\"Add\">\n                <md-tooltip md-direction=\"bottom\">Add and encrypt this secretphrase to your device</md-tooltip>\n                Add\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddLogin()\" ng-disabled=\"!vm.pageAddSecretPhrase\" aria-label=\"Sign in\">\n                <md-tooltip md-direction=\"bottom\">Sign in without storing your secretphrase</md-tooltip>\n                Sign in\n              </md-button>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\">\n              <br>\n              <span class=\"account-preview\">{{vm.pageAddCalculatedAccountId}}</span>\n              <span ng-show=\"vm.pageAddSecretPhraseHasHiddenChars\" class=\"account-preview\">\n                Secret phrase has hidden characters!&nbsp;<a href=\"#\" ng-click=\"vm.pageAddRemoveSecretPhraseHiddenChars()\">remove</a>\n              </span>\n              <br>\n              <span>BIP44 compatible = <b>{{vm.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n            </div>\n          </div>\n\n          <!-- ADD page (opens wallet file) -->\n          <div layout=\"column\" flex ng-show=\"vm.page=='addWallet'\">\n            <div layout=\"column\" flex>\n              <md-input-container flex>\n                <input type=\"file\" onchange=\"angular.element(this).scope().vm.pageAddFileInputChange(this.files)\">\n              </md-input-container>\n            </div>\n            <div layout=\"column\" layout-align=\"center center\" ng-show=\"vm.pageAddWalletInvalid\">\n              <p><b>Invalid wallet file</b></p>\n            </div>\n            <div layout=\"row\" layout-align=\"center center\">\n              <md-button class=\"md-warn md-raised\" ng-click=\"vm.page='add'\" aria-label=\"Back\">\n                <md-tooltip md-direction=\"bottom\">Go back one page</md-tooltip>\n                Back\n              </md-button>\n              <md-button class=\"md-primary md-raised\" ng-click=\"vm.pageAddWalletImportContinue()\" ng-disabled=\"!vm.pageAddWallet\" aria-label=\"Continue\">\n                <md-tooltip md-direction=\"bottom\">Click to open wallet explorer</md-tooltip>\n                Continue\n              </md-button>\n            </div>\n          </div>\n\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'user', '$location', 'heat', 'localKeyStore', 'secretGenerator', 'clipboard', '$mdToast', 'env', 'settings', 'walletFile', 'panel', 'lightwalletService'),
        __metadata("design:paramtypes", [Object, Function, UserService, Object, HeatService,
            LocalKeyStoreService,
            SecretGeneratorService,
            ClipboardService, Object, EnvService,
            SettingsService,
            WalletFileService,
            PanelService,
            LightwalletService])
    ], LoginComponent);
    return LoginComponent;
}());
var NewComponent = (function () {
    function NewComponent($scope, $q, heat, user, $timeout) {
        this.$scope = $scope;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        this.$timeout = $timeout;
        this.activated = false;
        this.checkAgain();
    }
    NewComponent.prototype.isExistingAccount = function () {
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalance(this.user.account, "0").then(function () {
            deferred.resolve(true);
        }).catch(function (error) {
            deferred.resolve(false);
        });
        return deferred.promise;
    };
    NewComponent.prototype.checkAgain = function () {
        var _this = this;
        this.isExistingAccount().then(function (activated) {
            if (activated) {
                _this.$scope.$evalAsync(function () {
                    _this.activated = true;
                });
            }
            else {
                _this.$timeout(2000, false).then(function () {
                    _this.checkAgain();
                });
            }
        });
    };
    NewComponent = __decorate([
        RouteConfig('/new'),
        Component({
            selector: 'new',
            styles: ["\n    new h2 {\n      font-size: 26px !important;\n    }\n    new .outer-container {\n      width: 100%;\n      max-width: 380px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-align=\"start center\">\n      <div layout=\"column\" layout-padding class=\"outer-container\">\n        <div layout=\"column\" flex layout-align=\"start center\">\n          <h2>Howdy new user</h2>\n          <p>To see your new account, please click on the home button on the horizontal menu bar above. Your payments section is empty until you receive new payments.</p>\n        </div>\n        <div layout=\"column\" flex layout-align=\"start center\" ng-show=\"!vm.activated\">\n          <p>Your account gets activated (and messages become visible) once your account is registered on the blockchain,\n  this will happen in the next block which is to be expected in the next 30 seconds.</p>\n          <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n          <p><b>Registering account on blockchain, please wait</b></p>\n        </div>\n        <div layout=\"column\" layout-align=\"space-around\" ng-show=\"vm.activated\">\n          <p><b>Your account is activated.</b></p>\n          <p>Check out your messages by clicking the messages button in the toolbar, there might be a message for you.</p>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'user', '$timeout'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            UserService, Function])
    ], NewComponent);
    return NewComponent;
}());
var ARDRCurrency = (function () {
    function ARDRCurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'ARDR';
        this.user = heat.$inject.get('user');
        this.homePath = "/ardor-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('ardorPendingTransactions');
        this.ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    ARDRCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.ardorBlockExplorerService.getBalance(this.address).then(function (data) {
            deferred.resolve(new Big(utils.convertToQNTf(data)).toFixed(8));
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    ARDRCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    ARDRCurrency.prototype.notifyBalanceChanged = function () {
    };
    ARDRCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendArdr($event).then(function (data) {
            var address = _this.user.account;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp, data.fullHash);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send ARDR Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    ARDRCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    ARDRCurrency.prototype.sendArdr = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
                var to = $scope['vm'].data.recipient;
                var amountNQT = utils.convertToNQT(String($scope['vm'].data.amountNQT));
                var feeNQT = utils.convertToNQT(String($scope['vm'].data.feeNQT));
                var recipientPublicKey;
                var txObject;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.secretPhrase);
                    txObject = "nxt?requestType=sendMoney&secretPhrase=" + user.secretPhrase + "&recipient=" + to + "&amountNQT=" + amountNQT + "&feeNQT=" + feeNQT + "&deadline=60&encryptedMessageData=" + encryptedNote.message + "&encryptedMessageNonce=" + encryptedNote.nonce + "&messageToEncryptIsText=true&encryptedMessageIsPrunable=true&chain=1";
                }
                else {
                    txObject = "nxt?requestType=sendMoney&secretPhrase=" + user.secretPhrase + "&recipient=" + to + "&amountNQT=" + amountNQT + "&feeNQT=" + feeNQT + "&deadline=60&chain=1";
                }
                $scope['vm'].disableOKBtn = true;
                ardorBlockExplorerService.sendTransactionWithSecret(txObject).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: " + data.txId);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            var defaultFee = '1.0';
            $scope['vm'].data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var ardorBlockExplorerService = heat.$inject.get('ardorBlockExplorerService');
                ardorBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(utils.convertToQNTf(info)).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " ARDR";
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
                ardorBlockExplorerService.getPublicKeyFromAddress($scope['vm'].data.recipient).then(function (publicKey) {
                    $scope['vm'].data.recipientPublicKey = publicKey;
                });
            }, 1000, false);
            $scope['vm'].recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send ARDR</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in ARDR</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in ARDR</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return ARDRCurrency;
}());
var BTCCurrency = (function () {
    function BTCCurrency(secretPhrase, address) {
        var _this = this;
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'BTC';
        this.invokeSendDialog = function ($event) {
            _this.sendBtc($event).then(function (data) {
                var address = _this.user.account;
                var privateKey = _this.user.secretPhrase;
                var publicKey = _this.user.publicKey;
                var encryptedMessage = heat.crypto.encryptMessage(data.message, publicKey, privateKey);
                var timestamp = new Date().getTime();
                _this.pendingTransactions.add(address, data.txId, timestamp);
                _this.bitcoinMessagesService.add(address, data.txId, encryptedMessage.data + ":" + encryptedMessage.nonce);
            }, function (err) {
                if (err) {
                    dialogs.alert($event, 'Send BTC Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
                }
            });
        };
        this.btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/bitcoin-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('bitcoinPendingTransactions');
        this.bitcoinMessagesService = heat.$inject.get('bitcoinMessagesService');
    }
    BTCCurrency.prototype.getBalance = function () {
        return this.btcBlockExplorerService.getBalance(this.address).then(function (balance) {
            var balanceUnconfirmed = balance / 100000000;
            return utils.commaFormat(new Big(balanceUnconfirmed + "").toFixed(8));
        });
    };
    BTCCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    BTCCurrency.prototype.notifyBalanceChanged = function () {
    };
    BTCCurrency.prototype.invokeSendToken = function ($event) {
    };
    BTCCurrency.prototype.sendBtc = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            var createTx = function (isForFeeEstimation) {
                if (isForFeeEstimation === void 0) { isForFeeEstimation = false; }
                var user = heat.$inject.get('user');
                var feeInSatoshi;
                var amountInSatoshi;
                var to;
                var addressPrivateKeyPair = { address: user.currency.address, privateKey: user.secretPhrase };
                if (!isForFeeEstimation) {
                    feeInSatoshi = ($scope['vm'].data.fee * 100000000).toFixed(0);
                    amountInSatoshi = ($scope['vm'].data.amount * 100000000).toFixed(0);
                    to = $scope['vm'].data.recipient;
                }
                else {
                    feeInSatoshi = $scope['vm'].data.fee ? ($scope['vm'].data.fee * 100000000).toFixed(0) : 0;
                    amountInSatoshi = $scope['vm'].data.amount ? ($scope['vm'].data.amount * 100000000).toFixed(0) : "0.0001";
                    to = $scope['vm'].data.recipient ? $scope['vm'].data.recipient : addressPrivateKeyPair.address;
                }
                var txObject = {
                    from: addressPrivateKeyPair.address,
                    to: to,
                    amount: parseInt(amountInSatoshi),
                    fee: Math.ceil(feeInSatoshi),
                    changeAddress: addressPrivateKeyPair.address,
                    privateKey: addressPrivateKeyPair.privateKey
                };
                return txObject;
            };
            $scope['vm'].okButtonClick = function ($event) {
                var bitcoreService = heat.$inject.get('bitcoreService');
                $scope['vm'].disableOKBtn = true;
                bitcoreService.sendBitcoins(createTx()).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        data.message = $scope['vm'].data.message;
                        dialogs.alert(event, 'Success', "TxId: " + data.txId);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err.message);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            $scope['vm'].data = {
                amount: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.00004540',
                message: '',
                userInputFee: false
            };
            var lookup = utils.debounce(function () {
                var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
                btcBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = (info / 100000000).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " BTC";
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            $scope['vm'].recipientChanged = function () {
                var bitcoreService = heat.$inject.get('bitcoreService');
                $scope['vm'].data.recipientInfo = '';
                lookup();
                $scope['vm'].data.txBytes = [];
                bitcoreService.signTransaction(createTx(true), true).then(function (rawTx) {
                    $scope['vm'].data.txBytes = converters.hexStringToByteArray(rawTx);
                    if (!$scope['vm'].data.userInputFee)
                        $scope['vm'].data.fee = $scope['vm'].data.txBytes.length * $scope['vm'].data.estimatedFee / 100000000;
                });
            };
            $scope['vm'].selectedItemChange = function (item) {
                $scope['vm'].value = $scope['vm'].selectedItem ? $scope['vm'].selectedItem.id : '';
                $scope['vm'].data.recipient = item.cryptoAddresses ? item.cryptoAddresses.find(function (i) { return i.name === 'BTC'; }).address : '';
                if ($scope['vm'].data.recipient && $scope['vm'].data.recipient !== '')
                    $scope['vm'].recipientChanged();
            };
            $scope['vm'].search = function () {
                var p = heat.$inject.get('p2pContactUtils');
                return p.lookupContact($scope['vm'].searchText.trim());
            };
            $scope['vm'].searchTextChange = function () {
                $scope['vm'].value = $scope['vm'].searchText;
                $scope['vm'].data.recipient = $scope['vm'].searchText;
            };
            $scope['vm'].amountChanged = function () {
                var bitcoreService = heat.$inject.get('bitcoreService');
                $scope['vm'].data.txBytes = [];
                bitcoreService.signTransaction(createTx(true), true).then(function (rawTx) {
                    $scope['vm'].data.txBytes = converters.hexStringToByteArray(rawTx);
                    if (!$scope['vm'].data.userInputFee)
                        $scope['vm'].data.fee = $scope['vm'].data.txBytes.length * $scope['vm'].data.estimatedFee / 100000000;
                });
            };
            $scope['vm'].feeChanged = function () {
                var bitcoreService = heat.$inject.get('bitcoreService');
                $scope['vm'].data.txBytes = [];
                bitcoreService.signTransaction(createTx(true), true).then(function (rawTx) {
                    $scope['vm'].data.txBytes = converters.hexStringToByteArray(rawTx);
                    $scope['vm'].data.estimatedFee = ($scope['vm'].data.fee / $scope['vm'].data.txBytes.length * 100000000).toFixed(0);
                    $scope['vm'].data.userInputFee = true;
                });
            };
            function getEstimatedFee() {
                var btcBlockExplorerService = heat.$inject.get('btcBlockExplorerService');
                btcBlockExplorerService.getEstimatedFee().then(function (data) {
                    if (!$scope['vm'].data.userInputFee)
                        $scope['vm'].data.estimatedFee = data;
                });
            }
            getEstimatedFee();
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send BTC</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n            <div flex layout=\"column\">\n                <md-autocomplete flex\n                  ng-required=\"true\"\n                  ng-readonly=\"false\"\n                  md-input-name=\"recipientBtcAddress\"\n                  md-floating-label=\"Recipient\"\n                  md-min-length=\"1\"\n                  md-items=\"item in vm.search(vm.searchText)\"\n                  md-item-text=\"item.publicName||item.id\"\n                  md-search-text=\"vm.searchText\"\n                  md-selected-item-change=\"vm.selectedItemChange(item)\"\n                  md-search-text-change=\"vm.searchTextChange()\"\n                  md-selected-item=\"vm.selectedItem\">\n                    <md-item-template>\n                      <div layout=\"row\" flex class=\"monospace-font\">\n                        <span>{{item.publicName||''}}</span>\n                        <span flex></span>\n                        <span>{{item.id}}</span>\n                      </div>\n                    </md-item-template>\n                </md-autocomplete>\n                <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n\n                <md-input-container flex >\n                  <label>Amount in BTC</label>\n                  <input ng-model=\"vm.data.amount\" ng-change=\"vm.amountChanged()\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in BTC</label>\n                  <input ng-model=\"vm.data.fee\" ng-keypress=\"vm.feeChanged($event)\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <md-button ng-click=\"0\" ng-disabled=\"true\" class=\"fee\" style=\"max-width:140px !important\">Fee/Byte {{vm.data.estimatedFee}} Sat</md-button>\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return BTCCurrency;
}());
var ETHCurrency = (function () {
    function ETHCurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'ETH';
        this.ethplorer = heat.$inject.get('ethplorer');
        this.user = heat.$inject.get('user');
        this.homePath = "/ethereum-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('ethereumPendingTransactions');
    }
    ETHCurrency.prototype.getBalance = function () {
        return this.ethplorer.getBalance(this.address).then(function (balance) {
            return utils.commaFormat(new Big(balance + "").toFixed(18));
        });
    };
    ETHCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return function () { };
    };
    ETHCurrency.prototype.notifyBalanceChanged = function () {
    };
    ETHCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendEther($event).then(function (data) {
            var address = _this.user.account;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txHash, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send Ether Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    ETHCurrency.prototype.invokeSendToken = function ($event) {
    };
    ETHCurrency.prototype.sendEther = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var web3 = heat.$inject.get('web3');
                var amountInWei = web3.web3.toWei($scope['vm'].data.amount.replace(',', ''), 'ether');
                var from = user.currency.address;
                var to = $scope['vm'].data.recipient;
                $scope['vm'].disableOKBtn = true;
                web3.sendEther(from, to, amountInWei).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxHash: " + data.txHash);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err.message);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            $scope['vm'].data = {
                amount: '',
                recipient: '',
                recipientInfo: '',
                fee: '0.000420'
            };
            var lookup = utils.debounce(function () {
                var ethplorer = heat.$inject.get('ethplorer');
                ethplorer.getAddressInfo($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = Number.parseFloat(info.ETH.balance).toFixed(18);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " ETH";
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            $scope['vm'].recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send Ether</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in ETH</label>\n                  <input ng-model=\"vm.data.amount\" required name=\"amount\">\n                </md-input-container>\n\n                <p>Fee: {{vm.data.fee}} ETH</p>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amount || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return ETHCurrency;
}());
var FIMKCurrency = (function () {
    function FIMKCurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'FIM';
        this.mofoSocketService = heat.$inject.get('mofoSocketService');
        this.user = heat.$inject.get('user');
        this.homePath = "/fimk-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('fimkPendingTransactions');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    FIMKCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.mofoSocketService.getAccount(this.address).then(function (info) {
            var balance = info.unconfirmedBalanceNQT ? parseInt(info.unconfirmedBalanceNQT) / 100000000 : 0;
            var formattedBalance = new Big(balance + "");
            deferred.resolve(new Big(formattedBalance).toFixed(8));
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    FIMKCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    FIMKCurrency.prototype.notifyBalanceChanged = function () {
    };
    FIMKCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendFim($event).then(function (data) {
            var address = _this.user.account;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send FIM Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    FIMKCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    FIMKCurrency.prototype.sendFim = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var mofoSocketService = heat.$inject.get('mofoSocketService');
                var to = $scope['vm'].data.recipient;
                var recipientPublicKey;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                var txObject;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.secretPhrase);
                    txObject = {
                        recipient: to,
                        amountNQT: utils.convertToNQT(String($scope['vm'].data.amountNQT)),
                        feeNQT: utils.convertToNQT(String($scope['vm'].data.feeNQT)),
                        publicKey: user.publicKey,
                        deadline: '1440',
                        requestType: 'sendMoney',
                        encryptedMessageData: encryptedNote.message,
                        encryptedMessageNonce: encryptedNote.nonce,
                        messageToEncryptIsText: 'true'
                    };
                }
                else {
                    txObject = {
                        recipient: to,
                        amountNQT: utils.convertToNQT(String($scope['vm'].data.amountNQT)),
                        feeNQT: utils.convertToNQT(String($scope['vm'].data.feeNQT)),
                        publicKey: user.publicKey,
                        deadline: '1440',
                        requestType: 'sendMoney'
                    };
                }
                $scope['vm'].disableOKBtn = true;
                mofoSocketService.sendFim(txObject).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: " + data.txId);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            var defaultFee = '0.1';
            $scope['vm'].data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var mofoSocketService = heat.$inject.get('mofoSocketService');
                var heatService = heat.$inject.get('heat');
                mofoSocketService.getAccount($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var unconfirmedBalanceNQT = parseInt(info.unconfirmedBalanceNQT) / 100000000;
                        var formattedBalance = new Big(unconfirmedBalanceNQT + "");
                        var balance = new Big(formattedBalance).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " FIM";
                        $scope['vm'].data.recipientPublicKey = info.publicKey;
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            $scope['vm'].recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                $scope['vm'].data.recipientPublicKey = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send FIM</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in FIM</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in FIM</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return FIMKCurrency;
}());
var HEATCurrency = (function () {
    function HEATCurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'HEAT';
        this.heat = heat.$inject.get('heat');
        this.sendmoney = heat.$inject.get('sendmoney');
        this.homePath = "/explorer-account/" + this.address + "/transactions";
    }
    HEATCurrency.prototype.getBalance = function () {
        return this.heat.api.getAccountBalanceVirtual(this.address, "0", "0", 1).then(function (balance) {
            var formatted = utils.formatQNT(balance.virtualBalance, 8);
            return formatted;
        });
    };
    HEATCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return this.heat.subscriber.balanceChanged({ account: this.address }, handler);
    };
    HEATCurrency.prototype.notifyBalanceChanged = function () {
    };
    HEATCurrency.prototype.invokeSendDialog = function ($event) {
        this.sendmoney.dialog($event).show();
    };
    HEATCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    return HEATCurrency;
}());
var IOTACurrency = (function () {
    function IOTACurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'IOTA';
        this.iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
        this.user = heat.$inject.get('user');
        this.homePath = "/iota-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('iotaPendingTransactions');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    IOTACurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.iotaBlockExplorerService.getAccountInfo(this.secretPhrase).then(function (info) {
            deferred.resolve(info.balance.toString());
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    IOTACurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    IOTACurrency.prototype.notifyBalanceChanged = function () {
    };
    IOTACurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendIota($event).then(function (data) {
            var address = _this.user.account;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data[0].hash, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send IOTA Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    IOTACurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    IOTACurrency.prototype.sendIota = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                var user = heat.$inject.get('user');
                $scope['vm'].disableOKBtn = true;
                var transfers = [{
                        address: $scope['vm'].data.recipient,
                        value: parseInt($scope['vm'].data.value)
                    }];
                iotaBlockExplorerService.sendIota(user.secretPhrase, transfers).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "Bundle: " + data[0].hash);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            $scope['vm'].data = {
                value: '',
                recipient: '',
                recipientInfo: '',
                addressReuse: true
            };
            var lookup = utils.debounce(function () {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                iotaBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(info).toFixed(0);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " IOTA";
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
            }, 1000, false);
            var checkAddressValidity = function (address) {
                var iotaBlockExplorerService = heat.$inject.get('iotaBlockExplorerService');
                iotaBlockExplorerService.checkAddressReuse(address).then(function (reuse) { return $scope['vm'].data.addressReuse = reuse; });
            };
            $scope['vm'].recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
                checkAddressValidity($scope['vm'].data.recipient);
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send IOTA</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in IOTA</label>\n                  <input ng-model=\"vm.data.value\" required name=\"amount\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.value || vm.disableOKBtn || vm.data.addressReuse\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return IOTACurrency;
}());
var NXTCurrency = (function () {
    function NXTCurrency(secretPhrase, address) {
        this.secretPhrase = secretPhrase;
        this.address = address;
        this.symbol = 'NXT';
        this.user = heat.$inject.get('user');
        this.homePath = "/nxt-account/" + this.address;
        this.pendingTransactions = heat.$inject.get('nxtPendingTransactions');
        this.nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
        this.$rootScope = heat.$inject.get('$rootScope');
        this.$q = heat.$inject.get('$q');
    }
    NXTCurrency.prototype.getBalance = function () {
        var deferred = this.$q.defer();
        this.nxtBlockExplorerService.getAccount(this.address).then(function (data) {
            deferred.resolve(new Big(utils.convertToQNTf(data.balanceNQT)).toFixed(8));
        }, function (err) {
            deferred.reject();
        });
        return deferred.promise;
    };
    NXTCurrency.prototype.subscribeBalanceChanged = function (handler) {
        return;
    };
    NXTCurrency.prototype.notifyBalanceChanged = function () {
    };
    NXTCurrency.prototype.invokeSendDialog = function ($event) {
        var _this = this;
        this.sendNxt($event).then(function (data) {
            var address = _this.user.account;
            var timestamp = new Date().getTime();
            _this.pendingTransactions.add(address, data.txId, timestamp);
        }, function (err) {
            if (err) {
                dialogs.alert($event, 'Send NXT Error', 'There was an error sending this transaction: ' + JSON.stringify(err));
            }
        });
    };
    NXTCurrency.prototype.invokeSendToken = function ($event) {
        return;
    };
    NXTCurrency.prototype.sendNxt = function ($event) {
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var user = heat.$inject.get('user');
                var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
                var to = $scope['vm'].data.recipient;
                var amountNQT = utils.convertToNQT(String($scope['vm'].data.amountNQT));
                var feeNQT = utils.convertToNQT(String($scope['vm'].data.feeNQT));
                var recipientPublicKey;
                var txObject;
                if ($scope['vm'].data.recipientPublicKey) {
                    recipientPublicKey = converters.hexStringToByteArray($scope['vm'].data.recipientPublicKey);
                }
                var userMessage = $scope['vm'].data.message;
                if (userMessage && userMessage != '' && recipientPublicKey) {
                    var options = {
                        "publicKey": recipientPublicKey
                    };
                    var encryptedNote = heat.crypto.encryptNote(userMessage, options, user.secretPhrase);
                    txObject = "nxt?requestType=sendMoney&publicKey=" + user.publicKey + "&recipient=" + to + "&amountNQT=" + amountNQT + "&feeNQT=" + feeNQT + "&deadline=60&encryptedMessageData=" + encryptedNote.message + "&encryptedMessageNonce=" + encryptedNote.nonce + "&messageToEncryptIsText=true";
                }
                else {
                    txObject = "nxt?requestType=sendMoney&publicKey=" + user.publicKey + "&recipient=" + to + "&amountNQT=" + amountNQT + "&feeNQT=" + feeNQT + "&deadline=60";
                }
                $scope['vm'].disableOKBtn = true;
                nxtBlockExplorerService.sendNxt(txObject).then(function (data) {
                    $mdDialog.hide(data).then(function () {
                        dialogs.alert(event, 'Success', "TxId: " + data.txId);
                    });
                }, function (err) {
                    $mdDialog.hide(null).then(function () {
                        dialogs.alert(event, 'Error', err);
                    });
                });
            };
            $scope['vm'].disableOKBtn = false;
            var defaultFee = '1.0';
            $scope['vm'].data = {
                amountNQT: '',
                recipient: '',
                recipientInfo: '',
                feeNQT: defaultFee,
                message: ''
            };
            var lookup = utils.debounce(function () {
                var nxtBlockExplorerService = heat.$inject.get('nxtBlockExplorerService');
                nxtBlockExplorerService.getBalance($scope['vm'].data.recipient).then(function (info) {
                    $scope.$evalAsync(function () {
                        var balance = new Big(utils.convertToQNTf(info)).toFixed(8);
                        $scope['vm'].data.recipientInfo = "Balance: " + balance + " NXT";
                    });
                }, function (error) {
                    $scope.$evalAsync(function () {
                        $scope['vm'].data.recipientInfo = error.message || 'Invalid';
                    });
                });
                nxtBlockExplorerService.getPublicKeyFromAddress($scope['vm'].data.recipient).then(function (publicKey) {
                    $scope['vm'].data.recipientPublicKey = publicKey;
                });
            }, 1000, false);
            $scope['vm'].recipientChanged = function () {
                $scope['vm'].data.recipientInfo = '';
                lookup();
            };
        }
        var $q = heat.$inject.get('$q');
        var $mdDialog = heat.$inject.get('$mdDialog');
        var deferred = $q.defer();
        $mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Send NXT</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n\n                <md-input-container flex >\n                  <label>Recipient</label>\n                  <input ng-model=\"vm.data.recipient\" ng-change=\"vm.recipientChanged()\" required name=\"recipient\">\n                  <span ng-if=\"vm.data.recipientInfo\">{{vm.data.recipientInfo}}</span>\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Amount in NXT</label>\n                  <input ng-model=\"vm.data.amountNQT\" required name=\"amount\">\n                </md-input-container>\n\n                <md-input-container flex >\n                  <label>Message</label>\n                  <input ng-model=\"vm.data.message\" name=\"message\">\n                </md-input-container>\n\n                <md-input-container flex>\n                  <label>Fee in NXT</label>\n                  <input ng-model=\"vm.data.feeNQT\" required name=\"fee\">\n                </md-input-container>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.recipient || !vm.data.amountNQT || vm.disableOKBtn\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    return NXTCurrency;
}());
var HeatAPI = (function () {
    function HeatAPI(heat, user, $q) {
        this.heat = heat;
        this.user = user;
        this.$q = $q;
    }
    HeatAPI.prototype.registerAccountName = function (publicKey, captcha, name, isprivate, signature) {
        return this.heat.get("/register/now/" + publicKey + "/" + captcha + "/" + name + "/" + isprivate + "/" + signature, 'value');
    };
    HeatAPI.prototype.getBlockchainStatus = function () {
        return this.heat.get('/blockchain/status');
    };
    HeatAPI.prototype.getServerHealth = function (host, port) {
        if (!host)
            return this.heat.get('/tools/telemetry/health');
        return this.heat.getRaw(host, port, '/tools/telemetry/health');
    };
    HeatAPI.prototype.getBlocks = function (from, to) {
        return this.heat.get("/blockchain/blocks/" + from + "/" + to + "/null");
    };
    HeatAPI.prototype.getBlock = function (numericId, includeTransactions) {
        if (includeTransactions === void 0) { includeTransactions = true; }
        return this.heat.get("/blockchain/block/" + numericId + "/" + includeTransactions);
    };
    HeatAPI.prototype.getBlockAtHeight = function (height, includeTransactions) {
        return this.heat.get("/blockchain/block/height/" + height + "/" + includeTransactions);
    };
    HeatAPI.prototype.getAccountBlocks = function (account, from, to) {
        return this.heat.get("/blockchain/blocks/account/" + account + "/" + from + "/" + to + "/null");
    };
    HeatAPI.prototype.getAccountBlocksCount = function (account) {
        return this.heat.get("/blockchain/blocks/account/count/" + account, "count");
    };
    HeatAPI.prototype.getPublicKey = function (account) {
        var deferred = this.$q.defer();
        this.heat.get("/account/publickey/" + account, "value").then(function (publicKey) {
            var test = heat.crypto.getAccountIdFromPublicKey(publicKey);
            if (test != account) {
                console.log("Public key returned from server does not match account");
                deferred.reject();
            }
            else {
                deferred.resolve(publicKey);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    HeatAPI.prototype.getPublicKeyOrEmptyString = function (account) {
        var deferred = this.$q.defer();
        this.heat.get("/account/publickey/" + account, "value").then(function (publicKey) {
            var test = heat.crypto.getAccountIdFromPublicKey(publicKey);
            if (test != account) {
                console.log("Public key returned from server does not match account");
                deferred.reject();
            }
            else {
                deferred.resolve(publicKey);
            }
        }, function (error) {
            if ((error.errorDescription || "").toLowerCase() == "unknown publickey") {
                deferred.resolve("");
            }
            else {
                deferred.reject();
            }
        });
        return deferred.promise;
    };
    HeatAPI.prototype.createTransaction = function (input) {
        console.log("CreateTransaction", input);
        var arg = { value: JSON.stringify(input) };
        return this.heat.post('/tx/create', arg);
    };
    HeatAPI.prototype.broadcast = function (param) {
        var arg = {};
        if (angular.isDefined(param.transactionJSON)) {
            arg['transactionJSON'] = JSON.stringify(param.transactionJSON);
        }
        if (angular.isDefined(param.transactionBytes)) {
            arg['transactionBytes'] = param.transactionBytes;
        }
        return this.heat.post('/tx/broadcast', arg);
    };
    HeatAPI.prototype.getAllAssetProtocol1 = function (from, to) {
        return this.heat.get("/exchange/assets/protocol1/" + from + "/" + to);
    };
    HeatAPI.prototype.getAssetProtocol1 = function (symbol) {
        return this.heat.get("/exchange/asset/protocol1/" + symbol);
    };
    HeatAPI.prototype.getAsset = function (asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/exchange/asset/properties/" + asset + "/" + propertiesAccount + "/" + propertiesProtocol);
    };
    HeatAPI.prototype.getAssetCertification = function (asset, certifierAccount) {
        return this.heat.get("/exchange/asset/certification/" + asset + "/" + certifierAccount);
    };
    HeatAPI.prototype.getAssets = function (propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/assets/" + propertiesAccount + "/" + propertiesProtocol + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAssetProperties = function (asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/exchange/asset/properties/" + asset + "/" + propertiesAccount + "/" + propertiesProtocol);
    };
    HeatAPI.prototype.getAccountPairOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/" + account + "/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAccountPairOrdersCount = function (account, currency, asset) {
        return this.heat.get("/order/account/pair/count/" + account + "/" + currency + "/" + asset, "count");
    };
    HeatAPI.prototype.getAccountAllOrders = function (account, from, to) {
        return this.heat.get("/order/account/all/" + account + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAccountAllOrdersCount = function (account) {
        return this.heat.get("/order/account/all/count/" + account, "count");
    };
    HeatAPI.prototype.getAskOrders = function (currency, asset, from, to) {
        return this.heat.get("/order/pair/asks/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAskOrdersCount = function (currency, asset) {
        return this.heat.get("/order/pair/asks/count/" + currency + "/" + asset, "count");
    };
    HeatAPI.prototype.getBidOrders = function (currency, asset, from, to) {
        return this.heat.get("/order/pair/bids/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getBidOrdersCount = function (currency, asset) {
        return this.heat.get("/order/pair/bids/count/" + currency + "/" + asset, "count");
    };
    HeatAPI.prototype.getAllAskOrders = function (from, to) {
        return this.heat.get("/order/asks/" + from + "/" + to);
    };
    HeatAPI.prototype.getAllBidOrders = function (from, to) {
        return this.heat.get("/order/bids/" + from + "/" + to);
    };
    HeatAPI.prototype.getAccountAskOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/asks/" + account + "/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAccountBidOrders = function (account, currency, asset, from, to) {
        return this.heat.get("/order/account/pair/bids/" + account + "/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getTrades = function (currency, asset, from, to) {
        return this.heat.get("/trade/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getTradesCount = function (currency, asset) {
        return this.heat.get("/trade/count/" + currency + "/" + asset, "count");
    };
    HeatAPI.prototype.getAllTrades = function (from, to) {
        return this.heat.get("/trade/all/" + from + "/" + to);
    };
    HeatAPI.prototype.getAllAccountTrades = function (account, propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/trade/account/" + account + "/" + propertiesAccount + "/" + propertiesProtocol + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAllAccountTradesCount = function (account) {
        return this.heat.get("/trade/account/count/" + account, "count");
    };
    HeatAPI.prototype.getAccountTrades = function (account, currency, asset, from, to) {
        return this.heat.get("/trade/account/pair/" + account + "/" + currency + "/" + asset + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getAccountTradesCount = function (account, currency, asset) {
        return this.heat.get("/trade/account/pair/count/" + account + "/" + currency + "/" + asset, "count");
    };
    HeatAPI.prototype.getAccountBalance = function (account, asset) {
        return this.heat.get("/account/balance/" + account + "/" + asset);
    };
    HeatAPI.prototype.getAccountBalanceVirtual = function (account, asset, propertiesAccount, propertiesProtocol) {
        return this.heat.get("/account/balance/virtual/" + account + "/" + asset + "/" + propertiesAccount + "/" + propertiesProtocol);
    };
    HeatAPI.prototype.getMarketsAll = function (sort, asc, propertiesAccountId, propertiesProtocol, from, to) {
        return this.heat.get("/exchange/markets/all/" + sort + "/" + asc + "/" + propertiesAccountId + "/" + propertiesProtocol + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getMarkets = function (currency, sort, asc, propertiesAccountId, propertiesProtocol, from, to) {
        return this.heat.get("/exchange/markets/" + currency + "/" + sort + "/" + asc + "/" + propertiesAccountId + "/" + propertiesProtocol + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getMarket = function (currency, asset, propertiesAccountId, propertiesProtocol) {
        return this.heat.get("/exchange/market/" + currency + "/" + asset + "/" + propertiesAccountId + "/" + propertiesProtocol);
    };
    HeatAPI.prototype.getAccountBalances = function (account, propertiesAccount, propertiesProtocol, from, to) {
        return this.heat.get("/account/balances/" + account + "/" + propertiesAccount + "/" + propertiesProtocol + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getPayments = function (account, currency, sort, asc, from, to) {
        return this.heat.get("/account/payments/" + account + "/" + currency + "/" + sort + "/" + asc + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getPaymentsCount = function (account, currency) {
        return this.heat.get("/account/payments/count/" + account + "/" + currency, "count");
    };
    HeatAPI.prototype.getMessagingContactMessagesCount = function (accountA, accountB) {
        return this.heat.get("/messages/contact/count/" + accountA + "/" + accountB, "count");
    };
    HeatAPI.prototype.getMessagingContactMessages = function (accountA, accountB, from, to) {
        return this.heat.get("/messages/contact/" + accountA + "/" + accountB + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getMessagingContacts = function (account, from, to) {
        return this.heat.get("/messages/latest/" + account + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getOHLCChartData = function (currency, asset, window) {
        return this.heat.get("/exchange/chartdata/" + currency + "/" + asset + "/" + window);
    };
    HeatAPI.prototype.getMiningInfo = function (secretPhrase) {
        return this.heat.post('/mining/info?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.startMining = function (secretPhrase) {
        return this.heat.post('/mining/start?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.stopMining = function (secretPhrase) {
        return this.heat.post('/mining/stop?api_key=secret', { secretPhrase: secretPhrase }, false, null, true);
    };
    HeatAPI.prototype.getAccountByNumericId = function (numericId) {
        return this.heat.get("/account/find/" + numericId);
    };
    HeatAPI.prototype.getTransaction = function (transaction) {
        return this.heat.get("/blockchain/transaction/" + transaction);
    };
    HeatAPI.prototype.getTransactionsForAccount = function (account, from, to) {
        return this.heat.get("/blockchain/transactions/account/" + account + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getTransactionsForAccountCount = function (account) {
        return this.heat.get("/blockchain/transactions/account/count/" + account, "count");
    };
    HeatAPI.prototype.getTransactionsForBlock = function (block, from, to) {
        return this.heat.get("/blockchain/transactions/block/" + block + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getTransactionsForBlockCount = function (block) {
        return this.heat.get("/blockchain/transactions/block/count/" + block, "count");
    };
    HeatAPI.prototype.getTransactionsFromTo = function (sender, recipient, from, to) {
        return this.heat.get("/blockchain/transactions/list/" + sender + "/" + recipient + "/" + from + "/" + to);
    };
    HeatAPI.prototype.getTransactionsForAll = function (from, to) {
        return this.heat.get("/blockchain/transactions/all/" + from + "/" + to);
    };
    HeatAPI.prototype.getTransactionsForAllCount = function () {
        return this.heat.get("/blockchain/transactions/all/count", "count");
    };
    HeatAPI.prototype.searchAccounts = function (query, from, to) {
        return this.heat.get("/search/accounts/" + query + "/" + from + "/" + to);
    };
    HeatAPI.prototype.searchAccountsCount = function (query) {
        return this.heat.get("/search/accounts/count/" + query, "count");
    };
    HeatAPI.prototype.searchPublicNames = function (query, from, to) {
        return this.heat.get("/account/search/0/" + query + "/" + from + "/" + to);
    };
    HeatAPI.prototype.rewardsAccount = function (account) {
        return this.heat.get("/mining/rewards/account/" + account);
    };
    HeatAPI.prototype.rewardsList = function (from, to) {
        return this.heat.get("/mining/rewards/list/" + from + "/" + to);
    };
    HeatAPI.prototype.rewardsListCount = function () {
        return this.heat.get('/mining/rewards/list/count', 'count');
    };
    HeatAPI.prototype.getKeystoreEntryCountByAccount = function (account) {
        return this.heat.get("/keystore/count/" + account, 'count');
    };
    HeatAPI.prototype.getKeystoreAccountEntry = function (account, key) {
        return this.heat.get("/keystore/get/" + account + "/" + key);
    };
    HeatAPI.prototype.listKeystoreAccountEntries = function (account, from, to) {
        return this.heat.get("/keystore/list/" + account + "/" + from + "/" + to);
    };
    HeatAPI.prototype.saveKeystoreEntry = function (key, value, secretPhrase) {
        return this.heat.post("/keystore/put", { key: key, value: value, fee: 1000000, deadline: 1440, secretPhrase: secretPhrase });
    };
    HeatAPI.fee = {
        standard: utils.convertToQNT('0.01'),
        assetIssue: utils.convertToQNT('500.00'),
        assetIssueMore: utils.convertToQNT('0.01'),
        whitelistMarket: utils.convertToQNT('10.00'),
        registerInternetAddressFee: utils.convertToQNT('100.00')
    };
    return HeatAPI;
}());
var ServerEngineError = (function () {
    function ServerEngineError(data) {
        this.data = data;
        if (angular.isObject(data)) {
            this.description = data['errorDescription'] || data['error'];
            this.code = data['errorCode'] || -1;
        }
        else {
            this.description = 'misc error';
            this.code = 99;
        }
    }
    return ServerEngineError;
}());
var InternalServerTimeoutError = (function (_super) {
    __extends(InternalServerTimeoutError, _super);
    function InternalServerTimeoutError() {
        return _super.call(this, { error: 'Internal timeout' }) || this;
    }
    return InternalServerTimeoutError;
}(ServerEngineError));
var HeatService = (function () {
    function HeatService($q, $http, settings, user, $timeout, env) {
        this.$q = $q;
        this.$http = $http;
        this.settings = settings;
        this.user = user;
        this.$timeout = $timeout;
        this.env = env;
        this.api = new HeatAPI(this, this.user, this.$q);
        this.subscriber = this.createSubscriber(this.settings.get(SettingsService.HEAT_WEBSOCKET));
    }
    HeatService.prototype.createSubscriber = function (url) {
        return new HeatSubscriber(url, this.$q, this.$timeout);
    };
    HeatService.prototype.resetSubscriber = function () {
        this.subscriber.reset(this.settings.get(SettingsService.HEAT_WEBSOCKET));
    };
    HeatService.prototype.getAuthData = function () {
        var timestamp = Date.now();
        var baseMessage = this.user.account + timestamp;
        var message = converters.stringToHexString(baseMessage);
        var secret = converters.stringToHexString(this.user.secretPhrase);
        var signature = heat.crypto.signBytes(message, secret);
        return {
            auth: {
                accountRS: this.user.account,
                timestamp: timestamp,
                signature: signature,
                publicKey: this.user.publicKey
            }
        };
    };
    HeatService.prototype.get = function (route, returns) {
        return this.getRaw(this.settings.get(SettingsService.HEAT_HOST), this.settings.get(SettingsService.HEAT_PORT), route, returns);
    };
    HeatService.prototype.getRaw = function (host, port, route, returns) {
        var _this = this;
        route = "api/v1" + route;
        var deferred = this.$q.defer();
        if (this.env.type == EnvType.BROWSER) {
            this.browserHttpGet([host, ':', port, '/', route].join(''), { headers: { 'Content-Type': 'application/json' } }, function (response) {
                _this.logResponse(route, null, response);
                var data = angular.isString(returns) ? response.data[returns] : response.data;
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, null, response);
                deferred.reject(new ServerEngineError(response.data));
            });
        }
        else if (this.env.type == EnvType.NODEJS) {
            var isHttps = host.indexOf('https://') == 0;
            this.nodeHttpGet(isHttps, host.replace(/^(\w+:\/\/)/, ''), port, '/' + route, function (response) {
                _this.logResponse(route, null, response);
                var data = angular.isString(returns) ? response[returns] : response;
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, null, response);
                deferred.reject(new ServerEngineError(response));
            });
        }
        return deferred.promise;
    };
    HeatService.prototype.browserHttpGet = function (url, config, onSuccess, onFailure) {
        this.$http.get(url, config).then(function (response) {
            if (angular.isDefined(response.data.errorDescription))
                onFailure(response);
            else
                onSuccess(response);
        }, function (response) { onFailure(response); });
    };
    HeatService.prototype.nodeHttpGet = function (isHttps, hostname, port, path, onSuccess, onFailure) {
        var options = {
            hostname: hostname, port: port, path: path, method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        };
        var http = require(isHttps ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) { body.push(chunk); });
            res.on('end', function () {
                var response = JSON.parse(body.join(''));
                if (angular.isDefined(response.errorDescription))
                    onFailure(response);
                else
                    onSuccess(response);
            });
        });
        req.on('error', function (e) { onFailure(e); });
        req.end();
    };
    HeatService.prototype.post = function (route, request, withAuth, returns, localHostOnly) {
        var host = localHostOnly ? this.settings.get(SettingsService.HEAT_HOST_LOCAL) : this.settings.get(SettingsService.HEAT_HOST);
        var port = localHostOnly ? this.settings.get(SettingsService.HEAT_PORT_LOCAL) : this.settings.get(SettingsService.HEAT_PORT);
        return this.postRaw(host, port, route, request, withAuth, returns, localHostOnly);
    };
    HeatService.prototype.postRaw = function (host, port, route, request, withAuth, returns, localHostOnly) {
        var _this = this;
        route = "api/v1" + route;
        var deferred = this.$q.defer();
        var req = request || {};
        if (withAuth) {
            req = angular.extend(req, this.getAuthData());
        }
        if (this.env.type == EnvType.BROWSER) {
            var address = [host, ':', port, '/', route].join('');
            if (localHostOnly) {
                if (address.indexOf('http://localhost') != 0) {
                    deferred.reject(new ServerEngineError({
                        errorDescription: "Operation allowed to localhost only! " + address + " is not allowed",
                        errorCode: 10
                    }));
                }
            }
            this.browserHttpPost(address, req, function (response) {
                _this.logResponse(route, request, response);
                var data = angular.isString(returns) ? response.data[returns] : response.data;
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, request, response);
                deferred.reject(new ServerEngineError(response.data));
            });
        }
        else if (this.env.type == EnvType.NODEJS) {
            var address = host.replace(/^(\w+:\/\/)/, '');
            if (localHostOnly) {
                if (address.indexOf('localhost') != 0) {
                    deferred.reject(new ServerEngineError({
                        errorDescription: "Operation allowed to localhost only " + address + " is not allowed",
                        errorCode: 10
                    }));
                }
            }
            var isHttps = host.indexOf('https://') == 0;
            this.nodeHttpPost(isHttps, address, port, '/' + route, req, function (response) {
                _this.logResponse(route, request, response);
                var data = angular.isString(returns) ? response.data[returns] : response.data;
                deferred.resolve(data);
            }, function (response) {
                _this.logErrorResponse(route, request, response);
                deferred.reject(new ServerEngineError(response.data));
            });
        }
        return deferred.promise;
    };
    HeatService.prototype.browserHttpPost = function (url, request, onSuccess, onFailure) {
        this.$http({
            method: 'POST',
            url: url,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            transformRequest: function (obj) {
                var str = [];
                for (var p in obj)
                    str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                return str.join("&");
            },
            data: request
        }).then(function (response) {
            if (angular.isDefined(response.data.errorDescription))
                onFailure(response);
            else
                onSuccess(response);
        }, function (response) { onFailure(response); });
    };
    HeatService.prototype.nodeHttpPost = function (isHttps, hostname, port, path, request, onSuccess, onFailure) {
        var querystring = require('querystring');
        var body = querystring.stringify(request);
        var options = {
            hostname: hostname, port: port, path: path, method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                "Content-Length": body.length
            }
        };
        var http = require(isHttps ? 'https' : 'http');
        var req = http.request(options, function (res) {
            res.setEncoding('utf8');
            var body = [];
            res.on('data', function (chunk) { body.push(chunk); });
            res.on('end', function () {
                var response = { data: JSON.parse(body.join('')) };
                if (angular.isDefined(response.data.errorDescription))
                    onFailure(response);
                else
                    onSuccess(response);
            });
        });
        req.on('error', function (e) { onFailure(e); });
        req.write(body);
        req.end();
    };
    HeatService.prototype.logResponse = function (route, request, response) {
        if (this.settings.get(SettingsService.LOG_HEAT_ALL)) {
            console.log("HEAT [" + route + "]", {
                request: request,
                response: response
            });
        }
    };
    HeatService.prototype.logErrorResponse = function (route, request, response) {
        if (this.settings.get(SettingsService.LOG_HEAT_ERRORS)) {
            console.error("HEAT [" + route + "]", {
                request: request,
                response: response
            });
        }
    };
    HeatService.prototype.mock = function (data) {
        var deferred = this.$q.defer();
        deferred.resolve(data);
        return deferred.promise;
    };
    HeatService.prototype.getHeatMessageContents = function (message) {
        try {
            if (message.messageIsEncrypted || message.messageIsEncryptedToSelf) {
                var byteArray = converters.hexStringToByteArray(message.messageBytes);
                var nonce = converters.byteArrayToHexString(byteArray.slice(0, 32));
                var data = converters.byteArrayToHexString(byteArray.slice(32));
                var secretPhrase = this.user.key ? this.user.key.secretPhrase : this.user.secretPhrase;
                var account = this.user.key ? this.user.key.account : this.user.account;
                if (message.recipient == account) {
                    return heat.crypto.decryptMessage(data, nonce, message.senderPublicKey, secretPhrase);
                }
                else if (message.sender == account) {
                    return heat.crypto.decryptMessage(data, nonce, message.recipientPublicKey, secretPhrase);
                }
            }
            else if (message.messageIsText) {
                return converters.hexStringToString(message.messageBytes);
            }
            else {
                return message.messageBytes ? '[BINARY] ' + message.messageBytes : '';
            }
        }
        catch (e) {
            console.log('Message parse exception', message, e);
            return '** could not parse message bytes **';
        }
    };
    HeatService = __decorate([
        Service('heat'),
        Inject('$q', '$http', 'settings', 'user', '$timeout', 'env'),
        __metadata("design:paramtypes", [Function, Function, SettingsService,
            UserService, Function, EnvService])
    ], HeatService);
    return HeatService;
}());
var HeatSubscriber = (function () {
    function HeatSubscriber(url, $q, $timeout) {
        this.url = url;
        this.$q = $q;
        this.$timeout = $timeout;
        this.RETRY_SYNC_DELAY = 2.5 * 1000;
        this.BLOCK_PUSHED = "1";
        this.BLOCK_POPPED = "2";
        this.BALANCE_CHANGED = "3";
        this.ORDER = "4";
        this.TRADE = "5";
        this.MESSAGE = "6";
        this.UNCONFIRMED_TRANSACTION = "7";
        this.MICROSERVICE = "8";
        this.connectedSocketPromise = null;
        this.subscribeTopics = [];
        this.unsubscribeTopics = [];
        this.needReset = false;
    }
    HeatSubscriber.prototype.blockPushed = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BLOCK_PUSHED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.blockPopped = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BLOCK_POPPED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.balanceChanged = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.BALANCE_CHANGED, filter), callback, $scope);
    };
    HeatSubscriber.prototype.order = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.ORDER, filter), callback, $scope);
    };
    HeatSubscriber.prototype.trade = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.TRADE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.message = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.MESSAGE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.unconfirmedTransaction = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.UNCONFIRMED_TRANSACTION, filter), callback, $scope);
    };
    HeatSubscriber.prototype.microservice = function (filter, callback, $scope) {
        return this.subscribe(new HeatSubscriberTopic(this.MICROSERVICE, filter), callback, $scope);
    };
    HeatSubscriber.prototype.reset = function (url) {
        this.url = url;
        this.needReset = true;
    };
    HeatSubscriber.prototype.subscribe = function (newTopic, callback, $scope) {
        var topic = this.findExistingOrAddNewTopic(newTopic);
        topic.addListener(callback);
        var unsubscribe = this.createUnsubscribeFunction(topic, callback);
        if (angular.isDefined($scope)) {
            $scope.$on('$destroy', function () { unsubscribe(); });
        }
        this.syncTopicSubscriptions();
        return unsubscribe;
    };
    HeatSubscriber.prototype.findExistingOrAddNewTopic = function (topic) {
        for (var i = 0; i < this.subscribeTopics.length; i++) {
            if (this.subscribeTopics[i].equals(topic)) {
                return this.subscribeTopics[i];
            }
        }
        this.subscribeTopics.push(topic);
        return topic;
    };
    HeatSubscriber.prototype.createUnsubscribeFunction = function (topic, callback) {
        var _this = this;
        return function () {
            topic.removeListener(callback);
            if (topic.isEmpty()) {
                _this.unsubscribeTopic(topic);
            }
        };
    };
    HeatSubscriber.prototype.unsubscribeTopic = function (topic) {
        this.subscribeTopics = this.subscribeTopics.filter(function (t) { return t !== topic; });
        this.unsubscribeTopics.push(topic);
        this.syncTopicSubscriptions();
    };
    HeatSubscriber.prototype.syncTopicSubscriptions = function () {
        var _this = this;
        this.getConnectedSocket().then(function (websocket) {
            if (_this.needReset) {
                websocket.close(3001, "Heat subscribes reseted");
                _this.needReset = false;
                return;
            }
            _this.unsubscribeTopics.forEach(function (topic) {
                if (topic.isSubscribed()) {
                    _this.sendUnsubscribe(websocket, topic);
                }
            });
            _this.unsubscribeTopics = _this.unsubscribeTopics.filter(function (topic) { return !topic.isSubscribed(); });
            _this.subscribeTopics.forEach(function (topic) {
                if (!topic.isSubscribed()) {
                    _this.sendSubscribe(websocket, topic);
                }
            });
            if (_this.subscribeTopics.find(function (topic) { return !topic.isSubscribed(); })) {
                _this.$timeout(_this.RETRY_SYNC_DELAY).then(function () {
                    _this.syncTopicSubscriptions();
                });
            }
        }, function () {
            _this.$timeout(_this.RETRY_SYNC_DELAY).then(function () {
                _this.syncTopicSubscriptions();
            });
        });
    };
    HeatSubscriber.prototype.getConnectedSocket = function () {
        if (this.connectedSocketPromise) {
            return this.connectedSocketPromise;
        }
        var deferred = this.$q.defer();
        var websocket = new WebSocket(this.url);
        this.hookupWebsocketEventListeners(websocket, deferred);
        return this.connectedSocketPromise = deferred.promise;
    };
    HeatSubscriber.prototype.hookupWebsocketEventListeners = function (websocket, deferred) {
        var _this = this;
        var onclose = function (event) {
            deferred.reject();
            _this.connectedSocketPromise = null;
            websocket.onclose = null;
            websocket.onopen = null;
            websocket.onerror = null;
            websocket.onmessage = null;
            _this.subscribeTopics.forEach(function (topic) { topic.setSubscribed(false); });
            _this.syncTopicSubscriptions();
        };
        var onerror = onclose;
        var onopen = function (event) {
            deferred.resolve(websocket);
        };
        var onmessage = function (event) {
            try {
                _this.onMessageReceived(JSON.parse(event.data));
            }
            catch (e) {
                console.log("Websocket parse error", e);
            }
        };
        websocket.onclose = onclose;
        websocket.onopen = onopen;
        websocket.onerror = onerror;
        websocket.onmessage = onmessage;
    };
    HeatSubscriber.prototype.sendUnsubscribe = function (websocket, topic) {
        if (websocket.readyState == 1) {
            websocket.send(JSON.stringify(["unsubscribe", [[topic.topicId, topic.params]]]));
            topic.setSubscribed(false);
        }
    };
    HeatSubscriber.prototype.sendSubscribe = function (websocket, topic) {
        if (websocket.readyState == 1) {
            websocket.send(JSON.stringify(["subscribe", [[topic.topicId, topic.params]]]));
            topic.setSubscribed(true);
        }
    };
    HeatSubscriber.prototype.onMessageReceived = function (messageJson) {
        var _this = this;
        if (!angular.isArray(messageJson) || messageJson.length != 3) {
            console.log("Websocket invalid message", messageJson);
            return;
        }
        var topicAsStr = messageJson[0], details = messageJson[1], contents = messageJson[2];
        if (!angular.isString(topicAsStr) || !angular.isObject(details)) {
            console.log("Websocket invalid field", messageJson);
            return;
        }
        this.subscribeTopics.forEach(function (topic) {
            if (topic.topicId == topicAsStr && _this.topicMatchesDetails(topic, details)) {
                _this.invokeListeners(topic, contents);
            }
        });
    };
    HeatSubscriber.prototype.topicMatchesDetails = function (topic, details) {
        var filterKeys = Object.getOwnPropertyNames(topic.params);
        for (var i = 0, key = filterKeys[i]; i < filterKeys.length; i++) {
            if (topic.params[key] != details[key])
                return false;
        }
        return true;
    };
    HeatSubscriber.prototype.invokeListeners = function (topic, contents) {
        topic.listeners.forEach(function (listener) {
            try {
                listener(contents);
            }
            catch (e) {
                console.error(e);
            }
        });
    };
    return HeatSubscriber;
}());
var HeatSubscriberTopic = (function () {
    function HeatSubscriberTopic(topicId, params) {
        this.topicId = topicId;
        this.params = params;
        this.listeners = [];
        this.subscribed = false;
        if (!angular.isString(topicId))
            throw new Error("Topic must be a string");
        if (!angular.isObject(params))
            throw new Error("Params must be an object");
        var names = Object.getOwnPropertyNames(params);
        names.forEach(function (key) {
            if (!angular.isString(params[key]))
                throw new Error("Params property " + key + " is not a string");
        });
    }
    HeatSubscriberTopic.prototype.setSubscribed = function (subscribed) {
        this.subscribed = subscribed;
    };
    HeatSubscriberTopic.prototype.isSubscribed = function () {
        return this.subscribed;
    };
    HeatSubscriberTopic.prototype.addListener = function (callback) {
        if (this.listeners.find(function (cb) { return cb === callback; }))
            throw new Error("Duplicate listener");
        this.listeners.push(callback);
    };
    HeatSubscriberTopic.prototype.removeListener = function (callback) {
        this.listeners = this.listeners.filter(function (c) { return c !== callback; });
    };
    HeatSubscriberTopic.prototype.isEmpty = function () {
        return this.listeners.length == 0;
    };
    HeatSubscriberTopic.prototype.equals = function (other) {
        if (this.topicId != other.topicId)
            return false;
        return this.objectEquals(this.params, other.params);
    };
    HeatSubscriberTopic.prototype.objectEquals = function (a, b) {
        var namesA = Object.getOwnPropertyNames(a);
        var namesB = Object.getOwnPropertyNames(b);
        if (namesA.length != namesB.length)
            return false;
        for (var i = 0; i < namesA.length; i++) {
            var key = namesA[i];
            if (a[key] != b[key])
                return false;
        }
        return true;
    };
    return HeatSubscriberTopic;
}());
var heat;
(function (heat) {
    var bundle;
    (function (bundle_1) {
        var MAGIC = 2147483647;
        var KEY_STORE_SEED = MAGIC - 1;
        var ASSET_PROPERTIES_SEED = MAGIC - 2;
        function createKeyStore(bundle) {
            var buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, true);
            buffer.writeInt32(KEY_STORE_SEED);
            var nameBytes = converters.stringToByteArray(bundle.name);
            buffer.writeShort(nameBytes.length);
            nameBytes.forEach(function (b) { buffer.writeByte(b); });
            var valueBytes = converters.stringToByteArray(bundle.value);
            valueBytes.forEach(function (b) { buffer.writeByte(b); });
            buffer.flip();
            return buffer.toHex();
        }
        bundle_1.createKeyStore = createKeyStore;
        function createAssetProperties(bundle) {
            var buffer = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, true);
            buffer.writeInt32(ASSET_PROPERTIES_SEED);
            buffer.writeInt64(Long.fromString(bundle.asset, true));
            buffer.writeInt32(bundle.protocol);
            var valueBytes = converters.stringToByteArray(bundle.value);
            buffer.writeShort(valueBytes.length);
            valueBytes.forEach(function (b) { buffer.writeByte(b); });
            buffer.flip();
            return buffer.toHex();
        }
        bundle_1.createAssetProperties = createAssetProperties;
    })(bundle = heat.bundle || (heat.bundle = {}));
})(heat || (heat = {}));
var p2p;
(function (p2p) {
    var CallDialog = (function (_super) {
        __extends(CallDialog, _super);
        function CallDialog($event, heat, user, recipient, recipientPublicKey, p2pmessaging) {
            var _this = _super.call(this, $event) || this;
            _this.heat = heat;
            _this.user = user;
            _this.recipient = recipient;
            _this.recipientPublicKey = recipientPublicKey;
            _this.p2pmessaging = p2pmessaging;
            _this.dialogTitle = 'Send offchain connect request';
            _this.dialogDescription = 'Connect other user to establish the peer-to-peer channel';
            _this.okBtnTitle = 'Connect';
            _this.okBtn['processing'] = false;
            _this.customFeeTitle = 'NO FEE';
            _this.okBtn['disabled'] = !recipient;
            return _this;
        }
        CallDialog.prototype.getFields = function ($scope) {
            var _this = this;
            var builder = new DialogFieldBuilder($scope);
            return [
                builder
                    .account('recipient', this.recipient)
                    .label('Counterparty HEAT account id')
                    .required()
                    .onchange(function (newValue) { return _this.onChangeRecipient($scope, newValue); }),
                builder.hidden('recipientPublicKey', this.recipientPublicKey)
            ];
        };
        CallDialog.prototype.getTransactionBuilder = function () {
            return undefined;
        };
        CallDialog.prototype.okBtn = function () {
            var _this = this;
            this.okBtn['processing'] = true;
            this.heat.api.getPublicKey(this.fields['recipient'].value).then(function (publicKey) {
                var room = _this.p2pmessaging.getOneToOneRoom(publicKey);
                if (_this.p2pmessaging.isPeerConnected(publicKey)) {
                    _this.okBtn['mdDialog'].hide(room);
                    return;
                }
                setTimeout(function () {
                    _this.okBtn['scope'].$evalAsync(function () {
                        _this.okBtn['processing'] = false;
                    });
                }, 7000);
                room = _this.p2pmessaging.call(publicKey);
                if (_this.channelListener) {
                    _this.p2pmessaging.removeListener(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, _this.channelListener);
                }
                _this.channelListener = function (roomParam, peerId) {
                    if (roomParam.name == room.name) {
                        _this.okBtn['mdDialog'].hide(room);
                        _this.okBtn['processing'] = false;
                        _this.p2pmessaging.removeListener(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, _this.channelListener);
                    }
                };
                _this.p2pmessaging.on(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, _this.channelListener);
                setTimeout(function () {
                    _this.p2pmessaging.removeListener(P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL, _this.channelListener);
                }, 60 * 1000);
                var peerAccount = heat.crypto.getAccountIdFromPublicKey(publicKey);
                _this.heat.api.searchPublicNames(peerAccount, 0, 100).then(function (accounts) {
                    var expectedAccount = accounts.find(function (value) { return value.publicKey == publicKey; });
                    if (expectedAccount) {
                        _this.p2pmessaging.saveContact(peerAccount, publicKey, expectedAccount.publicName, -Date.now());
                    }
                });
            }, function (reason) {
                _this.okBtn['processing'] = false;
            });
        };
        CallDialog.prototype.onChangeRecipient = function ($scope, newRecipient) {
            var _this = this;
            $scope.$evalAsync(function () {
                _this.okBtn['disabled'] = _this.user.account == newRecipient;
            });
        };
        return CallDialog;
    }(GenericDialog));
    p2p.CallDialog = CallDialog;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var MessageHistory = (function () {
        function MessageHistory(room, storage, user) {
            this.room = room;
            this.storage = storage;
            this.user = user;
            this.enabled = true;
            this.secretPhrase = this.user.key ? this.user.key.secretPhrase : this.user.secretPhrase;
            this.publicKey = this.user.key ? this.user.key.publicKey : this.user.publicKey;
            this.store = storage.namespace('p2p-messages.' + this.room.name);
            this.pages = this.store.keys()
                .map(function (key) {
                var ss = key.split('.');
                return [
                    parseInt(ss[0]),
                    (ss.length > 1 ? parseInt(ss[1]) : -1),
                    (ss.length > 2 ? parseInt(ss[2]) : -1)
                ];
            })
                .sort(function (a, b) { return a[0] - b[0]; });
            for (var i = 0; i < this.pages.length; i++) {
                if (this.pages[i][1] == -1 || this.pages[i][2] == -1) {
                    var items = this.getItemsInternal(this.pageKey(i));
                    this.savePage(i, items);
                }
            }
            if (this.pages.length == 0) {
                this.pageStorageNum = 0;
                this.pages.push([0, 0]);
            }
            else {
                this.pageStorageNum = this.pages[this.pages.length - 1][0];
                this.pageContent = this.getItems(this.pages.length - 1);
            }
            if (!this.pageContent) {
                this.pageContent = [];
            }
        }
        MessageHistory.prototype.getPageCount = function () {
            return this.pages.length;
        };
        MessageHistory.prototype.getItemCount = function () {
            return this.pages.map(function (v) { return v[1]; }).reduce(function (previousValue, currentValue) { return previousValue + currentValue; });
        };
        MessageHistory.prototype.getItemsScrollable = function (start, end) {
            var n = 0;
            var result = [];
            if (end <= 0) {
                return result;
            }
            start = Math.max(0, start);
            var needingLength = end - start;
            for (var i = 0; i < this.pages.length; i++) {
                var page = this.pages[i];
                n = n + page[1];
                if (n > start) {
                    var pageItems = this.getItems(i);
                    var pageStartIndex = Math.max(0, result.length > 0 ? 0 : start - (n - page[1]));
                    result = result.concat(pageItems.slice(pageStartIndex, pageStartIndex + (needingLength - result.length)));
                }
                if (result.length == needingLength) {
                    return result;
                }
            }
            return result;
        };
        MessageHistory.prototype.getItems = function (pageIndex) {
            if (pageIndex >= 0 && pageIndex < this.pages.length) {
                return this.getItemsInternal(this.pageKey(pageIndex));
            }
            return [];
        };
        MessageHistory.prototype.getItemsInternal = function (key) {
            var v = this.store.getString(key);
            if (v) {
                try {
                    var encrypted = JSON.parse(v);
                    var pageContentStr = heat.crypto.decryptMessage(encrypted.data, encrypted.nonce, this.publicKey, this.secretPhrase);
                    return JSON.parse(pageContentStr);
                }
                catch (e) {
                    console.log("Error on parse/decrypt message history page");
                }
            }
            return [];
        };
        MessageHistory.prototype.put = function (item) {
            this.pageContent.push(item);
            this.savePage(this.pages.length - 1, this.pageContent);
            if (this.pageContent.length >= MessageHistory.MAX_PAGE_LENGTH) {
                this.pageContent = [];
                this.pageStorageNum++;
                this.pages.push([this.pageStorageNum, 0]);
            }
            if (this.pages.length > MessageHistory.MAX_PAGES_COUNT) {
                console.log("Remove page " + this.pageKey(0));
                this.store.remove(this.pageKey(0));
                this.pages.splice(0, 1);
            }
        };
        MessageHistory.prototype.remove = function (timestamp) {
            for (var i = this.pages.length - 1; i >= 0; i--) {
                var items = this.getItems(i);
                var newItems = items.filter(function (item) { return item.timestamp != timestamp; });
                if (items.length != newItems.length) {
                    this.savePage(i, newItems);
                    return items.length - newItems.length;
                }
            }
            return 0;
        };
        MessageHistory.prototype.savePage = function (pageIndex, pageContent) {
            var encrypted = heat.crypto.encryptMessage(JSON.stringify(pageContent), this.publicKey, this.secretPhrase, false);
            var page = this.pages[pageIndex];
            try {
                this.store.remove(this.pageKey(pageIndex));
                page[1] = pageContent.length;
                page[2] = pageContent.length > 0 ? pageContent[pageContent.length - 1].timestamp : 0;
                this.store.put(this.pageKey(pageIndex), JSON.stringify(encrypted));
            }
            catch (domException) {
                console.log("Save page error " + domException);
                if (['QuotaExceededError', 'NS_ERROR_DOM_QUOTA_REACHED'].indexOf(domException.name) >= 0) {
                    var attempts = 5;
                    while (attempts > 0) {
                        try {
                            this.shrinkPageStore(6 - attempts);
                            this.store.put(this.pageKey(pageIndex), JSON.stringify(encrypted));
                            attempts = 0;
                        }
                        catch (e) {
                            console.log("Error while shrinking message history " + e);
                        }
                        attempts--;
                    }
                }
            }
        };
        MessageHistory.prototype.shrinkPageStore = function (pageToRemoveNumber) {
            var allRoomStore = this.storage.namespace('p2p-messages');
            var keysByTime = allRoomStore.keys()
                .map(function (key) {
                var ss = key.split('.');
                return [ss[0], parseInt(ss[1]), parseInt(ss[2]), parseInt(ss[3])];
            })
                .sort(function (a, b) { return a[3] - b[3]; });
            for (var _i = 0, keysByTime_1 = keysByTime; _i < keysByTime_1.length; _i++) {
                var key = keysByTime_1[_i];
                allRoomStore.remove(key.join('.'));
                if ((--pageToRemoveNumber) <= 0) {
                    break;
                }
            }
        };
        MessageHistory.prototype.pageKey = function (pageIndex) {
            var page = this.pages[pageIndex];
            return page[0] + (page[1] == -1 ? "" : "." + page[1]) + (page[2] == -1 ? "" : "." + page[2]);
        };
        MessageHistory.MAX_PAGES_COUNT = 200;
        MessageHistory.MAX_PAGE_LENGTH = 100;
        return MessageHistory;
    }());
    p2p.MessageHistory = MessageHistory;
})(p2p || (p2p = {}));
var p2p;
(function (p2p) {
    var P2PConnector = (function () {
        function P2PConnector(messenger, settings, $interval) {
            this.messenger = messenger;
            this.settings = settings;
            this.$interval = $interval;
            this.rooms = new Map();
            this.signalingMessageAwaitings = [];
            this.notAcceptedResponse = "notAcceptedResponse_@)(%$#&#&";
            this.pendingRooms = [];
            this._onlineStatus = "offline";
            this.signalingReady = null;
            this.config = {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: ["stun:stun1.l.google.com:19302", "stun:stun2.l.google.com:19302", "stun:stun3.l.google.com:19302", "stun:stun4.l.google.com:19302"] },
                    { urls: "stun:23.21.150.121" },
                    { urls: "stun:stun01.sipphone.com" },
                    { urls: "stun:stun.iptel.org" },
                    { urls: "stun:stun.ekiga.net" },
                    { urls: "stun:stun.fwdnet.net" },
                    { urls: "stun:stun.xten.com" }
                ],
            };
        }
        P2PConnector.prototype.setup = function (identity, createRoom, confirmIncomingCall, signalingError, sign, encrypt, decrypt) {
            this.pendingIdentity = identity;
            this.createRoom = createRoom;
            this.confirmIncomingCall = confirmIncomingCall;
            this.sign = sign;
            this.signalingError = signalingError;
            this.encrypt = encrypt;
            this.decrypt = decrypt;
        };
        P2PConnector.prototype.setOnlineStatus = function (status) {
            var _this = this;
            var sendOnlineStatus = function () {
                _this.sendSignalingMessage([{ type: "SET_ONLINE_STATUS", status: status }]);
                if (status == "online") {
                    _this.rooms.forEach(function (room) {
                        if (room.state.entered == "entered") {
                            room.enter(true);
                        }
                    });
                }
            };
            if (this.identity) {
                sendOnlineStatus();
            }
            else {
                this.sendSignalingMessage([{ type: "WANT_PROVE_IDENTITY" }]);
                this.pendingOnlineStatus = sendOnlineStatus;
            }
            this._onlineStatus = status;
            if (status == "offline") {
                this.identity = null;
            }
        };
        Object.defineProperty(P2PConnector.prototype, "onlineStatus", {
            get: function () {
                return this._onlineStatus;
            },
            enumerable: true,
            configurable: true
        });
        P2PConnector.prototype.getPeerOnlineStatus = function (peerId) {
            var _this = this;
            return this.request(function () { return _this.sendSignalingMessage([{ type: "GET_ONLINE_STATUS", peerId: peerId }]); }, function (msg) {
                if (msg.type === "ONLINE_STATUS" && msg.peerId == peerId)
                    return msg.status;
                return _this.notAcceptedResponse;
            });
        };
        P2PConnector.prototype.call = function (toPeerId, caller, room) {
            this.sendSignalingMessage([{ type: "CALL", toPeerId: toPeerId, caller: caller, room: room.name }]);
        };
        P2PConnector.prototype.getTmp = function (roomName) {
            var _this = this;
            return this.request(function () { return _this.sendSignalingMessage([{ type: "WHO_ONLINE" }]); }, function (msg) {
                if (msg.type === "WHO_ONLINE")
                    return msg.remotePeerIds;
                return _this.notAcceptedResponse;
            });
        };
        P2PConnector.prototype.enter = function (room, enforce) {
            var _this = this;
            var existingRoom = this.rooms.get(room.name);
            if (existingRoom && existingRoom.state.entered == "entered") {
                if (enforce) {
                    existingRoom.state.entered = "not";
                }
                else {
                    return;
                }
            }
            var requestEnterRoom = function () {
                room.state.approved = true;
                if (room.state.entered == "not") {
                    room.state.entered = "entering";
                    setTimeout(function () {
                        if (room.state.entered != "entered") {
                            room.state.entered = "not";
                        }
                    }, 4000);
                    _this.sendSignalingMessage([{ type: "ROOM", room: room.name }]);
                }
            };
            this.rooms.set(room.name, room);
            if (this.identity) {
                requestEnterRoom();
            }
            else {
                this.pendingRooms.push(requestEnterRoom);
                this.sendSignalingMessage([{ type: "WANT_PROVE_IDENTITY" }]);
                return;
            }
        };
        P2PConnector.prototype.getWebSocket = function () {
            var _this = this;
            if (!this.webSocketPromise || this.signalingReady === false) {
                this.webSocketPromise = new Promise(function (resolve, reject) {
                    var url = _this.settings.get(SettingsService.HEAT_WEBRTC_WEBSOCKET);
                    var socket = new WebSocket(url);
                    socket.onopen = function () {
                        socket.onmessage = function (msg) { return _this.onSignalingMessage(msg); };
                        socket.onclose = function () { return _this.onSignalingClosed(); };
                        _this.signalingReady = true;
                        if (_this.pingSignalingInterval) {
                            _this.$interval.cancel(_this.pingSignalingInterval);
                        }
                        _this.pingSignalingInterval = _this.$interval(function () {
                            _this.pingSignalingServer(socket);
                        }, 120 * 1000, 0, false);
                        resolve(socket);
                    };
                    socket.onerror = function (error) {
                        console.log(error);
                        reject(error);
                        _this.webSocketPromise = null;
                    };
                });
            }
            return this.webSocketPromise;
        };
        P2PConnector.prototype.pingSignalingServer = function (socket) {
            if (this.signalingReady) {
                this.sendSignalingMessage([{ type: "PING" }]);
            }
        };
        P2PConnector.prototype.sendSignalingMessage = function (data) {
            return this.getWebSocket()
                .then(function (websocket) {
                data.splice(0, 0, "webrtc");
                websocket.send(JSON.stringify(data));
            }, function (reason) { return console.log(reason); })
                .catch(function (reason) {
                console.log("error on get websocket \n" + reason);
            });
        };
        P2PConnector.prototype.onSignalingMessage = function (messageEvent) {
            var _this = this;
            if (this._onlineStatus == "offline") {
                return;
            }
            var data = JSON.parse(messageEvent.data);
            var msg;
            if (data.encrypted) {
                msg = JSON.parse(this.decrypt(data.encrypted, data.fromPeer));
                msg.fromPeer = data.fromPeer;
                msg.toPeer = data.toPeer;
                msg.room = data.room;
            }
            else {
                msg = data;
            }
            var roomName = msg.room;
            if (msg.type === 'PONG') {
            }
            else if (msg.type === 'PROVE_IDENTITY') {
                var signedData = this.sign(msg.data);
                signedData["type"] = P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY;
                this.sendSignalingMessage([signedData]);
            }
            else if (msg.type === 'APPROVED_IDENTITY') {
                this.identity = this.pendingIdentity;
                this.pendingRooms.forEach(function (f) { return f(); });
                this.pendingRooms = [];
                if (this.pendingOnlineStatus)
                    this.pendingOnlineStatus();
                this.pendingOnlineStatus = null;
            }
            else if (msg.type === 'CALL') {
                var caller_1 = msg.caller;
                this.confirmIncomingCall(caller_1).then(function (value) {
                    var room = _this.createRoom(roomName, caller_1);
                    _this.enter(room, true);
                });
            }
            else if (msg.type === 'ERROR') {
                this.signalingError(msg.reason);
            }
            else if (msg.type === 'WELCOME') {
                var room_1 = this.rooms.get(roomName);
                room_1.state.entered = "entered";
                msg.remotePeerIds.forEach(function (peerId) {
                    var peer = room_1.createPeer(peerId, peerId);
                    if (peer && !peer.isConnected()) {
                        var pc = _this.askPeerConnection(roomName, peerId);
                        _this.doOffer(roomName, peerId, pc);
                    }
                });
            }
            else if (msg.type === 'offer') {
                var peerId_1 = msg.fromPeer;
                var peer = this.rooms.get(roomName).createPeer(peerId_1, peerId_1);
                if (peer && !peer.isConnected()) {
                    var room_2 = this.rooms.get(roomName);
                    var pc_1 = this.askPeerConnection(roomName, peerId_1);
                    if (pc_1) {
                        pc_1.setRemoteDescription(new RTCSessionDescription(msg))
                            .then(function () {
                            _this.doAnswer(roomName, peerId_1, pc_1);
                        })
                            .catch(function (e) {
                            if (room_2.onFailure) {
                                room_2.onFailure(peerId_1, e);
                            }
                            else {
                                console.log(e.name + "  " + e.message);
                            }
                        });
                    }
                }
            }
            else if (msg.type === 'answer') {
                var room_3 = this.rooms.get(roomName);
                var peer = room_3.getPeer(msg.fromPeer);
                if (peer && !peer.isConnected()) {
                    var pc = peer.peerConnection;
                    if (pc) {
                        pc.setRemoteDescription(new RTCSessionDescription(msg))
                            .catch(function (e) {
                            if (room_3.onFailure) {
                                room_3.onFailure(msg.fromPeer, e);
                            }
                            else {
                                console.log(e.name + "  " + e.message);
                            }
                        });
                    }
                }
            }
            else if (msg.type === 'candidate') {
                var room_4 = this.rooms.get(roomName);
                var peer_1 = room_4.getPeer(msg.fromPeer);
                var pc = peer_1.peerConnection;
                var candidate = new RTCIceCandidate({
                    sdpMLineIndex: msg.label,
                    candidate: msg.candidate
                });
                pc.addIceCandidate(candidate)
                    .catch(function (e) {
                    console.log("Failure during addIceCandidate(): " + e.name + "  " + e.message);
                    if (room_4.onFailure) {
                        room_4.onFailure(msg.fromPeer, e);
                    }
                });
                if (!peer_1['noNeedReconnect']) {
                    setTimeout(function () {
                        if (!peer_1.isConnected() && peer_1['connectionRole'] == "answer") {
                            peer_1['noNeedReconnect'] = true;
                            var pc_2 = _this.askPeerConnection(roomName, msg.fromPeer);
                            _this.doOffer(roomName, msg.fromPeer, pc_2);
                        }
                    }, 2500);
                }
            }
            else if (msg.type === 'WRONGROOM') {
                console.log("Wrong room");
            }
            else {
                this.signalingMessageAwaitings.forEach(function (f) { return f(msg); });
            }
        };
        P2PConnector.prototype.onSignalingClosed = function () {
            this.signalingReady = false;
            this.$interval.cancel(this.pingSignalingInterval);
        };
        P2PConnector.prototype.askPeerConnection = function (roomName, peerId) {
            var _this = this;
            var peer = this.rooms.get(roomName).getPeer(peerId);
            var pc = peer.peerConnection;
            if (pc && pc.iceConnectionState != "connected" && pc.iceConnectionState != "completed") {
                pc.close();
                pc = null;
            }
            try {
                pc = new RTCPeerConnection(this.config);
                pc.onicecandidate = function (event) {
                    if (event.candidate) {
                        var data = {
                            type: 'candidate',
                            label: event.candidate.sdpMLineIndex,
                            id: event.candidate.sdpMid,
                            candidate: event.candidate.candidate
                        };
                        var encrypted = _this.encrypt(JSON.stringify(data), peerId);
                        _this.sendSignalingMessage([
                            { room: roomName, toPeerId: peerId },
                            { room: roomName, fromPeer: _this.identity, encrypted: encrypted }
                        ]);
                    }
                };
                pc.ondatachannel = function (event) {
                    var dataChannel = event.channel;
                    _this.initDataChannel(roomName, peerId, dataChannel, true);
                    peer.dataChannel = dataChannel;
                };
                pc.oniceconnectionstatechange = function (event) {
                    if (pc.iceConnectionState == "failed") {
                        console.log("iceConnectionState failed");
                    }
                    if (pc.iceConnectionState == 'disconnected') {
                        if (peer.dataChannel) {
                            peer.dataChannel.close();
                            _this.onCloseDataChannel(roomName, peerId, peer.dataChannel);
                        }
                        console.log('Peer is disconnected');
                    }
                };
                pc.onicecandidateerror = function (event) {
                    console.log(event.errorCode + "  " + event.hostCandidate + "  " + event.url + "  " + event.errorText);
                };
                peer.peerConnection = pc;
                return pc;
            }
            catch (e) {
                console.log(e);
                pc = null;
                return;
            }
        };
        P2PConnector.prototype.initDataChannel = function (roomName, peerId, dataChannel, sendCheckingMessage) {
            var _this = this;
            dataChannel.onopen = function (event) { return _this.onOpenDataChannel(roomName, peerId, dataChannel, sendCheckingMessage); };
            dataChannel.onclose = function (event) { return _this.onCloseDataChannel(roomName, peerId, dataChannel); };
            dataChannel.onmessage = function (event) { return _this.onMessage(roomName, peerId, dataChannel, event); };
            this.rooms.get(roomName).getPeer(peerId).dataChannel = dataChannel;
        };
        P2PConnector.prototype.onOpenDataChannel = function (roomName, peerId, dataChannel, sendCheckingMessage) {
            if (sendCheckingMessage) {
                var checkChannelMessage = { type: P2PConnector.MSG_TYPE_CHECK_CHANNEL, room: roomName, value: ("" + Math.random()) };
                this.sendSignalingMessage([checkChannelMessage]);
                this.send(roomName, JSON.stringify(checkChannelMessage), dataChannel);
            }
            var room = this.rooms.get(roomName);
            if (room.onOpenDataChannel) {
                room.onOpenDataChannel(peerId);
            }
            room.getPeer(peerId).dataChannel = dataChannel;
            var dataHex = converters.stringToHexString(randomString());
            if (!room["proofData"])
                room["proofData"] = {};
            room["proofData"][peerId] = dataHex;
            var signedData = this.sign(dataHex);
            var proofRequest = { type: P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY,
                signature: signedData.signatureHex, data: signedData.dataHex, publicKey: signedData.publicKeyHex };
            this.send(roomName, JSON.stringify(proofRequest), dataChannel);
        };
        P2PConnector.prototype.onCloseDataChannel = function (roomName, peerId, dataChannel) {
            var room = this.rooms.get(roomName);
            room.getPeer(peerId).dataChannel = null;
            if (room && room.onCloseDataChannel)
                room.onCloseDataChannel(peerId);
        };
        P2PConnector.prototype.createDataChannel = function (room, peerId, peerConnection, role) {
            var dataChannel;
            try {
                dataChannel = peerConnection.createDataChannel(room + ":" + peerId, null);
            }
            catch (e) {
                console.log('error creating data channel ' + e);
                return;
            }
            this.initDataChannel(room, peerId, dataChannel);
        };
        P2PConnector.prototype.onFailure = function (roomName, peerId, e) {
            var room = this.rooms.get(roomName);
            if (room.onFailure)
                room.onFailure(peerId, e);
        };
        P2PConnector.prototype.doOffer = function (roomName, peerId, peerConnection) {
            var _this = this;
            console.log("do offer");
            var peer = this.rooms.get(roomName).getPeer(peerId);
            peer['connectionRole'] = 'offer';
            this.createDataChannel(roomName, peerId, peerConnection, "caller");
            peerConnection.createOffer(function (offer) {
                peerConnection.setLocalDescription(offer, function () {
                    var encrypted = _this.encrypt(JSON.stringify(peerConnection.localDescription), peerId);
                    _this.sendSignalingMessage([
                        { room: roomName, toPeerId: peerId, fromPeer: _this.identity, encrypted: encrypted }
                    ]);
                }, function (e) { return _this.onFailure(roomName, peerId, e); });
            }, function (e) { return _this.onFailure(roomName, peerId, e); }, null);
        };
        P2PConnector.prototype.doAnswer = function (roomName, peerId, peerConnection) {
            var _this = this;
            console.log("do answer");
            var peer = this.rooms.get(roomName).getPeer(peerId);
            peer['connectionRole'] = peer['connectionRole'] ? 'no need' : 'answer';
            peerConnection.createAnswer(function (answer) {
                peerConnection.setLocalDescription(answer, function () {
                    var encrypted = _this.encrypt(JSON.stringify(peerConnection.localDescription), peerId);
                    _this.sendSignalingMessage([
                        { room: roomName, toPeerId: peerId, fromPeer: _this.identity, encrypted: encrypted }
                    ]);
                }, function (e) { return _this.onFailure(roomName, peerId, e); });
            }, function (e) { return _this.onFailure(roomName, peerId, e); });
        };
        P2PConnector.prototype.sendMessage = function (roomName, message) {
            return this.send(roomName, JSON.stringify(message));
        };
        P2PConnector.prototype.send = function (roomName, data, channel) {
            var room = this.rooms.get(roomName);
            var peers = Array.from(room.getAllPeers().values());
            var count = 0;
            for (var _i = 0, peers_1 = peers; _i < peers_1.length; _i++) {
                var peer = peers_1[_i];
                if (channel) {
                    if (peer.dataChannel == channel) {
                        var encrypted = this.encrypt(data, peer.publicKey);
                        return this.sendInternal(channel, JSON.stringify(encrypted));
                    }
                }
                else {
                    var encrypted = this.encrypt(data, peer.publicKey);
                    count = count + this.sendInternal(peer.dataChannel, JSON.stringify(encrypted));
                }
            }
            return count;
        };
        P2PConnector.prototype.sendInternal = function (channel, data) {
            var notSentReason;
            if (channel.readyState == "open") {
                try {
                    channel.send(data);
                    return 1;
                }
                catch (e) {
                    notSentReason = e.toString();
                }
            }
            else {
                notSentReason = "Channel state " + channel.readyState;
            }
            if (notSentReason) {
                console.log("Not sent: " + notSentReason);
            }
            return 0;
        };
        P2PConnector.prototype.onMessage = function (roomName, peerId, dataChannel, event) {
            try {
                var encrypted = JSON.parse(event.data);
                var msg = JSON.parse(this.decrypt(encrypted, peerId));
                var room = this.rooms.get(roomName);
                if (room) {
                    msg.fromPeerId = peerId;
                    msg.roomName = roomName;
                    room.onMessageInternal(msg);
                    this.messenger.onMessage(msg, room);
                }
                if (msg.type === P2PConnector.MSG_TYPE_CHECK_CHANNEL) {
                    this.sendSignalingMessage([{ room: roomName }, msg]);
                }
                else if (msg.type === P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY) {
                    var signedData = this.sign(msg.data);
                    var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY,
                        signature: signedData.signatureHex, data: signedData.dataHex, publicKey: signedData.publicKeyHex };
                    this.send(roomName, JSON.stringify(response), dataChannel);
                }
                else if (msg.type === P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY) {
                    if (msg.rejected) {
                        if (room.onRejected) {
                            room.onRejected(peerId, msg.rejected);
                        }
                        console.log("Peer " + peerId + " rejected channel to him");
                        dataChannel.close();
                        return;
                    }
                    var rejectedReason = void 0;
                    if (room["proofData"][peerId] !== msg.data) {
                        rejectedReason = "Received data does not match the sent data";
                    }
                    else if (msg.publicKey !== peerId) {
                        rejectedReason = "Received public key does not match the peer's public key";
                    }
                    else if (room.memberPublicKeys.indexOf(msg.publicKey) == -1) {
                        rejectedReason = "Received public key is not allowed";
                    }
                    if (rejectedReason) {
                        var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY, rejected: rejectedReason };
                        this.send(roomName, JSON.stringify(response), dataChannel);
                        dataChannel.close();
                        return;
                    }
                    if (heat.crypto.verifyBytes(msg.signature, msg.data, msg.publicKey)) {
                        delete room["proofData"][peerId];
                        console.log("PROOF_IDENTITY ok: \n" + msg.signature + " " + msg.data + " " + msg.publicKey);
                        if (!room.provenPublicKeyAllowed(room, peerId, msg.publicKey)) {
                            var response = { type: P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY, rejected: "Public key owner is not allowed to connect" };
                            this.send(roomName, JSON.stringify(response), dataChannel);
                            dataChannel.close();
                        }
                    }
                    else {
                        var response = { type: P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY, rejected: "Invalid signature" };
                        this.send(roomName, JSON.stringify(response), dataChannel);
                        dataChannel.close();
                    }
                }
            }
            catch (e) {
                console.log(e);
            }
        };
        P2PConnector.prototype.closeRoom = function (room) {
            var dataChannels = room.getDataChannels();
            dataChannels.forEach(function (channel) { return channel.close(); });
        };
        P2PConnector.prototype.close = function () {
            var _this = this;
            this.identity = null;
            this.pendingIdentity = null;
            this.pendingRooms = [];
            this.pendingOnlineStatus = null;
            this.rooms.forEach(function (room) { return _this.closeRoom(room); });
            if (this.signalingReady) {
                this.getWebSocket().then(function (socket) { return socket.close(); });
            }
        };
        P2PConnector.prototype.request = function (request, handleResponse) {
            var _this = this;
            var p = new Promise(function (resolve, reject) {
                var f = function (msg) {
                    var v = handleResponse(msg);
                    if (v !== _this.notAcceptedResponse) {
                        resolve(v);
                        var i = _this.signalingMessageAwaitings.indexOf(f);
                        if (i !== -1)
                            _this.signalingMessageAwaitings.splice(i, 1);
                    }
                };
                _this.signalingMessageAwaitings.push(f);
                return request();
            });
            return promiseTimeout(3000, p);
        };
        P2PConnector.MSG_TYPE_CHECK_CHANNEL = "CHECK_CHANNEL";
        P2PConnector.MSG_TYPE_REQUEST_PROOF_IDENTITY = "GET_PROOF_IDENTITY";
        P2PConnector.MSG_TYPE_RESPONSE_PROOF_IDENTITY = "PROOF_IDENTITY";
        return P2PConnector;
    }());
    p2p.P2PConnector = P2PConnector;
    function promiseTimeout(ms, promise) {
        return new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                reject(new Error("promise timeout"));
            }, ms);
            promise
                .then(function (res) {
                clearTimeout(timer);
                resolve(res);
            })
                .catch(function (err) {
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    function randomString() {
        return Math.random().toString(36).substr(2);
    }
})(p2p || (p2p = {}));
var P2PMessaging = (function (_super) {
    __extends(P2PMessaging, _super);
    function P2PMessaging(settings, user, storage, $interval, heat, $mdToast) {
        var _this = _super.call(this) || this;
        _this.settings = settings;
        _this.user = user;
        _this.storage = storage;
        _this.$interval = $interval;
        _this.heat = heat;
        _this.$mdToast = $mdToast;
        _this.offchainMode = false;
        _this.hasUnreadMessage = false;
        _this.sendKeys = function (room, text) {
            room.sendMessage({ timestamp: Date.now(), type: "contactUpdate", text: text });
        };
        var listener = function () {
            _this.publicKey = _this.user.key ? _this.user.key.publicKey : _this.user.publicKey;
            _this.secretPhrase = _this.user.key ? _this.user.key.secretPhrase : _this.user.secretPhrase;
            _this.connector = new p2p.P2PConnector(_this, settings, $interval);
            _this.connector.setup(_this.publicKey, function (roomName, peerId) { return _this.createRoomOnIncomingCall(roomName, peerId); }, function (peerId) { return _this.confirmIncomingCall(peerId); }, function (reason) { return _this.onSignalingError(reason); }, function (dataHex) { return _this.sign(dataHex); }, function (message, peerPublicKey) { return _this.encrypt(message, peerPublicKey); }, function (message, peerPublicKey) { return _this.decrypt(message, peerPublicKey); });
        };
        user.on(UserService.EVENT_UNLOCKED, listener);
        _this.p2pContactStore = storage.namespace('p2pContacts');
        _this.seenP2PMessageTimestampStore = storage.namespace('contacts.seenP2PMessageTimestamp');
        return _this;
    }
    P2PMessaging_1 = P2PMessaging;
    P2PMessaging.prototype.encrypt = function (message, peerPublicKey) {
        return heat.crypto.encryptMessage(message, peerPublicKey, this.secretPhrase, false);
    };
    P2PMessaging.prototype.decrypt = function (message, peerPublicKey) {
        return heat.crypto.decryptMessage(message.data, message.nonce, peerPublicKey, this.secretPhrase, false);
    };
    P2PMessaging.prototype.onMessage = function (msg, room) {
        this.emit(P2PMessaging_1.EVENT_NEW_MESSAGE, msg, room);
        this.seenP2PMessageTimestampStore.put(room.name + "_last-message-time", Date.now());
        this.updateSeenTime(null);
        this.displayNewMessagePopup(msg, room);
    };
    P2PMessaging.prototype.displayNewMessagePopup = function (msg, room) {
        if (msg.type == "chat" && msg.text) {
            var account = heat.crypto.getAccountIdFromPublicKey(msg.fromPeerId);
            var text = msg.text.substring(0, 50);
            if (msg.text.length > 50) {
                var lastSpaceIndex = Math.max(text.lastIndexOf(" "), 30);
                text = text.substring(0, lastSpaceIndex) + " ...";
            }
            this.$mdToast.show(this.$mdToast.simple().textContent("New message from " + account + ": \"" + text + "\"").hideDelay(6000));
        }
        else if (msg.type == "contactUpdate") {
            var parsedMessage_1 = JSON.parse(msg.text);
            var account_1 = heat.crypto.getAccountIdFromPublicKey(msg.fromPeerId);
            var publicKey_1 = msg.fromPeerId;
            console.log(msg.text);
            this.heat.api.searchPublicNames(account_1, 0, 100).then(function (accounts) {
                var expectedAccount = accounts.find(function (value) { return value.publicKey == publicKey_1; });
                if (expectedAccount) {
                    var contactUtils = heat.$inject.get('p2pContactUtils');
                    contactUtils.updateContactCurrencyAddress(account_1, parsedMessage_1.name, parsedMessage_1.address, publicKey_1, expectedAccount.publicName, -Date.now());
                }
            });
        }
    };
    Object.defineProperty(P2PMessaging.prototype, "onlineStatus", {
        get: function () {
            return this.connector.onlineStatus;
        },
        set: function (status) {
            this.connector.setOnlineStatus(status);
        },
        enumerable: true,
        configurable: true
    });
    P2PMessaging.prototype.getOneToOneRoom = function (peerId, required) {
        var roomName = this.generateOneToOneRoomName(this.publicKey, peerId);
        var room = this.connector.rooms.get(roomName);
        if (!room && required) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        if (room && room.getAllPeers().size <= 1) {
            return room;
        }
    };
    P2PMessaging.prototype.enterRoom = function (peerId) {
        if (this.onlineStatus == "offline") {
            return null;
        }
        var roomName = this.generateOneToOneRoomName(this.publicKey, peerId);
        var room = this.connector.rooms.get(roomName);
        if (!room) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        if (room.state.entered == "not") {
            room.enter();
        }
        return room;
    };
    P2PMessaging.prototype.call = function (peerId) {
        var room = this.enterRoom(peerId);
        this.connector.call(peerId, this.publicKey, room);
        return room;
    };
    P2PMessaging.prototype.onSignalingError = function (reason) {
        console.log("Signaling error: " + reason);
    };
    P2PMessaging.prototype.sign = function (dataHex) {
        var signature = heat.crypto.signBytes(dataHex, converters.stringToHexString(this.secretPhrase));
        return { signatureHex: signature, dataHex: dataHex, publicKeyHex: this.publicKey };
    };
    P2PMessaging.prototype.setupRoom = function (room) {
        var _this = this;
        room.onOpenDataChannel = function (peerId) {
            _this.emit(P2PMessaging_1.EVENT_ON_OPEN_DATA_CHANNEL, room, peerId);
        };
        room.onCloseDataChannel = function (peerId) {
            _this.emit(P2PMessaging_1.EVENT_ON_CLOSE_DATA_CHANNEL, room, peerId);
        };
        room.lastIncomingMessageTimestamp = this.seenP2PMessageTimestampStore.getNumber(room.name + "_last-message-time", 0);
        return room;
    };
    P2PMessaging.prototype.generateOneToOneRoomName = function (peerOnePublicKey, peerTwoPublicKey) {
        var arr = [heat.crypto.getAccountIdFromPublicKey(peerOnePublicKey), heat.crypto.getAccountIdFromPublicKey(peerTwoPublicKey)];
        arr.sort();
        return arr[0] + "-" + arr[1];
    };
    P2PMessaging.prototype.createRoomOnIncomingCall = function (roomName, peerId) {
        var room = this.connector.rooms.get(roomName);
        if (!room) {
            room = this.setupRoom(new p2p.Room(roomName, this.connector, this.storage, this.user, [peerId]));
            this.connector.rooms.set(roomName, room);
        }
        return room;
    };
    P2PMessaging.prototype.confirmIncomingCall = function (peerId) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.isPeerConnected(peerId)) {
                resolve();
                return;
            }
            var updateContactCallTime = function (account, publicKey, publicName) {
                _this.saveContact(peerAccount, peerId, publicName, -Date.now());
            };
            var peerAccount = heat.crypto.getAccountIdFromPublicKey(peerId);
            _this.heat.api.searchPublicNames(peerAccount, 0, 100).then(function (accounts) {
                var expectedAccount = accounts.find(function (value) { return value.publicKey == peerId; });
                if (expectedAccount) {
                    var closeDialogOnConnected = function (mdDialog) {
                        var interval = _this.$interval(function () {
                            if (_this.isPeerConnected(peerId)) {
                                mdDialog.cancel("Already connected");
                                _this.$interval.cancel(interval);
                                updateContactCallTime(peerAccount, peerId, expectedAccount.publicName);
                            }
                        }, 500, 7, false);
                    };
                    dialogs.confirm("Incoming connect request", "Account &nbsp;&nbsp;<b>" + expectedAccount.publicName + "</b>&nbsp;&nbsp; wants to connect with you. Accepting connection will share your current IP address. Accept or decline? Click OK to accept, Cancel to decline.", closeDialogOnConnected).then(function () {
                        updateContactCallTime(peerAccount, peerId, expectedAccount.publicName);
                        resolve();
                    });
                }
                else {
                    reject("Account not found");
                }
            });
        });
    };
    P2PMessaging.prototype.dialog = function ($event, recipient, recipientPublicKey, userMessage) {
        return new p2p.CallDialog($event, this.heat, this.user, recipient, recipientPublicKey, this);
    };
    P2PMessaging.prototype.saveContact = function (account, publicKey, publicName, calledTimestamp) {
        if (!publicKey)
            return;
        var contact = this.p2pContactStore.get(account);
        if (contact && calledTimestamp && calledTimestamp != contact.activityTimestamp) {
            contact.activityTimestamp = calledTimestamp;
            this.p2pContactStore.put(account, contact);
        }
        if (!contact) {
            contact = {
                account: account,
                privateName: '',
                publicKey: publicKey,
                publicName: publicName,
                timestamp: 0,
                activityTimestamp: calledTimestamp
            };
            this.p2pContactStore.put(account, contact);
        }
    };
    P2PMessaging.prototype.isPeerConnected = function (peerId) {
        var room = this.getOneToOneRoom(peerId);
        if (room) {
            var peer = room.getPeer(peerId);
            return peer && peer.isConnected();
        }
        return false;
    };
    P2PMessaging.prototype.roomHasUnreadMessage = function (room) {
        return room.lastIncomingMessageTimestamp > this.seenP2PMessageTimestampStore.getNumber(room.name, 0);
    };
    P2PMessaging.prototype.updateSeenTime = function (roomName, timestamp) {
        var _this = this;
        if (roomName) {
            this.seenP2PMessageTimestampStore.put(roomName, timestamp ? timestamp : Date.now() - 500);
        }
        var unreadRooms = [];
        this.connector.rooms.forEach(function (room) {
            if (_this.roomHasUnreadMessage(room)) {
                unreadRooms.push(room);
            }
        });
        var nowHasUnreadMessage = unreadRooms.length > 0;
        if (nowHasUnreadMessage != this.hasUnreadMessage) {
            this.hasUnreadMessage = nowHasUnreadMessage;
            this.emit(P2PMessaging_1.EVENT_HAS_UNREAD_CHANGED, unreadRooms);
        }
    };
    var P2PMessaging_1;
    P2PMessaging.EVENT_NEW_MESSAGE = 'EVENT_NEW_MESSAGE';
    P2PMessaging.EVENT_HAS_UNREAD_CHANGED = 'EVENT_HAS_UNREAD_CHANGED';
    P2PMessaging.EVENT_ON_OPEN_DATA_CHANNEL = 'EVENT_ON_OPEN_DATA_CHANNEL';
    P2PMessaging.EVENT_ON_CLOSE_DATA_CHANNEL = 'EVENT_ON_CLOSE_DATA_CHANNEL';
    P2PMessaging = P2PMessaging_1 = __decorate([
        Service('P2PMessaging'),
        Inject('settings', 'user', 'storage', '$interval', 'heat', '$mdToast'),
        __metadata("design:paramtypes", [SettingsService,
            UserService,
            StorageService, Function, HeatService, Object])
    ], P2PMessaging);
    return P2PMessaging;
}(EventEmitter));
var P2pContactUtils = (function () {
    function P2pContactUtils(storage, heat, $q, user) {
        this.storage = storage;
        this.heat = heat;
        this.$q = $q;
        this.user = user;
        this.p2pContactStore = storage.namespace('p2pContacts');
    }
    P2pContactUtils_1 = P2pContactUtils;
    P2pContactUtils.prototype.saveContact = function (account, publicKey, publicName, calledTimestamp) {
        if (!publicKey)
            return;
        var contact = this.p2pContactStore.get(account);
        if (contact && calledTimestamp && calledTimestamp != contact.activityTimestamp) {
            contact.activityTimestamp = calledTimestamp;
            this.p2pContactStore.put(account, contact);
        }
        if (!contact) {
            contact = {
                account: account,
                privateName: '',
                publicKey: publicKey,
                publicName: publicName,
                timestamp: 0,
                activityTimestamp: calledTimestamp
            };
            this.p2pContactStore.put(account, contact);
        }
    };
    P2pContactUtils.prototype.updateContactCurrencyAddress = function (account, currency, address, publicKey, publicName, calledTimeStamp) {
        if (!publicKey)
            return;
        var contact = this.p2pContactStore.get(account);
        if (!contact)
            this.saveContact(account, publicKey, publicName, calledTimeStamp);
        var currencyAddressMap = {
            name: currency,
            address: address
        };
        if (!contact.cryptoAddresses) {
            contact.cryptoAddresses = [currencyAddressMap];
        }
        else if (contact.cryptoAddresses.findIndex(function (map) { return map.name === currency; }) === -1) {
            contact.cryptoAddresses.push(currencyAddressMap);
        }
        else {
            contact.cryptoAddresses[contact.cryptoAddresses.findIndex(function (map) { return map.name === currency; })] = currencyAddressMap;
        }
        this.p2pContactStore.put(account, contact);
    };
    P2pContactUtils.prototype.lookupContact = function (query) {
        var deferred = this.$q.defer();
        var isNumbersOnly = P2pContactUtils_1.numbersOnly.test(query);
        if (isNumbersOnly) {
            deferred.resolve(this.searchContactByNumericId(query));
        }
        else {
            deferred.resolve(this.searchContactByPublicName(query));
        }
        return deferred.promise;
    };
    P2pContactUtils.prototype.searchContactByNumericId = function (query) {
        var _this = this;
        var contacts = [];
        var keys = this.p2pContactStore.keys().filter(function (key) { return key.startsWith(query); });
        keys.forEach(function (key) { return contacts.push(_this.p2pContactStore.get(key)); });
        return contacts;
    };
    P2pContactUtils.prototype.searchContactByPublicName = function (query) {
        var _this = this;
        var contacts = [];
        var keys = this.p2pContactStore.keys();
        keys.forEach(function (key) {
            var contact = _this.p2pContactStore.get(key);
            if (contact.publicName.indexOf(query) > -1) {
                contacts.push(contact);
            }
        });
        return contacts;
    };
    P2pContactUtils.prototype.shareCryptoAddress = function (contact, currency, value) {
        var _this = this;
        var validatedCurrency = currency.toLocaleLowerCase();
        this.heat.api.getKeystoreAccountEntry(this.user.key.account, contact.account + "-" + validatedCurrency).then(function (response) {
            var parsed = utils.parseResponse(response);
            if (parsed.errorDescription === 'Unknown key') {
                var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.key.secretPhrase);
                _this.heat.api.saveKeystoreEntry(contact.account + "-" + validatedCurrency, encrypted.data + "-" + encrypted.nonce, _this.user.key.secretPhrase);
            }
            else {
                var split = parsed.value.split("-");
                var decrypted = heat.crypto.decryptMessage(split[0], split[1], contact.publicKey, _this.user.key.secretPhrase);
                if (decrypted == value) {
                    return;
                }
                else {
                    var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.key.secretPhrase);
                    _this.heat.api.saveKeystoreEntry(contact.account + "-" + validatedCurrency, encrypted.data + "-" + encrypted.nonce, _this.user.key.secretPhrase);
                }
            }
        }).catch(function (e) {
            var parsed = utils.parseResponse(e);
            if (parsed.description === 'Unknown key') {
                var encrypted = heat.crypto.encryptMessage(value, contact.publicKey, _this.user.key.secretPhrase);
                _this.heat.api.saveKeystoreEntry(contact.account + "-" + validatedCurrency, encrypted.data + "-" + encrypted.nonce, _this.user.key.secretPhrase);
            }
        });
    };
    P2pContactUtils.prototype.fetchCryptoAddress = function (contact, currency) {
        var _this = this;
        var validatedCurrency = currency.toLocaleLowerCase();
        this.heat.api.getKeystoreAccountEntry(contact.account, this.user.key.account + "-" + validatedCurrency).then(function (response) {
            var parsed = utils.parseResponse(response);
            var split = parsed.value.split("-");
            var decrypted = heat.crypto.decryptMessage(split[0], split[1], contact.publicKey, _this.user.key.secretPhrase);
            console.log('decrypted value: ' + decrypted);
            _this.updateContactCurrencyAddress(contact.account, currency, decrypted, contact.publicKey, contact.publicName);
        }).catch(function (e) {
            console.log("Error getting keystore value of contact " + contact.account + "-" + validatedCurrency, e);
        });
    };
    var P2pContactUtils_1;
    P2pContactUtils.numbersOnly = /^[0-9]+$/;
    P2pContactUtils = P2pContactUtils_1 = __decorate([
        Service('p2pContactUtils'),
        Inject('storage', 'heat', '$q', 'user'),
        __metadata("design:paramtypes", [StorageService,
            HeatService, Function, UserService])
    ], P2pContactUtils);
    return P2pContactUtils;
}());
var p2p;
(function (p2p) {
    var Room = (function () {
        function Room(name, connector, storage, user, memberPublicKeys) {
            this.name = name;
            this.connector = connector;
            this.storage = storage;
            this.user = user;
            this.memberPublicKeys = memberPublicKeys;
            this.state = {
                approved: false,
                entered: "not"
            };
            this.lastIncomingMessageTimestamp = 0;
            this.peers = new Map();
        }
        Room.prototype.enter = function (enforce) {
            this.connector.enter(this, enforce);
            return this;
        };
        Room.prototype.sendMessage = function (message) {
            var count = this.connector.sendMessage(this.name, message);
            if (message.type == "chat") {
                var publicKey = this.user.key ? this.user.key.publicKey : this.user.publicKey;
                var item = { timestamp: message.timestamp, fromPeer: publicKey, content: message.text };
                this.getMessageHistory().put(item);
                if (this.onNewMessageHistoryItem) {
                    this.onNewMessageHistoryItem(item);
                }
            }
            return count;
        };
        Room.prototype.onMessageInternal = function (msg) {
            if (msg.type == "chat") {
                var item = { timestamp: msg.timestamp, fromPeer: msg.fromPeerId, content: msg.text };
                this.getMessageHistory().put(item);
                if (this.onNewMessageHistoryItem) {
                    this.onNewMessageHistoryItem(item);
                }
                this.lastIncomingMessageTimestamp = Date.now();
            }
            if (this.onMessage) {
                this.onMessage(msg);
            }
        };
        Room.prototype.getMessageHistory = function () {
            if (!this.messageHistory) {
                this.messageHistory = new p2p.MessageHistory(this, this.storage, this.user);
            }
            return this.messageHistory;
        };
        Room.prototype.provenPublicKeyAllowed = function (room, peerId, publicKey) {
            if (true)
                return true;
        };
        Room.prototype.getDataChannels = function () {
            var dataChannels = [];
            this.peers.forEach(function (peer) {
                if (peer.dataChannel) {
                    dataChannels.push(peer.dataChannel);
                }
            });
            return dataChannels;
        };
        Room.prototype.getPeer = function (peerId) {
            return this.peers.get(peerId);
        };
        Room.prototype.createPeer = function (peerId, publicKey) {
            if (this.memberPublicKeys.indexOf(publicKey) == -1) {
                return;
            }
            var existingPeer = this.peers.get(peerId);
            if (existingPeer) {
                return existingPeer;
            }
            var p = new RTCPeer(publicKey);
            this.peers.set(peerId, p);
            return p;
        };
        Room.prototype.getAllPeers = function () {
            return this.peers;
        };
        return Room;
    }());
    p2p.Room = Room;
    var RTCPeer = (function () {
        function RTCPeer(publicKey) {
            this.publicKey = publicKey;
        }
        RTCPeer.prototype.isConnected = function () {
            return this.dataChannel && this.dataChannel.readyState == "open";
        };
        return RTCPeer;
    }());
    p2p.RTCPeer = RTCPeer;
})(p2p || (p2p = {}));
var ControlCharRenderService = (function () {
    function ControlCharRenderService() {
    }
    ControlCharRenderService.prototype.toHtml = function (rawText) {
        return this.nl2br(rawText, '<br />');
    };
    ControlCharRenderService.prototype.nl2br = function (str, breakTag) {
        return (str + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag + '$2');
    };
    ControlCharRenderService = __decorate([
        Service('controlCharRender')
    ], ControlCharRenderService);
    return ControlCharRenderService;
}());
var EmojiiRenderService = (function () {
    function EmojiiRenderService() {
    }
    EmojiiRenderService.prototype.toHtml = function (rawText) {
        return rawText;
    };
    EmojiiRenderService = __decorate([
        Service('emojiiRender')
    ], EmojiiRenderService);
    return EmojiiRenderService;
}());
var AssetTransferService = (function (_super) {
    __extends(AssetTransferService, _super);
    function AssetTransferService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AssetTransferService.prototype.dialog = function ($event, recipient, recipientPublicKey, asset, amount, userMessage) {
        return new AssetTransferDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, asset, amount, userMessage);
    };
    AssetTransferService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 2)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return transaction.assetId === data.AssetTransfer.assetId &&
            transaction.quantity === data.AssetTransfer.quantity;
    };
    AssetTransferService = __decorate([
        Service('assetTransfer'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AssetTransferService);
    return AssetTransferService;
}(AbstractTransaction));
var AssetTransferDialog = (function (_super) {
    __extends(AssetTransferDialog, _super);
    function AssetTransferDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, asset, amount, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.asset = asset;
        _this.amount = amount;
        _this.userMessage = userMessage;
        _this.dialogTitle = 'Asset Transfer';
        _this.dialogDescription = 'Description on how to transfer asset';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.asset = _this.asset || '';
        _this.amount = _this.amount || '0';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    AssetTransferDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.fields['message'].changed();
                _this.heat.api.getPublicKeyOrEmptyString(_this.fields['recipient'].value).then(function (publicKey) {
                    if (publicKey == '') {
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                    else {
                        _this.fields['recipientPublicKey'].value = publicKey;
                        $scope.$evalAsync(function () {
                            _this.fields['recipient']['accountExists'] = true;
                        });
                    }
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                    });
                });
            }).
                required(),
            builder.asset('asset', this.asset).
                label('Asset').
                onchange(function () {
                var amountField = _this.fields['amount'];
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                if (assetInfo) {
                    amountField.symbol(assetInfo.symbol);
                    amountField.precision(assetInfo.decimals);
                }
                _this.fields['amount'].changed();
            }).
                validate("You dont own this asset", function () {
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).
                required(),
            builder.money('amount', this.amount).
                label('Amount').
                required().
                precision(8).
                symbol('').
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                if (_this.fields['asset'].value) {
                    _this.heat.api.getAccountBalance(_this.user.account, _this.fields['asset'].value).then(function (balance) {
                        try {
                            var avail = new Big(balance.unconfirmedBalance);
                            var total = new Big(amount);
                            if (avail.gte(total) > 0) {
                                deferred.resolve();
                            }
                            else {
                                deferred.reject();
                            }
                        }
                        catch (e) {
                            deferred.reject();
                        }
                    }, deferred.reject);
                }
                else {
                    deferred.resolve();
                }
                return deferred.promise;
            }),
            builder.text('message', this.userMessage).
                rows(2).
                asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            }).
                label('Message'),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    AssetTransferDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AssetTransfer', {
            assetId: this.fields['asset'].value,
            quantity: this.fields['amount'].value
        });
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return AssetTransferDialog;
}(GenericDialog));
var AssetWithdrawService = (function (_super) {
    __extends(AssetWithdrawService, _super);
    function AssetWithdrawService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    AssetWithdrawService.prototype.getWithdrawFeeInfo = function (asset) {
        var localCache = heat.isTestnet ? {} : {
            "5592059897546023466": {
                feePercentage: 0.4,
                minimumQuantity: "40000",
                notice1: 'Bitcoin withdrawals are usually processed within 1 hour from request.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "12723185826655406325": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'NXT withdrawals are usually processed within 24 hour from requests.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "17622812277075597103": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'ARDOR withdrawals are usually processed within 24 hours from requests.',
                notice2: 'Occasionally longer delays on non-banking days are possible.'
            },
            "8593933499455210945": {
                feePercentage: 0.4,
                minimumQuantity: "500000000",
                notice1: 'FIMK withdrawals are usually processed with 1-12 hours from requests.',
                notice2: 'Occasionally longer delays due to network issues are possible.'
            }
        };
        var deferred = this.$q.defer();
        if (angular.isDefined(localCache[asset]))
            deferred.resolve(localCache[asset]);
        else
            deferred.reject();
        return deferred.promise;
    };
    AssetWithdrawService.prototype.dialog = function ($event, assetInfo, amount) {
        var _this = this;
        var deferred = this.$q.defer();
        if (assetInfo.id == "0")
            deferred.reject();
        this.heat.api.getAsset(assetInfo.id, "0", 1).then(function (asset) {
            var issuer = asset.account;
            _this.heat.api.getPublicKey(issuer).then(function (publicKey) {
                _this.heat.api.getAccountBalance(_this.user.account, assetInfo.id).then(function (balance) {
                    _this.getWithdrawFeeInfo(assetInfo.id).then(function (withdrawInfo) {
                        deferred.resolve(new AssetWithdrawDialog($event, _this, _this.$q, _this.user, _this.heat, issuer, publicKey, assetInfo, withdrawInfo, amount, balance));
                    }, deferred.reject);
                }, deferred.reject);
            }, deferred.reject);
        }, deferred.reject);
        return deferred.promise;
    };
    AssetWithdrawService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 2)
            return false;
        transaction.assetId = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return transaction.assetId === data.AssetTransfer.assetId &&
            transaction.quantity === data.AssetTransfer.quantity;
    };
    AssetWithdrawService = __decorate([
        Service('assetWithdraw'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], AssetWithdrawService);
    return AssetWithdrawService;
}(AbstractTransaction));
var AssetWithdrawDialog = (function (_super) {
    __extends(AssetWithdrawDialog, _super);
    function AssetWithdrawDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, assetInfo, withdrawInfo, amount, userBalance) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.assetInfo = assetInfo;
        _this.withdrawInfo = withdrawInfo;
        _this.amount = amount;
        _this.userBalance = userBalance;
        _this.dialogClass = "withdraw-asset-service";
        _this.dialogTitle = 'Withdraw ' + _this.assetInfo.symbol;
        _this.dialogDescription = 'Description on how to withdraw ' + _this.assetInfo.symbol;
        _this.okBtnTitle = 'WITHDRAW';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.amount = _this.userBalance.unconfirmedBalance || _this.amount || '0';
        return _this;
    }
    AssetWithdrawDialog.prototype.fieldsReady = function ($scope) {
        var _this = this;
        var minFeeFloat = parseFloat(this.withdrawInfo.minimumQuantity + '');
        var amountFloat = parseFloat(this.userBalance.unconfirmedBalance + '');
        if (amountFloat > minFeeFloat) {
            $scope.$evalAsync(function () {
                _this.updateTotalAmountQNT(amountFloat, minFeeFloat);
            });
        }
        this.fields['amount'].changed(true);
    };
    AssetWithdrawDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var balance = utils.formatQNT(this.userBalance.balance, this.userBalance.decimals);
        var userBalanceText = balance + " " + this.assetInfo.symbol + " available on account";
        var feeText = "Processing and network fee " + this.withdrawInfo.feePercentage.toFixed(2) + "% (" + this.assetInfo.symbol + ")";
        var minAmountFormatted = utils.formatQNT(this.withdrawInfo.minimumQuantity, 8);
        var minWithdrawText = "Minimum withdraw fee is " + minAmountFormatted + " " + this.assetInfo.symbol;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.hidden('recipient', this.recipient)
                .required(),
            builder.text('message', '')
                .visible(true)
                .label("Recipient " + this.assetInfo.symbol + " address")
                .required(),
            builder.hidden('asset', this.assetInfo.id)
                .required(),
            builder.money('amount', this.amount)
                .label('Amount')
                .required()
                .precision(this.assetInfo.decimals)
                .symbol(this.assetInfo.symbol).
                asyncValidate("Not enough funds", function (amount) {
                var deferred = _this.$q.defer();
                if (_this.fields['asset'].value) {
                    _this.heat.api.getAccountBalance(_this.user.account, _this.fields['asset'].value).then(function (balance) {
                        try {
                            var avail = new Big(balance.unconfirmedBalance);
                            var total = new Big(amount);
                            if (avail.gte(total) > 0) {
                                deferred.resolve();
                            }
                            else {
                                deferred.reject();
                            }
                        }
                        catch (e) {
                            deferred.reject();
                        }
                    }, deferred.reject);
                }
                else {
                    deferred.resolve();
                }
                return deferred.promise;
            }).
                validate("Minimum amount is " + minAmountFormatted + " " + this.assetInfo.symbol, function (amount) {
                return parseInt(amount) > parseInt(_this.withdrawInfo.minimumQuantity);
            }).
                onchange(function () {
                var amountQNT = parseFloat(_this.fields['amount'].value || '0');
                _this.updateTotalAmountQNT(amountQNT, parseFloat(_this.withdrawInfo.minimumQuantity));
            }),
            builder.hidden('recipientPublicKey', this.recipientPublicKey),
            builder.text('youWillReceive', '0')
                .label('You will receive')
                .readonly(true),
            builder.staticText('feeText', feeText),
            builder.staticText('totalFeeText', 'Total fee: '),
            builder.staticText('minWithdrawText', minWithdrawText),
            builder.staticText('withdrawalNotice1', this.withdrawInfo.notice1),
            builder.staticText('withdrawalNotice2', this.withdrawInfo.notice2)
        ];
    };
    AssetWithdrawDialog.prototype.updateTotalAmountQNT = function (amountFloat, minFeeFloat) {
        if (amountFloat <= 0) {
            this.fields['youWillReceive'].value = '0';
            this.fields['totalFeeText'].value = "Total fee " + utils.formatQNT(Math.round(minFeeFloat) + '', 8) + " " + this.assetInfo.symbol;
        }
        else {
            var multiplier = 1.0 - (this.withdrawInfo.feePercentage / 100);
            var received = Math.round(amountFloat * multiplier);
            var totalFee = amountFloat - received;
            if (totalFee < minFeeFloat) {
                totalFee = minFeeFloat;
                received = Math.round(amountFloat - minFeeFloat);
            }
            this.fields['youWillReceive'].value = received < 0 ? '0' : utils.formatQNT(received + '', 8);
            this.fields['totalFeeText'].value = "Total fee " + utils.formatQNT(totalFee + '', 8) + " " + this.assetInfo.symbol;
        }
    };
    AssetWithdrawDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AssetTransfer', {
            assetId: this.fields['asset'].value,
            quantity: this.fields['amount'].value
        });
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return AssetWithdrawDialog;
}(GenericDialog));
var BalanceLeaseService = (function (_super) {
    __extends(BalanceLeaseService, _super);
    function BalanceLeaseService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    BalanceLeaseService.prototype.dialog = function (period, recipient, $event) {
        return new BalanceLeaseDialog($event, this, this.$q, this.user, this.heat, period, recipient);
    };
    BalanceLeaseService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 4)
            return false;
        if (transaction.subtype !== 0)
            return false;
        transaction.period = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        return transaction.period === data.EffectiveBalanceLeasing.period;
    };
    BalanceLeaseService = __decorate([
        Service('balanceLease'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], BalanceLeaseService);
    return BalanceLeaseService;
}(AbstractTransaction));
var BalanceLeaseDialog = (function (_super) {
    __extends(BalanceLeaseDialog, _super);
    function BalanceLeaseDialog($event, transaction, $q, user, heat, period, recipient) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.period = period;
        _this.recipient = recipient;
        _this.dialogTitle = 'Balance Lease';
        _this.dialogDescription = 'Description on how to lease balance';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    BalanceLeaseDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                required(),
            builder.text('period', this.period).
                label('Period (number of blocks)').
                required()
        ];
    };
    BalanceLeaseDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .recipient(this.fields['recipient'].value)
            .attachment('EffectiveBalanceLeasing', {
            period: parseInt(this.fields['period'].value)
        });
        return builder;
    };
    return BalanceLeaseDialog;
}(GenericDialog));
var CancelAskOrderService = (function (_super) {
    __extends(CancelAskOrderService, _super);
    function CancelAskOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    CancelAskOrderService.prototype.dialog = function (order, readonly, $event) {
        return new CancelAskOrderDialog($event, this, this.$q, this.user, order, readonly);
    };
    CancelAskOrderService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 5)
            return false;
        transaction.order = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return transaction.order === data.AskOrderCancellation.orderId;
    };
    CancelAskOrderService = __decorate([
        Service('cancelAskOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], CancelAskOrderService);
    return CancelAskOrderService;
}(AbstractTransaction));
var CancelAskOrderDialog = (function (_super) {
    __extends(CancelAskOrderDialog, _super);
    function CancelAskOrderDialog($event, transaction, $q, user, order, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.order = order;
        _this.readonly = readonly;
        _this.dialogTitle = 'Cancel ask order';
        _this.dialogDescription = 'Description on how to cancel ask order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    CancelAskOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('order', this.order).
                label('Order').
                required().
                readonly(this.readonly)
        ];
    };
    CancelAskOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AskOrderCancellation', {
            orderId: this.fields['order'].value
        });
        return builder;
    };
    return CancelAskOrderDialog;
}(GenericDialog));
var CancelBidOrderService = (function (_super) {
    __extends(CancelBidOrderService, _super);
    function CancelBidOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    CancelBidOrderService.prototype.dialog = function (order, readonly, $event) {
        return new CancelBidOrderDialog($event, this, this.$q, this.user, order, readonly);
    };
    CancelBidOrderService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 6)
            return false;
        transaction.order = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return transaction.order === data.BidOrderCancellation.orderId;
    };
    CancelBidOrderService = __decorate([
        Service('cancelBidOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], CancelBidOrderService);
    return CancelBidOrderService;
}(AbstractTransaction));
var CancelBidOrderDialog = (function (_super) {
    __extends(CancelBidOrderDialog, _super);
    function CancelBidOrderDialog($event, transaction, $q, user, order, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.order = order;
        _this.readonly = readonly;
        _this.dialogTitle = 'Cancel bid order';
        _this.dialogDescription = 'Description on how to cancel bid order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    CancelBidOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('order', this.order).
                label('Order').
                required().
                readonly(this.readonly)
        ];
    };
    CancelBidOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('BidOrderCancellation', {
            orderId: this.fields['order'].value
        });
        return builder;
    };
    return CancelBidOrderDialog;
}(GenericDialog));
var MasternodeService = (function (_super) {
    __extends(MasternodeService, _super);
    function MasternodeService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    MasternodeService.prototype.dialog = function ($event) {
        return new RegisterInternetAddressDialog($event, this, this.$q, this.user, this.heat, "");
    };
    MasternodeService.prototype.verify = function (transaction, bytes, data) {
        if (!AbstractTransaction.checkType(transaction, 4, 1))
            return false;
        var len = bytes.byteArray[bytes.pos];
        bytes.pos += 1;
        transaction.internetAddress = converters.byteArrayToString(bytes.byteArray, bytes.pos, len);
        bytes.pos += len;
        return transaction.internetAddress === data.InternetAddress.internetAddress;
    };
    MasternodeService = __decorate([
        Service('masternode'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], MasternodeService);
    return MasternodeService;
}(AbstractTransaction));
var RegisterInternetAddressDialog = (function (_super) {
    __extends(RegisterInternetAddressDialog, _super);
    function RegisterInternetAddressDialog($event, transaction, $q, user, heat, internetAddress) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.internetAddress = internetAddress;
        _this.dialogTitle = 'Register Masternode Address';
        _this.dialogDescription = 'Register Internet Address to be Masternode';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.registerInternetAddressFee, 8).replace(/000000$/, '');
        return _this;
    }
    RegisterInternetAddressDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder
                .text('internetAddress', this.internetAddress)
                .label('IP address or domain name')
                .required(),
            builder.staticText('note1', "MASTERNODE REGISTRATION WILL BECOME AVAILABLE AT BLOCK 2700000 (approx. 2019-08-10)"),
            builder.staticText('note2', "Minimum stake for Masternode to receive POP reward at block generation is 1000 HEAT"),
            builder.staticText('feeText', "NOTICE: Masternode registration will expire after 311040  blocks (~90 days). To keep receiving POP rewards you will need to re-register at that time"),
        ];
    };
    RegisterInternetAddressDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .recipient(this.user.account)
            .feeNQT(HeatAPI.fee.registerInternetAddressFee)
            .attachment('InternetAddress', {
            internetAddress: this.fields['internetAddress'].value
        });
        return builder;
    };
    return RegisterInternetAddressDialog;
}(GenericDialog));
var PlaceAskOrderService = (function (_super) {
    __extends(PlaceAskOrderService, _super);
    function PlaceAskOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    PlaceAskOrderService.prototype.dialog = function (currencyInfo, assetInfo, price, quantity, expiration, readonly, $event) {
        return new PlaceAskOrderDialog($event, this, this.$q, this.user, currencyInfo, assetInfo, price, quantity, expiration, readonly);
    };
    PlaceAskOrderService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 3)
            return false;
        transaction.currency = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.asset = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.price = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.expiration = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        return transaction.currency === data.AskOrderPlacement.currencyId &&
            transaction.asset === data.AskOrderPlacement.assetId &&
            transaction.quantity === data.AskOrderPlacement.quantity &&
            transaction.price === data.AskOrderPlacement.price &&
            transaction.expiration === data.AskOrderPlacement.expiration;
    };
    PlaceAskOrderService = __decorate([
        Service('placeAskOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], PlaceAskOrderService);
    return PlaceAskOrderService;
}(AbstractTransaction));
var PlaceAskOrderDialog = (function (_super) {
    __extends(PlaceAskOrderDialog, _super);
    function PlaceAskOrderDialog($event, transaction, $q, user, currencyInfo, assetInfo, price, quantity, expiration, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.currencyInfo = currencyInfo;
        _this.assetInfo = assetInfo;
        _this.price = price;
        _this.quantity = quantity;
        _this.expiration = expiration;
        _this.readonly = readonly;
        _this.dialogTitle = 'Place ask order';
        _this.dialogDescription = 'Description on how to place ask order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    PlaceAskOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('currency', this.currencyInfo.id).
                label('Currency').
                required().
                readonly(this.readonly),
            builder.text('asset', this.assetInfo.id).
                label('Asset').
                required().
                readonly(this.readonly),
            builder.text('price', this.price).
                label('Price').
                required().
                readonly(this.readonly),
            builder.text('quantity', this.quantity).
                label('Amount').
                required().
                readonly(this.readonly),
            builder.text('expiration', this.expiration).
                label('Expiration').
                required().
                readonly(this.readonly)
        ];
    };
    PlaceAskOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('AskOrderPlacement', {
            currencyId: this.fields['currency'].value,
            assetId: this.fields['asset'].value,
            price: utils.convertToQNT(this.fields['price'].value),
            quantity: utils.convertToQNT(this.fields['quantity'].value),
            expiration: this.fields['expiration'].value
        });
        return builder;
    };
    return PlaceAskOrderDialog;
}(GenericDialog));
var PlaceBidOrderService = (function (_super) {
    __extends(PlaceBidOrderService, _super);
    function PlaceBidOrderService($q, user) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        return _this;
    }
    PlaceBidOrderService.prototype.dialog = function (currencyInfo, assetInfo, price, quantity, expiration, readonly, $event) {
        return new PlaceBidOrderDialog($event, this, this.$q, this.user, currencyInfo, assetInfo, price, quantity, expiration, readonly);
    };
    PlaceBidOrderService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 4)
            return false;
        transaction.currency = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.asset = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.quantity = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.price = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.expiration = converters.byteArrayToSignedInt32(bytes.byteArray, bytes.pos);
        bytes.pos += 4;
        return transaction.currency === data.BidOrderPlacement.currencyId &&
            transaction.asset === data.BidOrderPlacement.assetId &&
            transaction.quantity === data.BidOrderPlacement.quantity &&
            transaction.price === data.BidOrderPlacement.price &&
            transaction.expiration === data.BidOrderPlacement.expiration;
    };
    PlaceBidOrderService = __decorate([
        Service('placeBidOrder'),
        Inject('$q', 'user'),
        __metadata("design:paramtypes", [Function, UserService])
    ], PlaceBidOrderService);
    return PlaceBidOrderService;
}(AbstractTransaction));
var PlaceBidOrderDialog = (function (_super) {
    __extends(PlaceBidOrderDialog, _super);
    function PlaceBidOrderDialog($event, transaction, $q, user, currencyInfo, assetInfo, price, quantity, expiration, readonly) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.currencyInfo = currencyInfo;
        _this.assetInfo = assetInfo;
        _this.price = price;
        _this.quantity = quantity;
        _this.expiration = expiration;
        _this.readonly = readonly;
        _this.dialogTitle = 'Place bid order';
        _this.dialogDescription = 'Description on how to place bid order';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        return _this;
    }
    PlaceBidOrderDialog.prototype.getFields = function ($scope) {
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.text('currency', this.currencyInfo.id).
                label('Currency').
                required().
                readonly(this.readonly),
            builder.text('asset', this.assetInfo.id).
                label('Asset').
                required().
                readonly(this.readonly),
            builder.text('price', this.price).
                label('Price').
                required().
                readonly(this.readonly),
            builder.text('quantity', this.quantity).
                label('Amount').
                required().
                readonly(this.readonly),
            builder.text('expiration', this.expiration).
                label('Expiration').
                required().
                readonly(this.readonly)
        ];
    };
    PlaceBidOrderDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('BidOrderPlacement', {
            currencyId: this.fields['currency'].value,
            assetId: this.fields['asset'].value,
            price: utils.convertToQNT(this.fields['price'].value),
            quantity: utils.convertToQNT(this.fields['quantity'].value),
            expiration: this.fields['expiration'].value
        });
        return builder;
    };
    return PlaceBidOrderDialog;
}(GenericDialog));
var SendmessageService = (function (_super) {
    __extends(SendmessageService, _super);
    function SendmessageService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    SendmessageService.prototype.dialog = function ($event, recipient, recipientPublicKey, userMessage) {
        return new SendmessageDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey, userMessage);
    };
    SendmessageService.prototype.verify = function (transaction, bytes) {
        return transaction.type === 1 && transaction.subtype === 0;
    };
    SendmessageService = __decorate([
        Service('sendmessage'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], SendmessageService);
    return SendmessageService;
}(AbstractTransaction));
var SendmessageDialog = (function (_super) {
    __extends(SendmessageDialog, _super);
    function SendmessageDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey, userMessage) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.userMessage = userMessage;
        _this.dialogTitle = 'Send Message';
        _this.dialogDescription = 'Description on how to send message';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.standard, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    SendmessageDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.account('recipient', this.recipient).
                label('Recipient').
                onchange(function () {
                _this.fields['recipientPublicKey'].value = null;
                _this.fields['message'].changed();
                _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                    _this.fields['recipientPublicKey'].value = publicKey;
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = true;
                        _this.fields['messagWarning'].visible(false);
                    });
                }, function () {
                    $scope.$evalAsync(function () {
                        _this.fields['recipient']['accountExists'] = false;
                        _this.fields['messagWarning'].visible(true);
                    });
                });
            }).
                required(),
            builder.staticText('messagWarning', 'Message field will be visible only if the receiver account is known by the HEAT p2p network.')
                .visible(true),
            builder.text('message', this.userMessage).
                rows(2).
                asyncValidate("No recipient public key", function (message) {
                var deferred = _this.$q.defer();
                if (String(message).trim().length == 0) {
                    deferred.resolve();
                }
                else {
                    if (_this.fields['recipientPublicKey'].value) {
                        deferred.resolve();
                    }
                    else {
                        _this.heat.api.getPublicKey(_this.fields['recipient'].value).then(function (publicKey) {
                            _this.fields['recipientPublicKey'].value = publicKey;
                            deferred.resolve();
                        }, deferred.reject);
                    }
                }
                return deferred.promise;
            }).
                label('Message'),
            builder.hidden('recipientPublicKey', this.recipientPublicKey)
        ];
    };
    SendmessageDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.standard)
            .attachment('ArbitraryMessage', {});
        builder.recipient(this.fields['recipient'].value);
        builder.recipientPublicKey(this.fields['recipientPublicKey'].value);
        if (this.fields['message'].value) {
            builder.message(this.fields['message'].value, TransactionMessageType.TO_RECIPIENT);
        }
        return builder;
    };
    return SendmessageDialog;
}(GenericDialog));
var WhitelistMarketService = (function (_super) {
    __extends(WhitelistMarketService, _super);
    function WhitelistMarketService($q, user, heat) {
        var _this = _super.call(this) || this;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        return _this;
    }
    WhitelistMarketService.prototype.dialog = function ($event, recipient, recipientPublicKey) {
        return new WhitelistMarketferDialog($event, this, this.$q, this.user, this.heat, recipient, recipientPublicKey);
    };
    WhitelistMarketService.prototype.verify = function (transaction, bytes, data) {
        if (transaction.type !== 2)
            return false;
        if (transaction.subtype !== 9)
            return false;
        transaction.currencyId = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        transaction.assetId = String(converters.byteArrayToBigInteger(bytes.byteArray, bytes.pos));
        bytes.pos += 8;
        return transaction.currencyId === data.WhitelistMarket.currencyId &&
            transaction.assetId === data.WhitelistMarket.assetId;
    };
    WhitelistMarketService = __decorate([
        Service('whitelistMarket'),
        Inject('$q', 'user', 'heat'),
        __metadata("design:paramtypes", [Function, UserService,
            HeatService])
    ], WhitelistMarketService);
    return WhitelistMarketService;
}(AbstractTransaction));
var WhitelistMarketferDialog = (function (_super) {
    __extends(WhitelistMarketferDialog, _super);
    function WhitelistMarketferDialog($event, transaction, $q, user, heat, recipient, recipientPublicKey) {
        var _this = _super.call(this, $event) || this;
        _this.transaction = transaction;
        _this.$q = $q;
        _this.user = user;
        _this.heat = heat;
        _this.recipient = recipient;
        _this.recipientPublicKey = recipientPublicKey;
        _this.dialogTitle = 'Whitelist Market';
        _this.dialogDescription = 'Description on how to whitelist a market';
        _this.okBtnTitle = 'SEND';
        _this.feeFormatted = utils.formatQNT(HeatAPI.fee.whitelistMarket, 8).replace(/000000$/, '');
        _this.recipient = _this.recipient || '';
        _this.recipientPublicKey = _this.recipientPublicKey || null;
        return _this;
    }
    WhitelistMarketferDialog.prototype.getFields = function ($scope) {
        var _this = this;
        var builder = new DialogFieldBuilder($scope);
        return [
            builder.asset('asset').
                label('Your asset').
                validate("You dont own this asset", function (value) {
                if (value == "0")
                    return true;
                var assetField = _this.fields['asset'];
                var assetInfo = assetField.getAssetInfo(_this.fields['asset'].value);
                return !!assetInfo;
            }).
                required(),
            builder.asset('currency').
                label('Allow market').
                searchAllAssets(true).
                required(),
        ];
    };
    WhitelistMarketferDialog.prototype.getTransactionBuilder = function () {
        var builder = new TransactionBuilder(this.transaction);
        builder.secretPhrase(this.user.secretPhrase)
            .feeNQT(HeatAPI.fee.whitelistMarket)
            .attachment('WhitelistMarket', {
            assetId: this.fields['asset'].value,
            currencyId: this.fields['currency'].value
        });
        return builder;
    };
    return WhitelistMarketferDialog;
}(GenericDialog));
var ArdorAccountComponent = (function () {
    function ArdorAccountComponent($scope, ardorBlockExplorerService, ardorPendingTransactions, $interval, $mdToast, settings, user) {
        var _this = this;
        this.$scope = $scope;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.ardorPendingTransactions = ardorPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        ardorPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            ardorPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
        this.sockets = [
            {
                name: 'HEAT_Ardr_node',
                socketUrl: 'https://bitnode.heatwallet.com:27876/'
            },
            {
                name: 'Localhost',
                socketUrl: 'http://localhost:27876/'
            }
        ];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.ardorBlockExplorerService.getSocketUrl() == w.socketUrl; }).name;
    }
    ArdorAccountComponent.prototype.changeSocketAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.ardorBlockExplorerService.setUrl(ret.socketUrl);
    };
    ArdorAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_1 = this.pendingTransactions[this.prevIndex];
            this.ardorBlockExplorerService.getTransactionStatus(pendingTxn_1.fullHash).then(function (data) {
                if (data.confirmations) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id " + pendingTxn_1.txId + " found").hideDelay(2000));
                    _this.ardorPendingTransactions.remove(pendingTxn_1.address, pendingTxn_1.txId, pendingTxn_1.time, pendingTxn_1.fullHash);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    ArdorAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.ardorPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr,
                        fullHash: tx.fullHash
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    ArdorAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.ardorBlockExplorerService.getBalance(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(utils.convertToQNTf(info)).toFixed(8);
                _this.busy = false;
            });
        });
    };
    ArdorAccountComponent = __decorate([
        RouteConfig('/ardor-account/:account'),
        Component({
            selector: 'ardorAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/ardor-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} ARDR\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              ARDOR Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeSocketAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-ardor-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-ardor-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'ardorBlockExplorerService', 'ardorPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, ArdorBlockExplorerService,
            ArdorPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], ArdorAccountComponent);
    return ArdorAccountComponent;
}());
var BitcoinAccountComponent = (function () {
    function BitcoinAccountComponent($scope, btcBlockExplorerService, bitcoinPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.btcBlockExplorerService = btcBlockExplorerService;
        this.bitcoinPendingTransactions = bitcoinPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        bitcoinPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            bitcoinPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
    }
    BitcoinAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_2 = this.pendingTransactions[this.prevIndex];
            this.btcBlockExplorerService.getTxInfo(pendingTxn_2.txId).then(function (data) {
                if (data.blockheight !== -1) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id " + pendingTxn_2.txId + " found").hideDelay(2000));
                    _this.bitcoinPendingTransactions.remove(pendingTxn_2.address, pendingTxn_2.txId, pendingTxn_2.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    BitcoinAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.bitcoinPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    BitcoinAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.btcBlockExplorerService.getBalance(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(info / 100000000).toFixed(8);
                _this.busy = false;
            });
        });
    };
    BitcoinAccountComponent = __decorate([
        RouteConfig('/bitcoin-account/:account'),
        Component({
            selector: 'bitcoinAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/bitcoin-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} BTC\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col tx-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col tx-col left\" flex>\n                <a target=\"_blank\" href=\"https://live.blockcypher.com/btc/tx/{{item.txId}}\">{{item.txId}}</a>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-btc-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-btc-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'btcBlockExplorerService', 'bitcoinPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, BtcBlockExplorerService,
            BitcoinPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], BitcoinAccountComponent);
    return BitcoinAccountComponent;
}());
var FimkAccountComponent = (function () {
    function FimkAccountComponent($scope, mofoSocketService, fimkPendingTransactions, $interval, $mdToast, settings, user) {
        var _this = this;
        this.$scope = $scope;
        this.mofoSocketService = mofoSocketService;
        this.fimkPendingTransactions = fimkPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.selectSocketEndPoint = 'Mofowallet';
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        fimkPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            fimkPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
        this.sockets = [
            {
                name: 'Mofowallet',
                socketUrl: 'wss://cloud.mofowallet.org:7986/ws/'
            },
            {
                name: 'Localhost',
                socketUrl: 'ws://localhost:7986/ws/'
            }
        ];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.mofoSocketService.getSocketUrl() == w.socketUrl; }).name;
    }
    FimkAccountComponent.prototype.changeSocketAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.mofoSocketService.mofoSocket(ret.socketUrl);
    };
    FimkAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.mofoSocketService.getRecentTx(this.user.account).then(function (recentTransactions) {
                for (var i = 0; i < _this.pendingTransactions.length; i++) {
                    var isPending = false;
                    for (var j = 0; j < recentTransactions.length; j++) {
                        if (recentTransactions[j].transaction == _this.pendingTransactions[i].txId) {
                            isPending = true;
                            break;
                        }
                    }
                    if (!isPending) {
                        _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id " + _this.pendingTransactions[i].txId + " found").hideDelay(2000));
                        _this.fimkPendingTransactions.remove(_this.pendingTransactions[i].address, _this.pendingTransactions[i].txId, _this.pendingTransactions[i].time);
                    }
                }
            }, function (err) {
                console.log('Error in getting recent FIMK Transactions ' + err);
            });
        }
    };
    FimkAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.fimkPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    FimkAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.mofoSocketService.getAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                var balance = info.unconfirmedBalanceNQT ? parseInt(info.unconfirmedBalanceNQT) / 100000000 : 0;
                var formattedBalance = new Big(balance + "");
                _this.balanceUnconfirmed = new Big(formattedBalance).toFixed(8);
                _this.busy = false;
            });
        });
    };
    FimkAccountComponent = __decorate([
        RouteConfig('/fimk-account/:account'),
        Component({
            selector: 'fimkAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/fimk-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} FIM\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              FIMK Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeSocketAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-fimk-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-fimk-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'mofoSocketService', 'fimkPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, MofoSocketService,
            FimkPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], FimkAccountComponent);
    return FimkAccountComponent;
}());
var RewardsProviderFactory = (function () {
    function RewardsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    RewardsProviderFactory.prototype.createProvider = function () {
        return new RewardsProvider(this.heat, this.$q);
    };
    RewardsProviderFactory = __decorate([
        Service('rewardsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], RewardsProviderFactory);
    return RewardsProviderFactory;
}());
var RewardsProvider = (function () {
    function RewardsProvider(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    RewardsProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.rewardsListCount();
    };
    RewardsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.rewardsList(firstIndex, lastIndex);
    };
    return RewardsProvider;
}());
var SearchAccountsProviderFactory = (function () {
    function SearchAccountsProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    SearchAccountsProviderFactory.prototype.createProvider = function (query) {
        return new SearchAccountsProvider(this.heat, this.$q, query);
    };
    SearchAccountsProviderFactory = __decorate([
        Service('searchAccountsProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], SearchAccountsProviderFactory);
    return SearchAccountsProviderFactory;
}());
var SearchAccountsProvider = (function () {
    function SearchAccountsProvider(heat, $q, query) {
        this.heat = heat;
        this.$q = $q;
        this.query = query;
    }
    SearchAccountsProvider.prototype.getPaginatedLength = function () {
        return this.heat.api.searchAccountsCount(this.query);
    };
    SearchAccountsProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        return this.heat.api.searchAccounts(this.query, firstIndex, lastIndex);
    };
    return SearchAccountsProvider;
}());
var ExploreAccountComponent = (function () {
    function ExploreAccountComponent($scope, heat, assetInfo, $q) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.$q = $q;
        this.assetInfos = [];
        this.refresh();
        heat.subscriber.balanceChanged({ account: this.account, currency: "0" }, function () {
            _this.refresh();
        }, $scope);
    }
    ExploreAccountComponent.prototype.csv = function ($event) {
        dialogs.download($event, this.account);
    };
    ExploreAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.accountName = "*";
        this.email = "*";
        this.publicKey = "*";
        this.firstSeen = "*";
        this.lease = "*";
        this.leaseBlocksRemain = "*";
        this.totalRewards = "*";
        this.effectiveBalance = "*";
        this.balanceUnconfirmed = "*";
        this.balanceConfirmed = "*";
        this.heat.api.getPublicKey(this.account).then(function (publicKey) {
            _this.$scope.$evalAsync(function () {
                _this.publicKey = publicKey;
            });
        });
        this.heat.api.getAccountByNumericId(this.account).then(function (account) {
            _this.$scope.$evalAsync(function () {
                _this.accountName = account.publicName;
                _this.balanceConfirmed = utils.formatQNT(account.balance, 8);
                _this.effectiveBalance = utils.formatQNT(account.effectiveBalance, 8);
                _this.balanceUnconfirmed = utils.formatQNT(account.unconfirmedBalance, 8);
                _this.currentLessee = account.currentLessee;
                _this.currentLesseeName = account.currentLesseeName || account.currentLessee;
                _this.currentLeasingHeightFrom = account.currentLeasingHeightFrom;
                _this.currentLeasingHeightTo = account.currentLeasingHeightTo;
                _this.nextLessee = account.nextLessee;
                _this.nextLesseeName = account.nextLesseeName || account.nextLessee;
                _this.nextLeasingHeightFrom = account.nextLeasingHeightFrom;
                _this.nextLeasingHeightTo = account.nextLeasingHeightTo;
                _this.lessors = account.lessors;
                if (angular.isArray(_this.lessors)) {
                    _this.lessors.forEach(function (lessor) {
                        lessor.balance = utils.formatQNT(lessor.effectiveBalance, 8) + " HEAT";
                        if (lessor.nextLessee == "0") {
                            lessor.nextLessee = "";
                        }
                        if (lessor.nextHeightFrom == 2147483647 || lessor.nextHeightFrom == lessor.currentHeightFrom) {
                            lessor.nextHeightFrom = "";
                        }
                        if (lessor.nextHeightTo == 2147483647) {
                            lessor.nextHeightTo = "";
                        }
                    });
                }
            });
            if (_this.currentLessee != "0") {
                _this.heat.api.getBlockchainStatus().then(function (status) {
                    _this.$scope.$evalAsync(function () {
                        _this.currentLeasingRemain = status.lastBlockchainFeederHeight - account.currentLeasingHeightTo;
                        _this.leaseTitle = "from " + _this.currentLeasingHeightFrom + " to " + _this.currentLeasingHeightTo + " remain " + _this.currentLeasingRemain;
                        _this.nextLeaseTitle = "from " + _this.nextLeasingHeightFrom + " to " + _this.nextLeasingHeightTo;
                    });
                });
            }
        });
        this.getAccountAssets().then(function (assetInfos) {
            _this.$scope.$evalAsync(function () {
                _this.assetInfos = assetInfos
                    .filter(function (info) { return parseFloat(info.userBalance) !== 0; })
                    .map(function (info) {
                    info['balance'] = utils.formatQNT(info.userBalance, 8);
                    return info;
                });
            });
        });
        this.heat.api.rewardsAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.totalRewards = utils.commaFormat(utils.formatQNT(info.totalRewards, 8));
            });
        });
    };
    ExploreAccountComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    ExploreAccountComponent.prototype.getAccountAssets = function () {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalances(this.account, "0", 1, 0, 100).then(function (balances) {
            var assetInfos = [];
            var promises = [];
            balances.forEach(function (balance) {
                if (balance.id != '0') {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info) {
                        assetInfos.push(angular.extend(info, {
                            userBalance: balance.virtualBalance
                        }));
                    }));
                }
            });
            if (promises.length > 0) {
                _this.$q.all(promises).then(function () {
                    assetInfos.sort(function (a, b) {
                        var textA = a.symbol.toUpperCase();
                        var textB = b.symbol.toUpperCase();
                        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
                    });
                    deferred.resolve(assetInfos);
                }, deferred.reject);
            }
            else {
                deferred.resolve([]);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    ExploreAccountComponent = __decorate([
        RouteConfig('/explorer-account/:account/:type'),
        Component({
            selector: 'explorerAccount',
            inputs: ['account', 'type'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Account:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.account}}/{{vm.type}}\">{{vm.accountName||vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Numeric account id:\n            </div>\n            <div class=\"value\">\n              {{vm.account}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} HEAT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Effective bal:\n            </div>\n            <div class=\"value\">\n              {{vm.effectiveBalance}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Lease: [{{vm.leaseTitle}}]\n            </div>\n            <div class=\"value\">\n              <span ng-if=\"vm.currentLessee=='0'\">None</span>\n              <span ng-if=\"vm.currentLessee!='0'\">\n                <a href=\"#/explorer-account/{{vm.currentLessee}}/{{vm.type}}\">{{vm.currentLesseeName}}</a>\n              </span>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Next lease: [{{vm.nextLeaseTitle}}]\n            </div>\n            <div class=\"value\">\n              <span ng-if=\"vm.nextLessee=='0'\">None</span>\n              <span ng-if=\"vm.nextLessee!='0'\">\n                <a href=\"#/explorer-account/{{vm.nextLessee}}/{{vm.type}}\">{{vm.nextLesseeName}}</a>\n              </span>\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total rewards:\n            </div>\n            <div class=\"value\">\n              {{vm.totalRewards}}\n            </div>\n          </div>\n          <div class=\"col-item\" flex layout-fill>\n            <div class=\"title\">\n              Assets:\n            </div>\n            <div class=\"scrollable\">\n              <div class=\"value\" ng-repeat=\"item in vm.assetInfos\">\n                <span class=\"balance\">{{item.balance}}</span>\n                <span class=\"symbol\"><b>{{item.symbol}}</b></span>\n                <span class=\"name\">\n                  <a ng-click=\"vm.showDescription($event, item)\">{{item.name}}</a>\n                </span>\n                <span class=\"issuer\">\n                  Issued by: <a href=\"#/explorer-account/{{item.issuer}}/{{vm.type}}\">{{item.issuerPublicName||item.issuer}}</a>\n                </span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div layout=\"row\" layout-align=\"start center\" class=\"type-row\">\n        <md-button ng-class=\"{'active':vm.type=='accounts'}\"\n          ng-disabled=\"vm.type=='transactions'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/transactions\">Transactions</md-button>\n        <md-button ng-class=\"{'active':vm.type=='blocks'}\"\n          ng-disabled=\"vm.type=='blocks'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/blocks\">Blocks</md-button>\n        <md-button ng-class=\"{'active':vm.type=='lessors'}\"\n          ng-disabled=\"vm.type=='lessors'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/lessors\">Lessors</md-button>\n        <md-button ng-class=\"{'active':vm.type=='trades'}\"\n          ng-disabled=\"vm.type=='trades'\"\n          ng-href=\"#/explorer-account/{{vm.account}}/trades\">Trades</md-button>\n        <span flex></span>\n        <md-button ng-click=\"vm.csv($event)\">Download CSV</md-button>\n      </div>\n      <div ng-if=\"vm.type=='transactions'\" flex layout=\"column\">\n        <virtual-repeat-transactions hide-label=\"true\" layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-transactions>\n      </div>\n      <div ng-if=\"vm.type=='blocks'\" flex layout=\"column\">\n        <explorer-latest-blocks layout=\"column\" flex account=\"vm.account\" hide-label=\"true\"></explorer-latest-blocks>\n      </div>\n      <div ng-if=\"vm.type=='trades'\" flex layout=\"column\">\n        <virtual-repeat-trades hide-label=\"true\" layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-trades>\n      </div>\n      <div ng-if=\"vm.type=='lessors'\" flex layout=\"column\" layout-fill>\n        <md-list flex layout-fill layout=\"column\" class=\"lessors\">\n          <md-list-item class=\"header\">\n            <div class=\"truncate-col id-col left\">ID</div>\n            <div class=\"truncate-col balance-col left\">Balance</div>\n            <div class=\"truncate-col from-col left\">From</div>\n            <div class=\"truncate-col to-col left\">To</div>\n            <div class=\"truncate-col next-lessee-col\">Next</div>\n            <div class=\"truncate-col from-col\">From</div>\n            <div class=\"truncate-col to-col\" flex>To</div>\n          </md-list-item>\n          <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n            <md-list-item md-virtual-repeat=\"item in vm.lessors\" aria-label=\"Entry\">\n              <div class=\"truncate-col id-col left\">\n                <a href=\"#/explorer-account/{{item.id}}/transactions\">{{item.id}}</a>\n              </div>\n              <div class=\"truncate-col balance-col\">\n                {{item.balance}}\n              </div>\n              <div class=\"truncate-col from-col left\">\n                {{item.currentHeightFrom}}\n              </div>\n              <div class=\"truncate-col to-col left\">\n                {{item.currentHeightTo}}\n              </div>\n              <div class=\"truncate-col next-lessee-col\">\n                <a ng-if=\"item.nextLessee\" href=\"#/explorer-account/{{item.nextLessee}}/transactions\">{{item.nextLessee}}</a>\n              </div>\n              <div class=\"truncate-col from-col\">\n                {{item.nextHeightFrom}}\n              </div>\n              <div class=\"truncate-col to-col\" flex>\n                {{item.nextHeightTo}}\n              </div>\n            </md-list-item>\n          </md-virtual-repeat-container>\n        </md-list>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', 'assetInfo', '$q'),
        __metadata("design:paramtypes", [Object, HeatService,
            AssetInfoService, Function])
    ], ExploreAccountComponent);
    return ExploreAccountComponent;
}());
var ExplorerBlockComponent = (function () {
    function ExplorerBlockComponent($scope, heat, settings) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.settings = settings;
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        heat.api.getBlock(this.block).then(function (block) {
            $scope.$evalAsync(function () {
                _this.generator = block.generator;
                _this.generatorPublicName = block['generatorPublicName'];
                _this.totalAmount = utils.formatQNT(block.totalAmountHQT, 8);
                _this.totalFee = utils.formatQNT(block.totalFeeHQT, 8);
                _this.popReward = utils.formatQNT(block.popRewardHQT, 8);
                _this.posReward = utils.formatQNT(block.posRewardHQT, 8);
                var date = utils.timestampToDate(block.timestamp);
                _this.time = dateFormat(date, format);
                _this.height = block.height;
                _this.blockObject = block;
            });
        });
    }
    ExplorerBlockComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Block: ' + item.block);
    };
    ExplorerBlockComponent = __decorate([
        RouteConfig('/explorer-block/:block'),
        Component({
            selector: 'explorerBlock',
            inputs: ['block'],
            styles: ["\n    explorer-block h3 {\n      font-size: 24px !important;\n      font-weight: bold;\n      padding-bottom: 0px;\n      margin-bottom: 0px;\n    }\n    explorer-block a {\n      cursor: pointer;\n    }\n    explorer-block a i {\n      font-size: 14px !important;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill layout-padding >\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Height:\n            </div>\n            <div class=\"value\">\n              {{vm.height}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Time:\n            </div>\n            <div class=\"value\">\n              {{vm.time}}\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Block id:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-block/{{vm.block}}\">{{vm.block}}</a>\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Generator:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.generator}}/transactions\">{{vm.generatorPublicName||vm.generator}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total amount:\n            </div>\n            <div class=\"value\">\n              {{vm.totalAmount}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Total fee:\n            </div>\n            <div class=\"value\">\n              {{vm.totalFee}} HEAT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              POP reward:\n            </div>\n            <div class=\"value\">\n              {{vm.popReward}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              POS reward:\n            </div>\n            <div class=\"value\">\n              {{vm.posReward}} HEAT\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              JSON:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.jsonDetails($event, vm.blockObject)\">Show <i class=\"material-icons\">code</i></a>\n            </div>\n          </div>\n        </div>\n      </div>\n      <virtual-repeat-transactions layout=\"column\" flex layout-fill block=\"vm.block\"></virtual-repeat-transactions>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', 'settings'),
        __metadata("design:paramtypes", [Object, HeatService,
            SettingsService])
    ], ExplorerBlockComponent);
    return ExplorerBlockComponent;
}());
var ExplorerLatestBlocksComponent = (function (_super) {
    __extends(ExplorerLatestBlocksComponent, _super);
    function ExplorerLatestBlocksComponent($scope, $q, heat, latestBlocksProviderFactory, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.latestBlocksProviderFactory = latestBlocksProviderFactory;
        _this.settings = settings;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.latestBlocksProviderFactory.createProvider(_this.blockObject, _this.account), function (block) {
            var date = utils.timestampToDate(block.timestamp);
            block.time = dateFormat(date, format);
            block.amount = utils.formatQNT(block.totalAmountHQT, 8) + " HEAT";
            block.fee = utils.trimDecimals(utils.formatQNT(block.totalFeeHQT, 8), 2) + " HEAT";
            block.pos = utils.trimDecimals(utils.formatQNT(block.posRewardHQT, 8), 2) + " HEAT";
            block.pop = utils.trimDecimals(utils.formatQNT(block.popRewardHQT, 8), 2) + " HEAT";
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        heat.subscriber.blockPopped({}, refresh, $scope);
        heat.subscriber.blockPushed({}, refresh, $scope);
        return _this;
    }
    ExplorerLatestBlocksComponent.prototype.jsonDetails = function ($event, item) {
        dialogs.jsonDetails($event, item, 'Block: ' + item.block);
    };
    ExplorerLatestBlocksComponent.prototype.onSelect = function (selectedBlock) { };
    ExplorerLatestBlocksComponent = __decorate([
        Component({
            selector: 'explorerLatestBlocks',
            inputs: ['blockObject', 'account', 'hideLabel'],
            styles: ["\n  .he {         \n    min-width: 40px !important;         \n    max-width: 70px !important;         \n  }\n  .tx {         \n    min-width: 20px !important;         \n    max-width: 40px !important;         \n  }\n  .fee {         \n    max-width: 70px !important;         \n  }\n  "],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Latest Blocks\n      </div>\n      <md-list flex layout-fill layout=\"column\" >\n        <md-list-item class=\"header\">\n          <div class=\"he truncate-col height-col left\">Height</div>\n          <div class=\"truncate-col date-col left\">Time</div>\n          <div class=\"truncate-col block-col block left\">Block</div>\n          <div class=\"truncate-col generator-col block left\" ng-if=\"!vm.account\">Generator</div>\n          <div class=\"tx truncate-col transactions-col\">Tx</div>\n          <div class=\"truncate-col amount-col\">Amount</div>\n          <div class=\"fee truncate-col fee-col\">Fee</div>\n          <div class=\"truncate-col pos-col left\">POS Reward</div>\n          <div class=\"truncate-col pop-col left\" flex>POP Reward</div>\n          <!-- JSON -->\n          <div class=\"truncate-col json-col\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"he truncate-col height-col left\">{{item.height}}</div>\n            <div class=\"truncate-col date-col left\">{{item.time}}</div>\n            <div class=\"truncate-col block-col block left\"><a href=\"#/explorer-block/{{item.block}}\">{{item.block}}</a></div>\n            <div class=\"truncate-col generator-col block left\" ng-if=\"!vm.account\"><a href=\"#/explorer-account/{{item.generator}}/transactions\">{{item.generatorPublicName||item.generator}}</a></div>\n            <div class=\"tx truncate-col transactions-col\">{{item.numberOfTransactions}}</div>\n            <div class=\"truncate-col amount-col\">{{item.amount}}</div>\n            <div class=\"fee truncate-col fee-col\">{{item.fee}}</div>\n            <div class=\"truncate-col pos-col left\">{{item.pos}}</div>\n            <div class=\"truncate-col pop-col left\" flex>{{item.pop}}</div>\n            <!-- JSON -->\n            <div class=\"truncate-col json-col\">\n              <a ng-click=\"vm.jsonDetails($event, item)\">\n                <md-icon md-font-library=\"material-icons\">code</md-icon>\n              </a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'latestBlocksProviderFactory', 'settings'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            LatestBlocksProviderFactory,
            SettingsService])
    ], ExplorerLatestBlocksComponent);
    return ExplorerLatestBlocksComponent;
}(VirtualRepeatComponent));
var ExplorerResultsAccountsComponent = (function (_super) {
    __extends(ExplorerResultsAccountsComponent, _super);
    function ExplorerResultsAccountsComponent($scope, $q, searchAccountsProviderFactory) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.searchAccountsProviderFactory = searchAccountsProviderFactory;
        _this.initializeVirtualRepeat(_this.searchAccountsProviderFactory.createProvider(_this.query), function (account) {
            account.balanceFormatted = utils.formatQNT(account.unconfirmedBalance, 8);
            if (account.publicName == account.id) {
                account.publicName = '[private]';
            }
        });
        return _this;
    }
    ExplorerResultsAccountsComponent.prototype.onSelect = function (selectedAccount) { };
    ExplorerResultsAccountsComponent = __decorate([
        Component({
            selector: 'explorerResultsAccounts',
            inputs: ['query'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col id-col left\">Account</div>\n          <div class=\"truncate-col balance-col\">Balance</div>\n          <div class=\"truncate-col name-col left\" flex>Name</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"truncate-col id-col left\"><a href=\"#/explorer-account/{{item.id}}/transactions\">{{item.id}}</a></div>\n            <div class=\"truncate-col balance-col\">{{item.balanceFormatted}}</div>\n            <div class=\"truncate-col name-col left\" flex>{{item.publicName}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'searchAccountsProviderFactory'),
        __metadata("design:paramtypes", [Object, Function, SearchAccountsProviderFactory])
    ], ExplorerResultsAccountsComponent);
    return ExplorerResultsAccountsComponent;
}(VirtualRepeatComponent));
var ExplorerResultsComponent = (function () {
    function ExplorerResultsComponent($scope, heat, $location) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.$location = $location;
        if (this.type === 'search' || this.type === 'accounts') {
            heat.api.searchAccountsCount(this.query).then(function (count) {
                $scope.$evalAsync(function () {
                    if (_this.type === 'search' && count > 0) {
                        _this.type = 'accounts';
                        _this.$location.path("/explorer-results/" + _this.type + "/" + _this.query);
                    }
                });
            });
        }
        if (this.type === 'search' || this.type === 'blocks') {
            heat.api.getBlock(this.query, true).then(function (block) {
                $scope.$evalAsync(function () {
                    _this.blockObject = block;
                    if (_this.type === 'search') {
                        _this.type = 'blocks';
                        _this.$location.path("/explorer-results/" + _this.type + "/" + _this.query);
                    }
                });
            }, function () {
                var height = parseInt(_this.query);
                if (!isNaN(height)) {
                    heat.api.getBlockAtHeight(height, true).then(function (block) {
                        $scope.$evalAsync(function () {
                            _this.blockObject = block;
                            if (_this.type === 'search') {
                                _this.type = 'blocks';
                                _this.$location.path("/explorer-results/" + _this.type + "/" + _this.query);
                            }
                        });
                    });
                }
            });
        }
        if (this.type === 'search' || this.type === 'transactions') {
            heat.api.getTransaction(this.query).then(function (transaction) {
                $scope.$evalAsync(function () {
                    _this.transactionObject = transaction;
                    if (_this.type === 'search') {
                        _this.type = 'transactions';
                        _this.$location.path("/explorer-results/" + _this.type + "/" + _this.query);
                    }
                });
            });
        }
    }
    ExplorerResultsComponent = __decorate([
        RouteConfig('/explorer-results/:type/', '/explorer-results/:type/:query'),
        Component({
            selector: 'explorerResults',
            inputs: ['type', 'query'],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <explorer-search layout=\"column\" query=\"vm.query\"></explorer-search>\n      <div layout=\"row\" layout-align=\"start center\" class=\"type-row\">\n        <md-button ng-class=\"{'active':vm.type=='accounts'}\"\n          ng-disabled=\"vm.type=='accounts'\"\n          ng-href=\"#/explorer-results/accounts/{{vm.query}}\">Accounts</md-button>\n        <md-button ng-class=\"{'active':vm.type=='blocks'}\"\n          ng-disabled=\"vm.type=='blocks'\"\n          ng-href=\"#/explorer-results/blocks/{{vm.query}}\">Blocks</md-button>\n        <md-button ng-class=\"{'active':vm.type=='transactions'}\"\n          ng-disabled=\"vm.type=='transactions'\"\n          ng-href=\"#/explorer-results/transactions/{{vm.query}}\">Transactions</md-button>\n      </div>\n\n      <!-- ACCOUNTS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='accounts'\">\n        <explorer-results-accounts query=\"vm.query\" flex layout=\"column\"></explorer-results-accounts>\n      </div>\n\n      <!-- BLOCKS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='blocks'\">\n        <explorer-latest-blocks ng-if=\"vm.blockObject\" layout=\"column\" flex block-object=\"vm.blockObject\"></explorer-latest-blocks>\n        <span ng-if=\"!vm.blockObject\">\n          No blocks found with that height or id.\n        </span>\n      </div>\n\n      <!-- TRANSACTIONS -->\n      <div layout=\"column\" flex ng-if=\"vm.type=='transactions'\">\n        <virtual-repeat-transactions ng-if=\"vm.transactionObject\" layout=\"column\" flex transaction-object=\"vm.transactionObject\"></virtual-repeat-transactions>\n        <span ng-if=\"!vm.transactionObject\">\n          No transaction found with that id.\n        </span>\n      </div>\n\n      <div layout=\"column\" flex ng-if=\"vm.type=='search'\">No results found</div>\n\n    </div>\n  "
        }),
        Inject('$scope', 'heat', '$location'),
        __metadata("design:paramtypes", [Object, HeatService, Object])
    ], ExplorerResultsComponent);
    return ExplorerResultsComponent;
}());
var ExplorerRewardsBlocksComponent = (function (_super) {
    __extends(ExplorerRewardsBlocksComponent, _super);
    function ExplorerRewardsBlocksComponent($scope, $q, heat, rewardsProviderFactory, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$q = $q;
        _this.heat = heat;
        _this.rewardsProviderFactory = rewardsProviderFactory;
        _this.settings = settings;
        var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.initializeVirtualRepeat(_this.rewardsProviderFactory.createProvider(), function (reward) {
            reward['effectiveBalanceFormatted'] = utils.commaFormat(reward.effectiveBalance) + " HEAT";
            reward['totalRewardsFormatted'] = utils.commaFormat(utils.formatQNT(reward.totalRewards, 8)) + " HEAT";
        });
        var refresh = utils.debounce(angular.bind(_this, _this.determineLength), 500, false);
        heat.subscriber.blockPopped({}, refresh, $scope);
        heat.subscriber.blockPushed({}, refresh, $scope);
        return _this;
    }
    ExplorerRewardsBlocksComponent.prototype.onSelect = function (selectedBlock) { };
    ExplorerRewardsBlocksComponent = __decorate([
        RouteConfig('/explorer-rewards'),
        Component({
            selector: 'explorerRewards',
            template: "\n    <div layout=\"column\" flex layout-fill layout-padding>\n      <div layout=\"row\" class=\"trader-component-title\" ng-hide=\"vm.hideLabel\">Forging Rewards\n      </div>\n      <md-list flex layout-fill layout=\"column\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col account-col left\">Account</div>\n          <div class=\"truncate-col effective-col block left\">Effective Balance</div>\n          <div class=\"truncate-col total-col left\">Total Rewards</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <div class=\"truncate-col account-col left\">\n              <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.accountName||item.account}}</a>\n            </div>\n            <div class=\"truncate-col effective-col block left\">{{item.effectiveBalanceFormatted}}</div>\n            <div class=\"truncate-col total-col left\">{{item.totalRewardsFormatted}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'heat', 'rewardsProviderFactory', 'settings'),
        __metadata("design:paramtypes", [Object, Function, HeatService,
            RewardsProviderFactory,
            SettingsService])
    ], ExplorerRewardsBlocksComponent);
    return ExplorerRewardsBlocksComponent;
}(VirtualRepeatComponent));
var ExplorerSearchComponent = (function () {
    function ExplorerSearchComponent($scope, $location) {
        this.$scope = $scope;
        this.$location = $location;
    }
    ExplorerSearchComponent.prototype.onKeyPress = function ($event) {
        if ($event.keyCode == 13) {
            var type = this.type || 'search';
            var query = this.query || '';
            this.$location.path("/explorer-results/" + type + "/" + query);
        }
    };
    ExplorerSearchComponent = __decorate([
        Component({
            selector: 'explorerSearch',
            inputs: ['type', 'query'],
            template: "\n    <div layout=\"row\" flex layout-fill>\n      <md-input-container flex>\n        <label>Search for account id, account public names, transaction id, block id or block height</label>\n        <input name=\"search-text\" ng-model=\"vm.query\" ng-keypress=\"vm.onKeyPress($event)\">\n      </md-input-container>\n    </div>\n  "
        }),
        Inject('$scope', '$location'),
        __metadata("design:paramtypes", [Object, Object])
    ], ExplorerSearchComponent);
    return ExplorerSearchComponent;
}());
var ExplorerComponent = (function () {
    function ExplorerComponent($scope) {
        this.$scope = $scope;
    }
    ExplorerComponent = __decorate([
        RouteConfig('/explorer'),
        Component({
            selector: 'explorer',
            styles: ["\n    explorer h3 {\n      font-size: 24px !important;\n      font-weight: bold;\n      padding-bottom: 0px;\n      margin-bottom: 0px;\n    }\n    explorer md-list-item.active {\n      background-color: #B2DFDB;\n    }\n    explorer .wallet {\n      height: 32px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <explorer-search layout=\"column\" type=\"''\" query=\"''\"></explorer-search>\n      <explorer-latest-blocks layout=\"column\" flex=\"30\"></explorer-latest-blocks>\n      <virtual-repeat-transactions layout=\"column\" flex=\"60\"></virtual-repeat-transactions>\n    </div>\n  "
        }),
        Inject('$scope'),
        __metadata("design:paramtypes", [Object])
    ], ExplorerComponent);
    return ExplorerComponent;
}());
var EthereumAccountComponent = (function () {
    function EthereumAccountComponent($scope, web3, assetInfo, $q, user, ethplorer, ethereumPendingTransactions, settings, $interval, $mdToast) {
        this.$scope = $scope;
        this.web3 = web3;
        this.assetInfo = assetInfo;
        this.$q = $q;
        this.user = user;
        this.ethplorer = ethplorer;
        this.ethereumPendingTransactions = ethereumPendingTransactions;
        this.settings = settings;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.erc20Tokens = [];
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.personalize = this.account == this.user.account;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        ethereumPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 20000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            ethereumPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
    }
    EthereumAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_3 = this.pendingTransactions[this.prevIndex];
            this.ethplorer.getTxInfo(pendingTxn_3.txHash).then(function (data) {
                _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with hash " + pendingTxn_3.txHash + " found").hideDelay(2000));
                _this.ethereumPendingTransactions.remove(pendingTxn_3.address, pendingTxn_3.txHash, pendingTxn_3.timestamp);
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    EthereumAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.ethereumPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.timestamp), format),
                        timestamp: tx.timestamp,
                        txHash: tx.txHash,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.timestamp - a.timestamp; });
            }
        });
    };
    EthereumAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.balanceUnconfirmed = "*";
        this.ethplorer.getAddressInfo(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(info.ETH.balance).toFixed(18);
                if (info.tokens) {
                    _this.erc20Tokens = info.tokens.map(function (token) {
                        var tokenInfo = _this.ethplorer.tokenInfoCache[token.tokenInfo.address];
                        return {
                            balance: utils.formatQNT(new Big(token.balance + "").toFixed(), tokenInfo ? tokenInfo.decimals : 18),
                            symbol: token.tokenInfo.symbol,
                            name: token.tokenInfo.name,
                            id: ''
                        };
                    });
                }
            });
        });
    };
    EthereumAccountComponent = __decorate([
        RouteConfig('/ethereum-account/:account'),
        Component({
            selector: 'ethereumAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/ethereum-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance:\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} ETH\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\" flex>\n          <div class=\"col-item\" flex layout-fill>\n            <div class=\"title\">\n              ERC-20 Tokens:\n            </div>\n            <div class=\"scrollable\">\n              <div class=\"value\" ng-repeat=\"item in vm.erc20Tokens\">\n                <span class=\"balance\">{{item.balance}}</span>\n                <span class=\"symbol\"><b>{{item.symbol}}</b></span>\n                <span class=\"balance\">Token: {{item.name}}</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Hash</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <a target=\"_blank\" href=\"https://ethplorer.io/tx/{{item.txHash}}\">{{item.txHash}}</a>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-eth-transactions layout=\"column\" flex layout-fill account=\"vm.account\" personalize=\"vm.personalize\"></virtual-repeat-eth-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'web3', 'assetInfo', '$q', 'user', 'ethplorer', 'ethereumPendingTransactions', 'settings', '$interval', '$mdToast'),
        __metadata("design:paramtypes", [Object, Web3Service,
            AssetInfoService, Function, UserService,
            EthplorerService,
            EthereumPendingTransactionsService,
            SettingsService, Function, Object])
    ], EthereumAccountComponent);
    return EthereumAccountComponent;
}());
var HomeComponent = (function () {
    function HomeComponent(user) {
        this.user = user;
        user.requireLogin();
        user.on(UserService.EVENT_UNLOCKED, function () {
        });
    }
    HomeComponent = __decorate([
        RouteConfig('/home'),
        Component({
            selector: 'home',
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <virtual-repeat-transactions layout=\"column\" flex account=\"vm.user.account\" personalize=\"true\"></virtual-repeat-transactions>\n      <!-- <virtual-repeat-eth-transactions layout=\"column\" flex account=\"vm.user.account\" personalize=\"true\"></virtual-repeat-eth-transactions> -->\n    </div>\n  "
        }),
        Inject('user'),
        __metadata("design:paramtypes", [UserService])
    ], HomeComponent);
    return HomeComponent;
}());
var IotaAccountComponent = (function () {
    function IotaAccountComponent($scope, iotaBlockExplorerService, iotaPendingTransactions, $interval, $mdToast, settings, user) {
        this.$scope = $scope;
        this.iotaBlockExplorerService = iotaBlockExplorerService;
        this.iotaPendingTransactions = iotaPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        iotaPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            iotaPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
    }
    IotaAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.iotaBlockExplorerService.getAccountInfo(this.user.secretPhrase).then(function (recentTransactions) {
                for (var i = 0; i < _this.pendingTransactions.length; i++) {
                    var isPending = true;
                    for (var j = 0; j < recentTransactions.transfers.length; j++) {
                        if (recentTransactions.transfers[j][0].hash == _this.pendingTransactions[i].txId) {
                            isPending = false;
                            break;
                        }
                    }
                    if (!isPending) {
                        _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id " + _this.pendingTransactions[i].txId + " found").hideDelay(2000));
                        _this.iotaPendingTransactions.remove(_this.pendingTransactions[i].address, _this.pendingTransactions[i].txId, _this.pendingTransactions[i].time);
                    }
                }
            }, function (err) {
                console.log('Error in getting recent IOTA Transactions ' + err);
            });
        }
    };
    IotaAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.iotaPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    IotaAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.iotaBlockExplorerService.getAccountInfo(this.user.secretPhrase).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = info ? info.balance : 0;
                _this.busy = false;
            });
        });
    };
    IotaAccountComponent = __decorate([
        RouteConfig('/iota-account/:account'),
        Component({
            selector: 'iotaAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/iota-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} IOTA\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-iota-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-iota-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'iotaBlockExplorerService', 'iotaPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, IotaBlockExplorerService,
            IotaPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], IotaAccountComponent);
    return IotaAccountComponent;
}());
var EditMessageComponent = (function () {
    function EditMessageComponent($scope, sendmessage, storage, $timeout, user, p2pMessaging, $mdToast) {
        this.$scope = $scope;
        this.sendmessage = sendmessage;
        this.$timeout = $timeout;
        this.user = user;
        this.p2pMessaging = p2pMessaging;
        this.$mdToast = $mdToast;
        this.store = storage.namespace('contacts.latestTimestamp', $scope);
    }
    EditMessageComponent.prototype.onKeyPress = function ($event) {
        if ($event.keyCode == 13 && !$event.shiftKey) {
            this.send($event);
        }
    };
    EditMessageComponent.prototype.send = function ($event) {
        if (this.messageText && this.messageText.trim().length != 0) {
            if ($event.preventDefault)
                $event.preventDefault();
            if (this.p2pMessaging.offchainMode) {
                this.sendP2PMessage($event);
            }
            else {
                this.sendMessage($event);
            }
        }
    };
    EditMessageComponent.prototype.sendP2PMessage = function ($event) {
        var _this = this;
        var notSentReason;
        var room = this.p2pMessaging.getOneToOneRoom(this.publickey);
        if (room) {
            var peer = room.getPeer(this.publickey);
            if (peer && peer.isConnected()) {
                var count = room.sendMessage({ timestamp: Date.now(), type: "chat", text: this.messageText });
                this.$scope.$evalAsync(function () {
                    _this.messageText = '';
                });
            }
            else {
                notSentReason = "Peer is not connected";
            }
        }
        else {
            notSentReason = "Chat 'room' for contact is not created";
        }
        if (notSentReason) {
            this.$mdToast.show(this.$mdToast.simple().textContent("Not sent. " + notSentReason).hideDelay(3000));
        }
    };
    EditMessageComponent.prototype.sendMessage = function ($event) {
        var _this = this;
        var account = heat.crypto.getAccountIdFromPublicKey(this.publickey);
        this.sendmessage.
            dialog($event, account, this.publickey, this.messageText).
            send().
            then(function () {
            _this.$scope.$evalAsync(function () {
                _this.messageText = '';
            });
            _this.$timeout(2 * 1000, false).then(function () {
                var latestTimestamp = _this.store.getNumber(account, 0);
                _this.store.put(account, latestTimestamp + 1);
            });
        });
    };
    EditMessageComponent.prototype.toggleOffchain = function ($event) {
        this.p2pMessaging.offchainMode = !this.p2pMessaging.offchainMode;
    };
    EditMessageComponent = __decorate([
        Component({
            selector: 'editMessage',
            inputs: ['publickey'],
            styles: ["\n    edit-message .md-button {\n      margin: 0px;\n      min-width: 46px;\n    }\n    .edit-message-textarea {\n      border: solid 1px;\n      border-radius: 5px 5px 0px;\n    }\n    .edit-message-textarea.offchain {\n      border-color: green;\n    }\n    .edit-message-textarea::placeholder {\n      color: rgb(117, 117, 117);\n    }\n    .send-button-container {\n      padding-left: 10px;\n    }\n    edit-message .offchain-button {\n      width: 110px;\n      height: 30px;\n    }\n    edit-message .offchain-button.disable span {\n      color: grey;\n    }\n    edit-message .offchain-button.active {\n      background-color: green;\n    }\n    edit-message .send-button {\n      margin-top: 6px;\n    }\n  "],
            template: "\n    <div layout=\"row\" flex>\n      <div layout=\"column\" flex=\"noshrink\">\n        <form hide-gt-xs name=\"editMessageForm\" ng-submit=\"vm.sendMessage($event)\" flex layout=\"row\">\n          <textarea flex rows=\"4\" ng-model=\"vm.messageText\"></textarea>\n          <md-button type=\"submit\" aria-label=\"Submit\">\n            <md-icon md-font-library=\"material-icons\">send</md-icon>\n          </md-button>\n        </form>\n        <textarea hide-xs ng-model=\"vm.messageText\" flex rows=\"4\" class=\"edit-message-textarea\"\n          ng-class=\"{'offchain': vm.p2pMessaging.offchainMode}\"\n          ng-keypress=\"vm.onKeyPress($event)\" placeholder=\"Hit ENTER key to send, SHIFT+ENTER for new line\"></textarea>\n      </div>\n      <div layout=\"column\" class=\"send-button-container\">\n        <md-button class=\"offchain-button\" ng-click=\"vm.toggleOffchain()\" ng-class=\"{'active': vm.p2pMessaging.offchainMode, 'disable': !vm.p2pMessaging.offchainMode}\">\n          <md-tooltip md-direction=\"top\">Peer-to-peer messages off blockchain</md-tooltip>\n          {{vm.p2pMessaging.offchainMode ? 'offchain  \u2714' : 'offchain'}}\n        </md-button>\n        <md-button class=\"md-primary send-button\" flex ng-click=\"vm.send($event)\">\n          Send\n        </md-button>\n      </div>\n    </div>\n\n  "
        }),
        Inject('$scope', 'sendmessage', 'storage', '$timeout', 'user', 'P2PMessaging', '$mdToast'),
        __metadata("design:paramtypes", [Object, SendmessageService,
            StorageService, Function, UserService,
            P2PMessaging, Object])
    ], EditMessageComponent);
    return EditMessageComponent;
}());
var MessageBatchEntryComponent = (function () {
    function MessageBatchEntryComponent() {
        this.io = this.message['outgoing'] ? 'outgoing' : 'incoming';
    }
    MessageBatchEntryComponent = __decorate([
        Component({
            selector: 'messageBatchEntry',
            inputs: ['message'],
            styles: ["\n    message-batch-entry .header {\n      font-size: 12px;\n    }\n    message-batch-entry .batch-entry {\n      padding-left: 0px;\n    }\n\n    message-batch-entry .column {\n      border-radius: 15px;\n      min-width: 120px;\n      padding-top: 5px;\n    }\n    message-batch-entry .outgoing {\n      text-align: right;\n      float: right;\n      background-color: #0c5f68;\n      color: white;\n      padding-left: 10px;\n      padding-top: 10px;\n      padding-right: 10px;\n      padding-botton: 0px;\n      border-radius: .4em;\n    }\n    message-batch-entry .incoming {\n      text-align: left;\n      float: left;\n      background-color: #52a7b1;\n      color: black;\n      padding-left: 10px;\n      padding-top: 10px;\n      padding-right: 10px;\n      padding-botton: 0px;\n      border-radius: .4em;\n    }\n    message-batch-entry .message-content pre {\n      white-space: pre-wrap;       /* Since CSS 2.1 */\n      white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n      white-space: -pre-wrap;      /* Opera 4-6 */\n      white-space: -o-pre-wrap;    /* Opera 7 */\n      word-wrap: break-word;       /* Internet Explorer 5.5+ */\n      /* Adds a hyphen where the word breaks, if supported (No Blink) */\n      -ms-hyphens: auto;\n      -moz-hyphens: auto;\n      -webkit-hyphens: auto;\n      hyphens: auto;\n    }\n  "],
            template: "\n    <div ng-class=\"vm.io\">\n      <div class=\"header\">\n        {{::vm.message.date}}\n      </div>\n      <div class=\"message-content\"><pre>{{vm.message.content}}</pre></div>\n    </div>\n  "
        }),
        __metadata("design:paramtypes", [])
    ], MessageBatchEntryComponent);
    return MessageBatchEntryComponent;
}());
var MessageBatchViewerComponent = (function (_super) {
    __extends(MessageBatchViewerComponent, _super);
    function MessageBatchViewerComponent($scope, $q, $timeout, $document, heat, user, settings, render, controlCharRender, storage) {
        var _this = _super.call(this, $scope, $q, $timeout) || this;
        _this.$document = $document;
        _this.heat = heat;
        _this.user = user;
        _this.settings = settings;
        _this.render = render;
        _this.controlCharRender = controlCharRender;
        _this.store = storage.namespace('contacts.latestTimestamp', $scope);
        _this.dateFormat = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        _this.account = _this.user.key ? _this.user.key.account : _this.user.account;
        var refresh = utils.debounce((angular.bind(_this, _this.onMessageAdded)), 500, false);
        heat.subscriber.message({ sender: _this.account }, refresh, $scope);
        heat.subscriber.message({ recipient: _this.account }, refresh, $scope);
        _this.loadInitial();
        var publicKey = _this.user.key ? _this.user.key.publicKey : _this.user.publicKey;
        if (_this.publickey == publicKey) {
            throw Error("Same public key as logged in user");
        }
        return _this;
    }
    MessageBatchViewerComponent.prototype.loadInitial = function () {
        var _this = this;
        var deferred = this.$q.defer();
        this.clear();
        this.$scope.$evalAsync(function () { _this.getParentScope().loading = true; });
        this.getBatch(0).then(function (batch) {
            _this.$scope.$evalAsync(function () {
                _this.getParentScope().loading = false;
                _this.$timeout(0).then(function () {
                    deferred.resolve();
                });
            });
        });
        deferred.promise.then(function () {
            if (_this.batches[0].entries.length > 0) {
                _this.goTo(_this.getFirst().getLast().__id, 0, 1);
            }
        });
        return deferred.promise;
    };
    MessageBatchViewerComponent.prototype.onMessageAdded = function () {
        var _this = this;
        var batch = this.getFirst();
        batch.loadMore().then(function () {
            var entry = batch.getLast();
            var id = entry.__id;
            _this.$scope.$evalAsync(function () {
                _this.$timeout(0).then(function () {
                    _this.goTo(id, 0, 1000);
                });
            });
        });
    };
    MessageBatchViewerComponent.prototype.onMessageRemoved = function () { };
    MessageBatchViewerComponent.prototype.onMessageConfirmed = function () { };
    MessageBatchViewerComponent.prototype.goTo = function (id, offset, duration) {
        var container = this.getScrollContainer();
        var element = angular.element(document.getElementById(id));
        if (!element)
            return;
        var _offset = offset || 30;
        var _duration = duration || 2000;
        return container.duScrollToElement(element, _offset, _duration, heat.easing.easeOutCubic);
    };
    MessageBatchViewerComponent.prototype.getScrollContainer = function () {
        return angular.element(document.getElementById(this.containerId));
    };
    MessageBatchViewerComponent.prototype.getCount = function () {
        return this.heat.api.getMessagingContactMessagesCount(this.account, heat.crypto.getAccountIdFromPublicKey(this.publickey));
    };
    MessageBatchViewerComponent.prototype.getItems = function (firstIndex, lastIndex) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getMessagingContactMessages(this.account, heat.crypto.getAccountIdFromPublicKey(this.publickey), firstIndex, lastIndex).then(function (messages) {
            var index = firstIndex;
            var result = messages.map(function (message) {
                var date = utils.timestampToDate(message.timestamp);
                message['date'] = dateFormat(date, _this.dateFormat);
                message['outgoing'] = _this.account == message.sender;
                message['contents'] = _this.decryptMessage(message);
                message['index'] = index++;
                message['html'] = _this.render.render(message['contents'], [_this.controlCharRender]);
                _this.updateLatestMessageReadTimestamp(message);
                return message;
            });
            deferred.resolve(result);
        });
        return deferred.promise;
    };
    MessageBatchViewerComponent.prototype.decryptMessage = function (message) {
        return this.heat.getHeatMessageContents(message);
    };
    MessageBatchViewerComponent.prototype.updateLatestMessageReadTimestamp = function (message) {
        var account = this.account == message.sender ? message.recipient : message.sender;
        var latestTimestamp = this.store.getNumber(account, 0);
        if (message.timestamp > latestTimestamp) {
            this.store.put(account, message.timestamp);
        }
    };
    MessageBatchViewerComponent = __decorate([
        Component({
            selector: 'messageBatchViewer',
            inputs: ['publickey', '@containerId'],
            styles: ["\n    message-batch-viewer .message-item {\n      min-height: 80px;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex>\n      <div class=\"scroll-up\" layout=\"row\" flex ng-hide=\"vm.getParentScope().loading || vm.batches[vm.batches.length-1].firstIndex == 0\" layout-align=\"center\">\n        <md-button ng-click=\"vm.scrollUp()\" aria-label=\"Go up\">Go up</md-button>\n      </div>\n      <div layout=\"column\">\n        <div layout=\"column\" ng-repeat=\"batch in vm.batches | orderBy:'-'\">\n          <div layout=\"column\" ng-repeat=\"entry in batch.entries\">\n            <message-batch-entry id=\"{{::entry.__id}}\" message=\"entry\" flex=\"none\" class=\"message-item\"></message-batch-entry>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$timeout', '$document', 'heat', 'user', 'settings', 'render', 'controlCharRender', 'storage'),
        __metadata("design:paramtypes", [Object, Function, Function, Object, HeatService,
            UserService,
            SettingsService,
            RenderService,
            ControlCharRenderService,
            StorageService])
    ], MessageBatchViewerComponent);
    return MessageBatchViewerComponent;
}(AbstractBatchViewerComponent));
var MessengerComponent = (function () {
    function MessengerComponent($scope, user, sendmessage, p2pMessaging, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.sendmessage = sendmessage;
        this.p2pMessaging = p2pMessaging;
        this.$interval = $interval;
        user.requireLogin();
        $scope.$on('$destroy', function () {
            $interval.cancel(_this.interval);
        });
    }
    MessengerComponent.prototype.showSendmessageDialog = function ($event) {
        this.sendmessage.dialog($event).show();
    };
    MessengerComponent.prototype.showCallDialog = function ($event) {
        var recipient = heat.crypto.getAccountIdFromPublicKey(this.publickey);
        this.p2pMessaging.dialog($event, recipient, this.publickey).show().finally(function () { });
    };
    MessengerComponent.prototype.toggleOnline = function ($event) {
        this.p2pMessaging.onlineStatus = this.p2pMessaging.onlineStatus == "online" ? "offline" : "online";
        this.p2pMessaging.enterRoom(this.publickey);
    };
    MessengerComponent = __decorate([
        RouteConfig('/messenger/:publickey'),
        Component({
            selector: 'messenger',
            inputs: ['publickey'],
            styles: ["\n    messenger user-contacts {\n      width: 300px;\n      min-width: 240px;\n    }\n    messenger .control-panel {\n      margin-top: 6px;\n      margin-right: 6px;\n    }\n    messenger edit-message {\n      min-height: 80px;\n    }\n    messenger .outer-container {\n      padding-top: 0px;\n      padding-bottom: 0px;\n    }\n    messenger md-content {\n      height: 100%;\n      //padding: 0 0 0 12px;\n    }\n    messenger .progress-indicator {\n      padding-left: 0px;\n      padding-right: 0px;\n    }\n    messenger md-progress-linear > .md-container {\n      height: 3px;\n      max-height: 3px;\n    }\n    messenger .edit-message {\n      padding-right: 0px;\n      padding-top: 8px;\n    }\n    .control-panel button {\n      flex: auto;\n    }\n    .p2p-messages {\n      height: 100%;\n    }\n    #onlineStatusButton.disable span {\n      color: grey;\n    }\n    #onlineStatusButton.active {\n      background-color: green;\n    }\n    #newContactButton {\n      max-width: 171px;\n    }\n    #newContactButton md-icon {\n      margin-right: 8px;\n      color: white;\n    }\n  "],
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill class=\"outer-container\">\n      <div layout=\"row\" flex layout-fill>\n        <div layout=\"column\">\n          <user-contacts flex layout=\"column\" ></user-contacts>\n          <div layout=\"row\" class=\"control-panel\">\n            <md-button id=\"newContactButton\" class=\"md-primary\" aria-label=\"Add contact\" ng-click=\"vm.showSendmessageDialog($event)\">\n              <md-tooltip md-direction=\"top\">\n                Send message to new contact\n              </md-tooltip>\n              <md-icon md-font-library=\"material-icons\">add_circle_outline</md-icon>\n              New CONTACT\n            </md-button>\n            <md-button id=\"CallButton\" class=\"md-primary\" aria-label=\"Call\"\n            ng-if=\"vm.p2pMessaging.onlineStatus == 'online'\" ng-click=\"vm.showCallDialog($event)\">\n              <md-tooltip md-direction=\"top\">\n                Connect user to establish the peer-to-peer channel\n              </md-tooltip>\n              CONNECT\n            </md-button>\n          </div>\n          <div layout=\"row\" class=\"control-panel\">\n            <md-button class=\"online\" id=\"onlineStatusButton\" ng-click=\"vm.toggleOnline()\"\n            ng-class=\"{'active': vm.p2pMessaging.onlineStatus == 'online', 'disable': vm.p2pMessaging.onlineStatus !== 'online'}\">\n              <md-tooltip md-direction=\"top\">Set online peer-to-peer messaging status</md-tooltip>\n              {{vm.p2pMessaging.onlineStatus == 'online' ? 'online  \u2714' : 'online'}}\n            </md-button>\n          </div>\n        </div>\n        <div layout=\"column\" layout-fill>\n          <md-content flex id=\"message-batch-container\">\n            <msg-viewer flex layout=\"column\" container-id=\"message-batch-container\"\n                    publickey=\"::vm.publickey\"></msg-viewer>\n          </md-content>\n          <div layout=\"row\" flex=\"none\" class=\"edit-message\">\n            <edit-message publickey=\"vm.publickey\" layout=\"row\" flex></edit-message>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', 'sendmessage', 'P2PMessaging', '$interval'),
        __metadata("design:paramtypes", [Object, UserService,
            SendmessageService,
            P2PMessaging, Function])
    ], MessengerComponent);
    return MessengerComponent;
}());
var MsgViewerComponent = (function () {
    function MsgViewerComponent(heat, user, $scope, p2pMessaging, settings, $timeout) {
        this.heat = heat;
        this.user = user;
        this.$scope = $scope;
        this.p2pMessaging = p2pMessaging;
        this.settings = settings;
        this.$timeout = $timeout;
        var publicKey = this.user.key ? this.user.key.publicKey : this.user.publicKey;
        if (this.publickey == publicKey) {
            throw Error("Same public key as logged in user");
        }
        this.dateFormat = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        this.account = user.key ? user.key.account : user.account;
        var refresh = utils.debounce((angular.bind(this, this.onMessageAdded)), 500, false);
        heat.subscriber.message({ sender: this.account }, refresh, $scope);
        heat.subscriber.message({ recipient: this.account }, refresh, $scope);
        MsgViewerComponent_1.count = 10000;
        this.initMessages();
    }
    MsgViewerComponent_1 = MsgViewerComponent;
    MsgViewerComponent.prototype.initMessages = function () {
        var _this = this;
        this.offchainPages = 0;
        this.onchainMessagesCount = 0;
        this.messagesCount = 0;
        this.displayMessages = { index: 0, messages: [] };
        this.allMessages = [];
        this.heat.api.getMessagingContactMessagesCount(this.account, heat.crypto.getAccountIdFromPublicKey(this.publickey)).then(function (count) {
            if (count > 0) {
                _this.onchainMessagesCount = count;
                _this.messagesCount += count;
            }
            var room = _this.p2pMessaging.getOneToOneRoom(_this.publickey, true);
            if (room) {
                _this.messageHistory = room.getMessageHistory();
                _this.offchainPages = _this.messageHistory.getPageCount() - 1;
                room.onNewMessageHistoryItem = function (item) { _this.onMessageAdded(item, true); };
                _this.messagesCount += _this.messageHistory.getItemCount();
            }
            _this.loadMessages();
        });
    };
    MsgViewerComponent.prototype.loadMessages = function () {
        var _this = this;
        var promises = [];
        var to = this.onchainMessagesCount;
        var from = this.onchainMessagesCount - 10 > 0 ? this.onchainMessagesCount - 10 : 0;
        promises.push(this.loadOnchainMessages(from, to));
        promises.push(this.loadOffchainMessages());
        Promise.all(promises).then(function (messages) {
            var _a;
            _this.allMessages = (_a = _this.allMessages).concat.apply(_a, messages);
            _this.allMessages.sort(function (a, b) { return (Date.parse(a.date) < Date.parse(b.date)) ? 1 : ((Date.parse(b.date) < Date.parse(a.date)) ? -1 : 0); });
            _this.displayMessages.messages = _this.displayMessages.messages.concat(_this.allMessages.slice(_this.displayMessages.index, _this.displayMessages.index + 10));
            _this.$scope.$evalAsync(function () {
                _this.$timeout(0).then(function () {
                    _this.scrollElement = document.getElementById(_this.displayMessages.messages[_this.displayMessages.index].__id);
                    _this.displayMessages.index = _this.displayMessages.index + 10 <= _this.messagesCount ? _this.displayMessages.index + 10 : _this.messagesCount;
                    _this.getScrollContainer().duScrollToElement(angular.element(_this.scrollElement), 0, 1200, heat.easing.easeOutCubic);
                });
            });
        });
    };
    MsgViewerComponent.prototype.loadOnchainMessages = function (from, to) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var onchainMessages = [];
            if (from < 0 || to < 0)
                resolve(onchainMessages);
            else {
                _this.heat.api.getMessagingContactMessages(_this.account, heat.crypto.getAccountIdFromPublicKey(_this.publickey), from, to).then(function (messages) {
                    messages.forEach(function (message) { return onchainMessages.push(_this.processOnchainItem(message)); });
                    resolve(onchainMessages);
                }).catch(function () { return resolve(onchainMessages); });
            }
        });
    };
    MsgViewerComponent.prototype.loadOffchainMessages = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.messageHistory && _this.offchainPages >= 0) {
                var page = _this.messageHistory.getItems(_this.offchainPages);
                if (page.length < 10) {
                    page = page.concat(_this.messageHistory.getItems(--_this.offchainPages));
                }
                page.forEach(function (item) { return _this.processOffchainItem(item); });
                resolve(page);
            }
            else {
                resolve([]);
            }
        });
    };
    MsgViewerComponent.prototype.processOnchainItem = function (message) {
        return {
            'content': this.heat.getHeatMessageContents(message),
            'date': dateFormat(utils.timestampToDate(message.timestamp), this.dateFormat),
            'outgoing': this.account === message.sender,
            'onchain': true,
            'timestamp': message.timestamp,
            '__id': ++MsgViewerComponent_1.count
        };
    };
    MsgViewerComponent.prototype.processOffchainItem = function (item) {
        item['senderAccount'] = heat.crypto.getAccountIdFromPublicKey(item.fromPeer);
        item['outgoing'] = this.account == item['senderAccount'];
        item['date'] = dateFormat(item.timestamp, this.dateFormat);
        item['onchain'] = false;
        item['content'] = item['content'] || item['message'];
        item['__id'] = ++MsgViewerComponent_1.count;
        return item;
    };
    MsgViewerComponent.prototype.onMessageAdded = function (data, isoffchain) {
        var _this = this;
        if (isoffchain === void 0) { isoffchain = false; }
        var newMessage;
        if (isoffchain)
            newMessage = this.processOffchainItem(data);
        else
            newMessage = this.processOnchainItem(data);
        this.displayMessages.messages.splice(0, 0, newMessage);
        this.displayMessages.index++;
        this.messagesCount++;
        this.$scope.$evalAsync(function () {
            _this.$timeout(0).then(function () {
                _this.scrollElement = document.getElementById(newMessage.__id);
                _this.getScrollContainer().duScrollToElement(angular.element(_this.scrollElement), 0, 1200, heat.easing.easeOutCubic);
            });
        });
    };
    MsgViewerComponent.prototype.scrollUp = function () {
        --this.offchainPages;
        this.onchainMessagesCount -= 11;
        this.loadMessages();
    };
    MsgViewerComponent.prototype.getScrollContainer = function () {
        return angular.element(document.getElementById(this.containerId));
    };
    var MsgViewerComponent_1;
    MsgViewerComponent = MsgViewerComponent_1 = __decorate([
        Component({
            selector: 'msgViewer',
            inputs: ['publickey', '@containerId'],
            template: "\n    <div>\n      <div class=\"row\" class=\"progress-indicator\" flex ng-show=\"vm.loading\">\n        <md-progress-linear class=\"md-primary\" md-mode=\"indeterminate\"></md-progress-linear>\n      </div>\n      <div layout=\"column\" flex>\n        <div class=\"scroll-up\" layout=\"row\" flex ng-hide=\"vm.loading || vm.displayMessages.messages.length === vm.messagesCount\" layout-align=\"center\">\n          <md-button ng-click=\"vm.scrollUp()\" aria-label=\"Go up\">Go up</md-button>\n        </div>\n        <div layout=\"column\">\n          <div layout=\"column\" ng-repeat=\"message in vm.displayMessages.messages | orderBy:'date'\">\n            <message-batch-entry id=\"{{::message.__id}}\" message=\"message\" flex=\"none\" class=\"message-item\"></message-batch-entry>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('heat', 'user', '$scope', 'P2PMessaging', 'settings', '$timeout'),
        __metadata("design:paramtypes", [HeatService,
            UserService, Object, P2PMessaging,
            SettingsService, Function])
    ], MsgViewerComponent);
    return MsgViewerComponent;
}());
var P2PMessagesViewerComponent = (function () {
    function P2PMessagesViewerComponent($scope, $q, $timeout, $document, heat, user, settings, render, controlCharRender, storage, p2pMessaging) {
        var _this = this;
        this.$scope = $scope;
        this.$document = $document;
        this.heat = heat;
        this.user = user;
        this.settings = settings;
        this.render = render;
        this.controlCharRender = controlCharRender;
        this.storage = storage;
        this.p2pMessaging = p2pMessaging;
        var publicKey = this.user.key ? this.user.key.publicKey : this.user.publicKey;
        if (this.publickey == publicKey) {
            throw Error("Same public key as logged in user");
        }
        this.dateFormat = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.publickey != '0') {
            var room_5 = this.p2pMessaging.getOneToOneRoom(this.publickey, true);
            if (room_5) {
                this.p2pMessaging.updateSeenTime(room_5.name, Date.now() + 1000 * 60 * 60 * 24);
                this.datasource = new P2PMessagesDataSource(room_5.getMessageHistory(), function (item) { return _this.processItem(item); });
                room_5.onNewMessageHistoryItem = function (item) {
                    _this.datasource.first++;
                    var adapter = $scope.adapter;
                    if (adapter.isEOF()) {
                        adapter.append([_this.processItem(item)]);
                    }
                };
                $scope.$on('$destroy', function () {
                    _this.p2pMessaging.updateSeenTime(room_5.name, Date.now());
                    room_5.onNewMessageHistoryItem = null;
                });
            }
        }
    }
    P2PMessagesViewerComponent.prototype.openMenu = function ($mdMenu, event) {
        $mdMenu.open(event);
    };
    P2PMessagesViewerComponent.prototype.removeMessage = function (event, item) {
        var _this = this;
        dialogs.confirm("Remove message", "Do you want to remove the message ?").then(function () {
            _this.datasource.remove(item);
            var adapter = _this.$scope.adapter;
            adapter.applyUpdates(function (item2) {
                if (item2 == item) {
                    return [];
                }
            });
        });
    };
    P2PMessagesViewerComponent.prototype.processItem = function (item) {
        item['senderAccount'] = heat.crypto.getAccountIdFromPublicKey(item.fromPeer);
        item['outgoing'] = this.user.account == item['senderAccount'];
        item['dateFormatted'] = dateFormat(item.timestamp, this.dateFormat);
        return item;
    };
    P2PMessagesViewerComponent = __decorate([
        Component({
            selector: 'p2pMessagesViewer',
            inputs: ['publickey', '@containerId'],
            styles: ["\n    .messages {\n      overflow: auto;\n    }\n    .message-entry {\n      color: white;\n      margin-bottom: 14px;\n      margin-right: 10px;\n      // max-width: 85%;\n    }\n    .message-entry .message-content {\n      white-space: pre-line;\n    }\n    .message-entry md-icon {\n      color: green;\n      margin: 0 12px 0 0;\n    }\n    .message-entry .header {\n      padding-bottom: 6px;\n      color: grey;\n    }\n    .message-entry .menu-button {\n      color: grey !important;\n    }\n    .message-entry div.message {\n      width: 100%;\n    }\n    // .outgoing {\n    //   align-self: flex-end;\n    // }\n    .message-entry.ng-enter, .message-entry.ng-leave {\n      -webkit-transition: 0.5s linear all;\n      transition: 0.5s linear all;\n    }\n    .message-entry.ng-enter, .message-entry.ng-leave.ng-leave-active {\n      opacity: 0;\n      height: 0px;\n    }\n    .message-entry.ng-leave, .message-entry.ng-enter.ng-enter-active {\n      opacity: 1;\n      height: 40px;\n    }\n  "],
            template: "\n<div class=\"messages\" ui-scroll-viewport layout=\"column\" flex scroll-glue>\n\n  <div ui-scroll=\"item in vm.datasource\" buffer-size=\"20\" adapter=\"adapter\"\n  layout=\"row\" class=\"message-entry\" ng-class=\"{outgoing: item.outgoing}\">\n\n    <md-icon md-font-library=\"material-icons\">{{item.outgoing ? 'chat_bubble_outline' : 'comment'}}</md-icon>\n    <div layout=\"column\" class=\"message\">\n      <div class=\"header\">\n        <b ng-if=\"!item.outgoing\">{{item.senderAccount}}&nbsp;&nbsp;&nbsp;&nbsp;</b>{{::item.dateFormatted}}\n      </div>\n      <div class=\"message-content\">{{item.content}}</div>\n    </div>\n\n    <md-menu>\n      <md-button aria-label=\"Message menu\" class=\"md-icon-button menu-button\" ng-click=\"vm.openMenu($mdMenu, $event)\">\n        <!--<md-icon md-menu-origin md-svg-icon=\"call:phone\"></md-icon>-->\n        ...\n      </md-button>\n      <md-menu-content width=\"4\">\n        <md-menu-item>\n          <md-button ng-click=\"vm.removeMessage($event, item)\">\n            Remove\n          </md-button>\n        </md-menu-item>\n      </md-menu-content>\n    </md-menu>\n\n  </div>\n</div>\n  "
        }),
        Inject('$scope', '$q', '$timeout', '$document', 'heat', 'user', 'settings', 'render', 'controlCharRender', 'storage', 'P2PMessaging'),
        __metadata("design:paramtypes", [Object, Function, Function, Object, HeatService,
            UserService,
            SettingsService,
            RenderService,
            ControlCharRenderService,
            StorageService,
            P2PMessaging])
    ], P2PMessagesViewerComponent);
    return P2PMessagesViewerComponent;
}());
var P2PMessagesDataSource = (function () {
    function P2PMessagesDataSource(messageHistory, processItem) {
        this.messageHistory = messageHistory;
        this.processItem = processItem;
        this.data = [];
        this.first = 1;
    }
    P2PMessagesDataSource.prototype.get = function (index, count, success) {
        var _this = this;
        var start = index;
        var end = Math.min(index + count - 1, this.first);
        if (start <= end) {
            var lastIndex = this.messageHistory.getItemCount() - 1;
            var items = this.messageHistory.getItemsScrollable(lastIndex + start - this.first, lastIndex + end - this.first + 1)
                .map(function (item) { return _this.processItem(item); });
            success(items);
        }
        else {
            success([]);
        }
    };
    P2PMessagesDataSource.prototype.remove = function (item) {
        this.messageHistory.remove(item.timestamp);
    };
    return P2PMessagesDataSource;
}());
var P2PMessagingProbeComponent = (function () {
    function P2PMessagingProbeComponent() {
    }
    P2PMessagingProbeComponent_1 = P2PMessagingProbeComponent;
    var P2PMessagingProbeComponent_1;
    P2PMessagingProbeComponent = P2PMessagingProbeComponent_1 = __decorate([
        RouteConfig('/p2pmessagingprobe'),
        Component({
            controller: P2PMessagingProbeComponent_1,
            selector: 'probe',
            template: "\n<p>\n  My name: <input type=\"text\" ng-model=\"vm.myName\" />\n  Room: <input type=\"text\" ng-model=\"vm.roomName\" />\n  Call to Peer Id: <input type=\"text\" ng-model=\"vm.peerId\" />\n</p>\n\n<p>\n<button class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.enterRoom()\">Enter room</button>\n<button class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.canCall\" ng-click=\"vm.call()\">Call</button>\n</p>\n\n<p>Who is online: {{vm.whoIsOnline}}</p>\n\n<form ng-submit=\"vm.send()\">\n   <input type=\"text\" ng-model=\"vm.messageText\" ng-disabled=\"!vm.connected\"/>\n   <button type=\"submit\" class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\">Send</button>\n   <!--<input type=\"submit\" class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\"/>-->\n</form>\n\n<!--\n<p><input type=\"text\" ng-model=\"vm.messageText\" />\n<button class=\"md-primary md-button md-ink-ripple\" ng-disabled=\"!vm.connected\" ng-click=\"vm.send()\">Send</button>\n</p>\n-->\n\n<div style=\"overflow: scroll;\">\n  <div ng-repeat=\"message in vm.messages track by $index\">\n    <span>{{message}}</span>\n  </div>\n</div>\n\n<!--<textarea>{{vm.messageConsole}}</textarea>-->\n"
        }),
        Inject('$scope', 'user', 'sendmessage', '$interval', 'P2PConnector', 'storage', 'settings')
    ], P2PMessagingProbeComponent);
    return P2PMessagingProbeComponent;
}());
var NxtAccountComponent = (function () {
    function NxtAccountComponent($scope, nxtBlockExplorerService, nxtPendingTransactions, $interval, $mdToast, settings, user) {
        var _this = this;
        this.$scope = $scope;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
        this.nxtPendingTransactions = nxtPendingTransactions;
        this.$interval = $interval;
        this.$mdToast = $mdToast;
        this.settings = settings;
        this.user = user;
        this.pendingTransactions = [];
        this.prevIndex = 0;
        this.busy = true;
        this.refresh();
        var listener = this.updatePendingTransactions.bind(this);
        nxtPendingTransactions.addListener(listener);
        this.updatePendingTransactions();
        var promise = $interval(this.timerHandler.bind(this), 30000);
        this.timerHandler();
        $scope.$on('$destroy', function () {
            nxtPendingTransactions.removeListener(listener);
            $interval.cancel(promise);
        });
        this.sockets = [
            {
                name: 'HEAT_NXT_node',
                socketUrl: 'https://bitnode.heatwallet.com:7876/'
            },
            {
                name: 'Localhost',
                socketUrl: 'http://localhost:7876/'
            }
        ];
        this.$scope['vm'].selectSocketEndPoint = this.sockets.find(function (w) { return _this.nxtBlockExplorerService.getSocketUrl() == w.socketUrl; }).name;
    }
    NxtAccountComponent.prototype.changeSocketAddress = function () {
        var _this = this;
        var ret = this.sockets.find(function (w) { return _this.$scope['vm'].selectSocketEndPoint == w.name; });
        this.nxtBlockExplorerService.setUrl(ret.socketUrl);
    };
    NxtAccountComponent.prototype.timerHandler = function () {
        var _this = this;
        this.refresh();
        if (this.pendingTransactions.length) {
            this.prevIndex += 1;
            if (this.prevIndex >= this.pendingTransactions.length) {
                this.prevIndex = 0;
            }
            var pendingTxn_4 = this.pendingTransactions[this.prevIndex];
            this.nxtBlockExplorerService.getTransactionStatus(pendingTxn_4.txId).then(function (data) {
                if (data.confirmations) {
                    _this.$mdToast.show(_this.$mdToast.simple().textContent("Transaction with id " + pendingTxn_4.txId + " found").hideDelay(2000));
                    _this.nxtPendingTransactions.remove(pendingTxn_4.address, pendingTxn_4.txId, pendingTxn_4.time);
                }
            }, function (err) {
                console.log('Transaction not found', err);
            });
        }
    };
    NxtAccountComponent.prototype.updatePendingTransactions = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.pendingTransactions = [];
            var addr = _this.user.account;
            var txns = _this.nxtPendingTransactions.pending[addr];
            if (txns) {
                var format = _this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
                txns.forEach(function (tx) {
                    _this.pendingTransactions.push({
                        date: dateFormat(new Date(tx.time), format),
                        time: tx.time,
                        txId: tx.txId,
                        address: addr
                    });
                });
                _this.pendingTransactions.sort(function (a, b) { return b.time - a.time; });
            }
        });
    };
    NxtAccountComponent.prototype.refresh = function () {
        var _this = this;
        this.busy = true;
        this.balanceUnconfirmed = "";
        this.nxtBlockExplorerService.getAccount(this.account).then(function (info) {
            _this.$scope.$evalAsync(function () {
                _this.balanceUnconfirmed = new Big(utils.convertToQNTf(info.balanceNQT)).toFixed(8);
                _this.busy = false;
            });
        });
    };
    NxtAccountComponent = __decorate([
        RouteConfig('/nxt-account/:account'),
        Component({
            selector: 'nxtAccount',
            inputs: ['account'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"explorer-detail\">\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Address:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/nxt-account/{{vm.account}}\">{{vm.account}}</a>\n            </div>\n          </div>\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Balance: <md-progress-circular md-mode=\"indeterminate\" md-diameter=\"20px\" ng-show=\"vm.busy\"></md-progress-circular>\n            </div>\n            <div class=\"value\">\n              {{vm.balanceUnconfirmed}} NXT\n            </div>\n          </div>\n        </div>\n        <div layout=\"column\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              NXT Server:\n            </div>\n            <div class=\"value\">\n              <md-select class=\"md-select-ws\" ng-model=\"vm.selectSocketEndPoint\" ng-change=\"vm.changeSocketAddress()\">\n                <md-option ng-repeat=\"socket in vm.sockets\" value=\"{{socket.name}}\">{{socket.name}}</md-option>\n              </md-select>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <div flex layout=\"column\">\n        <div layout=\"column\" ng-if=\"vm.pendingTransactions.length\">\n          <div layout=\"row\" class=\"trader-component-title\">Pending Transactions</div>\n          <md-list flex layout-fill layout=\"column\">\n            <md-list-item class=\"header\">\n              <div class=\"truncate-col date-col left\">Time</div>\n              <div class=\"truncate-col id-col left\">Status</div>\n              <div class=\"truncate-col info-col left\" flex>Transaction Id</div>\n            </md-list-item>\n            <md-list-item ng-repeat=\"item in vm.pendingTransactions\" class=\"row\">\n              <div class=\"truncate-col date-col left\">{{item.date}}</div>\n              <div class=\"truncate-col id-col left\">\n                Pending&nbsp;<elipses-loading></elipses-loading>\n              </div>\n              <div class=\"truncate-col info-col left\" flex>\n                <span>{{item.txId}}</span>\n              </div>\n            </md-list-item>\n          </md-list>\n          <p></p>\n        </div>\n        <virtual-repeat-nxt-transactions layout=\"column\" flex layout-fill account=\"vm.account\"></virtual-repeat-nxt-transactions>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'nxtBlockExplorerService', 'nxtPendingTransactions', '$interval', '$mdToast', 'settings', 'user'),
        __metadata("design:paramtypes", [Object, NxtBlockExplorerService,
            NxtPendingTransactionsService, Function, Object, SettingsService,
            UserService])
    ], NxtAccountComponent);
    return NxtAccountComponent;
}());
var ServerComponent = (function () {
    function ServerComponent($scope, server, heat, user, settings, $mdToast) {
        var _this = this;
        this.$scope = $scope;
        this.server = server;
        this.heat = heat;
        this.user = user;
        this.settings = settings;
        this.$mdToast = $mdToast;
        this.ROW_HEIGHT = 12;
        this.calculatedTopIndex = 0;
        this.topIndex = 0;
        this.consoleRowCount = 0;
        this.isMining = false;
        this.miningRemaining = '*';
        this.miningDeadline = '*';
        this.miningHittime = '*';
        this.msgRegExp = /^([\d-]+\s[\d:]+)\s(.+)\s-\s(.*)/;
        if (user.unlocked) {
            heat.subscriber.blockPushed({ generator: user.account }, function () { _this.updateMiningInfo(); });
            heat.subscriber.blockPopped({ generator: user.account }, function () { _this.updateMiningInfo(); });
        }
        else {
            var listener_2 = function () { _this.updateMiningInfo(); };
            user.on(UserService.EVENT_UNLOCKED, listener_2);
            $scope.$on('$destroy', function () { return user.removeListener(UserService.EVENT_UNLOCKED, listener_2); });
        }
        this.hostLocal = this.settings.get(SettingsService.HEAT_HOST_LOCAL);
        this.hostRemote = this.settings.get(SettingsService.HEAT_HOST_REMOTE);
        this.portLocal = this.settings.get(SettingsService.HEAT_PORT_LOCAL);
        this.portRemote = this.settings.get(SettingsService.HEAT_PORT_REMOTE);
        this.connectedToLocalhost = this.isConnectedToLocalhost();
        SettingsService.forceServerPriority(this.isConnectedToLocalhost() ? this.hostLocal : this.hostRemote, this.isConnectedToLocalhost() ? this.portLocal : this.portRemote);
        this.onOutput = function () {
            $scope.$evalAsync(function () {
                _this.calculatedTopIndex = _this.determineTopIndex();
                if (!(_this.topIndex < (_this.calculatedTopIndex - 5)) || _this.consoleRowCount < _this.getLength()) {
                    _this.topIndex = _this.calculatedTopIndex;
                }
            });
        };
        server.addListener('output', this.onOutput);
        $scope.$on('$destroy', function () {
            server.removeListener('output', _this.onOutput);
        });
        this.updateMiningInfo();
        window.setTimeout(function () {
            _this.topIndex = _this.determineTopIndex();
            _this.onOutput();
        }, 3000);
        this.remotehostDisplay = this.hostRemote.replace('https://', '');
    }
    ServerComponent.prototype.showInstallFolder = function () {
        require('electron').shell.showItemInFolder(this.server.getAppDir('.'));
    };
    ServerComponent.prototype.showUserDataFolder = function () {
        this.server.getUserDataDirFromMainProcess().then(function (userDataDir) {
            var path = require('path');
            var dir = path.join(userDataDir);
            require('electron').shell.showItemInFolder(path.resolve(dir));
        });
    };
    ServerComponent.prototype.editFailoverConfig = function () {
        var _this = this;
        var fs = require('fs');
        var filePath = 'failover-config.json';
        fs.readFile(filePath, function (err, data) {
            if (err) {
                console.log("Cannot load 'failover-config.json': " + err);
                throw err;
            }
            dialogs.textEditor("Failover Config", data, function (editedData) {
                fs.writeFile(filePath, editedData, function (err) {
                    if (err)
                        throw err;
                    _this.settings.applyFailoverConfig();
                });
            });
        });
    };
    ServerComponent.prototype.getItemAtIndex = function (index) {
        return this.render(this.server.buffer[index]);
    };
    ServerComponent.prototype.getLength = function () {
        return this.server.buffer.length;
    };
    ServerComponent.prototype.connectToLocalhostChanged = function () {
        this.toggleConnectToLocalhost();
    };
    ServerComponent.prototype.isConnectedToLocalhost = function () {
        return this.settings.get(SettingsService.HEAT_HOST) == this.hostLocal &&
            this.settings.get(SettingsService.HEAT_PORT) == this.portLocal;
    };
    ServerComponent.prototype.toggleConnectToLocalhost = function () {
        var host = this.isConnectedToLocalhost() ? this.hostRemote : this.hostLocal;
        var port = this.isConnectedToLocalhost() ? this.portRemote : this.portLocal;
        this.settings.put(SettingsService.HEAT_HOST, host);
        this.settings.put(SettingsService.HEAT_PORT, port);
        SettingsService.forceServerPriority(host, port);
    };
    ServerComponent.prototype.startServer = function () {
        this.server.startServer();
        this.$mdToast.show(this.$mdToast.simple().textContent("In some cases you need to Start the server A SECOND TIME!\n" +
            "Wheter that's the case is indicated at the end of the log output (the colored text with black background).").hideDelay(10000));
    };
    ServerComponent.prototype.stopServer = function () {
        this.server.stopServer();
    };
    ServerComponent.prototype.determineRowCount = function () {
        var el = document.getElementById('server-console-container');
        return Math.round(el.clientHeight / this.ROW_HEIGHT);
    };
    ServerComponent.prototype.determineTopIndex = function () {
        this.consoleRowCount = this.determineRowCount();
        return Math.max(0, this.getLength() - this.consoleRowCount + 2);
    };
    ServerComponent.prototype.render = function (msg) {
        if (angular.isUndefined(msg))
            return msg;
        if (angular.isUndefined(msg.rendered)) {
            var match = this.msgRegExp.exec(msg);
            msg.rendered = match ? { timestamp: match[1], severity: match[2], message: match[3] } : { message: msg };
        }
        return msg.rendered;
    };
    ServerComponent.prototype.startMining = function () {
        var _this = this;
        this.heat.api.startMining(this.user.secretPhrase).then(function (info) {
            _this.updateMiningInfo();
        });
    };
    ServerComponent.prototype.stopMining = function () {
        var _this = this;
        this.heat.api.stopMining(this.user.secretPhrase).then(function (info) {
            _this.updateMiningInfo();
        });
    };
    ServerComponent.prototype.updateMiningInfo = function () {
        var _this = this;
        if (this.user.unlocked) {
            this.heat.api.getMiningInfo(this.user.secretPhrase).then(function (info) {
                _this.$scope.$evalAsync(function () {
                    if (info[0]) {
                        _this.isMining = true;
                        _this.miningRemaining = info[0].remaining;
                        _this.miningDeadline = info[0].deadline;
                        _this.miningHittime = info[0].hitTime;
                    }
                    else {
                        _this.isMining = false;
                    }
                });
            }, function () {
                _this.$scope.$evalAsync(function () {
                    _this.isMining = false;
                });
            });
        }
    };
    ServerComponent = __decorate([
        RouteConfig('/server'),
        Component({
            selector: 'server',
            template: "\n    <div layout=\"column\" flex layout-padding layout-fill>\n      <div layout=\"row\" class=\"button-row\">\n        <md-button class=\"start-stop\" ng-show=\"!vm.server.isRunning\" ng-click=\"vm.startServer()\">Start Server</md-button>\n        <md-button class=\"start-stop md-primary\" ng-show=\"vm.server.isRunning\" ng-click=\"vm.stopServer()\">Stop Server</md-button>\n        <md-button class=\"start-stop\" ng-click=\"vm.showInstallFolder()\">\n          <md-tooltip md-direction=\"bottom\">Access your server config files and back them up before updating HEAT server</md-tooltip>\n          Install Dir\n        </md-button>\n        <md-button class=\"start-stop\" ng-click=\"vm.showUserDataFolder()\">\n          <md-tooltip md-direction=\"bottom\">Access your user profile</md-tooltip>\n          User Dir\n        </md-button>\n\n        <md-button ng-click=\"vm.editFailoverConfig()\">\n          <md-tooltip md-direction=\"bottom\">Edit failover config</md-tooltip>\n          Failover Config\n        </md-button>\n\n        <md-switch ng-model=\"vm.connectedToLocalhost\" aria-label=\"Choose API connection\" ng-change=\"vm.connectToLocalhostChanged()\">\n          <md-tooltip md-direction=\"top\">\n            Connect client API to remotehost or to your local machine\n          </md-tooltip>\n          Client API connected to {{ vm.connectedToLocalhost ? 'localhost' : vm.remotehostDisplay }}\n        </md-switch>\n        <span flex></span>\n        <div layout=\"row\" layout-align=\"center center\" class=\"mining-stats\" ng-show=\"vm.isMining\">\n          <span>Remaining : </span>\n          <span class=\"mining-stats-val\">{{vm.miningRemaining}}</span>\n          <span>Deadline : </span>\n          <span class=\"mining-stats-val\">{{vm.miningDeadline}}</span>\n          <span>Hittime : </span>\n          <span class=\"mining-stats-val\">{{vm.miningHittime}}</span>\n        </div>\n        <md-button ng-show=\"vm.user.unlocked&&!vm.isMining\" ng-disabled=\"!vm.server.isReady\" class=\"start-stop\" ng-click=\"vm.startMining()\">Start Mining</md-button>\n        <md-button ng-show=\"vm.user.unlocked&&vm.isMining\" ng-disabled=\"!vm.server.isReady\" class=\"start-stop md-primary\" ng-click=\"vm.stopMining()\">Stop Mining</md-button>\n        <a ng-show=\"!vm.user.unlocked\" class=\"start-stop\" href=\"#/login\">Sign in to start mining</a>\n\n      </div>\n      <div layout=\"column\" flex class=\"console\" layout-fill>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\"\n            virtual-repeat-flex-helper id=\"server-console-container\">\n          <pre md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\">\n            <span ng-if=\"!item.timestamp\">{{item.message}}</span>\n            <span ng-if=\"item.timestamp\">\n              <span class=\"date\">{{item.timestamp}}&nbsp;<span class=\"severity {{item.severity}}\">{{item.severity}}</span>&nbsp;<span class=\"message\">{{item.message}}</span>\n            </span>\n          </pre>\n        </md-virtual-repeat-container>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'server', 'heat', 'user', 'settings', '$mdToast'),
        __metadata("design:paramtypes", [Object, ServerService,
            HeatService,
            UserService,
            SettingsService, Object])
    ], ServerComponent);
    return ServerComponent;
}());
var OrdersProviderFactory = (function () {
    function OrdersProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    OrdersProviderFactory.prototype.createProvider = function (currency, asset, account, isAsk) {
        return new OrdersProvider(currency, asset, account, isAsk, this.heat, this.$q);
    };
    OrdersProviderFactory = __decorate([
        Service('ordersProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], OrdersProviderFactory);
    return OrdersProviderFactory;
}());
var OrdersProvider = (function () {
    function OrdersProvider(currency, asset, account, isAsk, heat, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.isAsk = isAsk;
        this.heat = heat;
        this.$q = $q;
    }
    OrdersProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.heat.api.getAccountPairOrdersCount(this.account, this.currency, this.asset);
        }
        else if (this.isAsk) {
            return this.heat.api.getAskOrdersCount(this.currency, this.asset);
        }
        return this.heat.api.getBidOrdersCount(this.currency, this.asset);
    };
    OrdersProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.heat.api.getAccountPairOrders(this.account, this.currency, this.asset, firstIndex, lastIndex);
        }
        else if (this.isAsk) {
            return this.heat.api.getAskOrders(this.currency, this.asset, firstIndex, lastIndex);
        }
        return this.heat.api.getBidOrders(this.currency, this.asset, firstIndex, lastIndex);
    };
    return OrdersProvider;
}());
var TradesProviderFactory = (function () {
    function TradesProviderFactory(heat, $q) {
        this.heat = heat;
        this.$q = $q;
    }
    TradesProviderFactory.prototype.createProvider = function (currency, asset, account) {
        return new TradesProvider(currency, asset, account, this.heat, this.$q);
    };
    TradesProviderFactory = __decorate([
        Service('tradesProviderFactory'),
        Inject('heat', '$q'),
        __metadata("design:paramtypes", [HeatService, Function])
    ], TradesProviderFactory);
    return TradesProviderFactory;
}());
var TradesProvider = (function () {
    function TradesProvider(currency, asset, account, heat, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.heat = heat;
        this.$q = $q;
    }
    TradesProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.heat.api.getAccountTradesCount(this.account, this.currency, this.asset);
        }
        return this.heat.api.getTradesCount(this.currency, this.asset);
    };
    TradesProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.heat.api.getAccountTrades(this.account, this.currency, this.asset, firstIndex, lastIndex);
        }
        return this.heat.api.getTrades(this.currency, this.asset, firstIndex, lastIndex);
    };
    return TradesProvider;
}());
var TraderBalancesComponent = (function () {
    function TraderBalancesComponent($scope, heat, user, assetInfoService, $q) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.user = user;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.balances = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var refresh = utils.debounce((angular.bind(_this, _this.loadBalances)), 1 * 1000, false);
                heat.subscriber.balanceChanged({ account: user.account }, refresh, $scope);
                _this.loadBalances();
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderBalancesComponent.prototype.loadBalances = function () {
        var _this = this;
        this.heat.api.getAccountBalances(this.user.account, "0", 1, 0, 100).then(function (balances) {
            _this.$scope.$evalAsync(function () {
                var promises = [];
                _this.balances = balances;
                balances.forEach(function (balance) {
                    promises.push(_this.assetInfoService.getInfo(balance.id).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            balance.symbol = info.symbol;
                            balance.name = info.name;
                            balance.certified = info.certified;
                        });
                    }));
                    balance.symbol = '*';
                    balance.name = '*';
                    balance.balance = utils.formatQNT(balance.virtualBalance, balance.decimals).replace(/.00000000$/, '');
                    ;
                    if (_this.currencyInfo.id == balance.id)
                        _this.currencyInfo.userBalance = balance.virtualBalance;
                    if (_this.assetInfo.id == balance.id)
                        _this.assetInfo.userBalance = balance.virtualBalance;
                });
                _this.$q.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        balances.sort(function (a, b) {
                            if (a.certified < b.certified)
                                return 1;
                            if (a.certified > b.certified)
                                return -1;
                            if (a.symbol < b.symbol)
                                return 1;
                            if (a.symbol > b.symbol)
                                return -1;
                            return 0;
                        });
                    });
                });
            });
        });
    };
    TraderBalancesComponent = __decorate([
        Component({
            selector: 'traderBalances',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" class=\"trader-component-title\">Account&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <md-list>\n      <md-list-item class=\"header\">\n        <div class=\"truncate-col symbol-col\">Asset</div>\n        <div class=\"truncate-col balance-col right-align\" flex>Balance</div>\n      </md-list-item>\n      <md-virtual-repeat-container  flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n        <md-list-item md-virtual-repeat=\"item in vm.balances\">\n          <div class=\"truncate-col symbol-col\" ng-class=\"{certified:item.certified}\">{{item.symbol}}</div>\n          <div class=\"truncate-col balance-col right-align\" ng-class=\"{certified:item.certified}\" flex>{{item.balance}}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'user', 'assetInfo', '$q'),
        __metadata("design:paramtypes", [Object, HeatService,
            UserService,
            AssetInfoService, Function])
    ], TraderBalancesComponent);
    return TraderBalancesComponent;
}());
var TraderChartComponent = (function () {
    function TraderChartComponent($scope, heat, $q, $interval, $window) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.$q = $q;
        this.$interval = $interval;
        this.$window = $window;
        this.interval = "HOUR";
        this.filter = 'ALL';
        this.chart = { closeLine: null, close: null, closeArea: null, volumeLine: null, volumeArea: null, data: null, x: null, xAxis: null };
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        var onresize = utils.debounce(function () { _this.determineElementSize(); }, 50);
        angular.element($window).on('resize', onresize);
        var interval = $interval(function () { _this.checkForFlatline(); }, 2000);
        $scope.$on('$destroy', function () {
            angular.element($window).off('resize', onresize);
            $interval.cancel(interval);
        });
        this.refreshChartDelayed = utils.debounce(function (order) { _this.refreshChart(order); }, 5 * 1000, false);
    }
    TraderChartComponent.prototype.determineElementSize = function () {
        var ohlcchart = document.querySelector('#ohlcchart');
        if (ohlcchart && ohlcchart.offsetWidth > 0 && ohlcchart.offsetHeight > 0) {
            this.fullWidth = ohlcchart.clientWidth;
            this.fullHeight = ohlcchart.clientHeight;
            this.refresh();
            return true;
        }
        return false;
    };
    TraderChartComponent.prototype.getOHLCChartData = function () {
        if (this.filter === 'ONE_DAY' ||
            this.filter === 'ONE_HOUR' ||
            this.filter === 'FIVE_MINUTES' ||
            this.filter === 'ONE_MINUTE') {
            this.interval = 'ONE_MINUTE';
        }
        else {
            this.interval = 'HOUR';
        }
        return this.heat.api.getOHLCChartData(this.currencyInfo.id, this.assetInfo.id, this.interval);
    };
    TraderChartComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            _this.refreshChartDelayed(order);
        }, this.$scope);
    };
    TraderChartComponent.prototype.refreshChart = function (order) {
        if (order.unconfirmed === false) {
            var price = parseInt(order.price);
            var OHLCChartItemData = {
                close: price,
                date: new Date(),
                high: price,
                low: price,
                open: price,
                volume: parseInt(order.quantity)
            };
            this.update(OHLCChartItemData);
        }
    };
    TraderChartComponent.prototype.checkForFlatline = function () {
        if (this.chart.data && this.chart.data.length > 0) {
            var lastDate = this.chart.data[this.chart.data.length - 1].date.getTime();
            var now = new Date().getTime();
            var diff = (now - lastDate) / 1000;
            if (diff > 2) {
                var lastPrice = this.chart.data[this.chart.data.length - 1].close;
                var OHLCChartItemData = {
                    close: lastPrice,
                    date: new Date(),
                    high: lastPrice,
                    low: lastPrice,
                    open: lastPrice,
                    volume: 0
                };
                this.update(OHLCChartItemData);
            }
        }
    };
    TraderChartComponent.prototype.setInterval = function (interval) {
        this.interval = interval;
        this.refresh();
    };
    TraderChartComponent.prototype.setFilter = function (filter) {
        this.filter = filter;
        this.refresh();
    };
    TraderChartComponent.prototype.update = function (OHLCChartItemData) {
        this.lastTrade = OHLCChartItemData;
        this.chart.data.push(OHLCChartItemData);
        d3.select(".close-line")
            .attr("d", this.chart.closeLine)
            .attr("transform", null)
            .transition();
        d3.select(".close-area")
            .attr("d", this.chart.closeArea)
            .attr("transform", null)
            .transition();
        d3.select(".volume-line")
            .attr("d", this.chart.volumeLine)
            .attr("transform", null)
            .transition();
        d3.select(".volume-area")
            .attr("d", this.chart.volumeArea)
            .attr("transform", null)
            .transition();
        var filterDate = this.getFilterDateTime(this.filter);
        var startDate = new Date(filterDate.valueOf());
        if (this.filter == 'ALL') {
            startDate = this.chart.data[0].date;
        }
        this.chart.x.domain([startDate, new Date()]);
        d3.selectAll("g.x.axis").call(this.chart.xAxis)
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-0.5em")
            .attr("dy", "-0.05em")
            .attr("transform", "rotate(-90)");
        if (this.chart.data[0].date < filterDate) {
            this.chart.data.shift();
        }
    };
    TraderChartComponent.prototype.refresh = function () {
        var _this = this;
        this.getOHLCChartData().then(function (heatChart) {
            var margin = { top: 20, right: 80, bottom: 60, left: 50 }, width = _this.fullWidth - margin.left - margin.right, height = _this.fullHeight - margin.top - margin.bottom;
            var yClose = d3.scaleLinear()
                .range([height, 0]);
            var yVolume = d3.scaleLinear()
                .range([height, 0]);
            var tickFormat;
            if (_this.filter === 'ONE_DAY' ||
                _this.filter === 'ONE_HOUR' ||
                _this.filter === 'FIVE_MINUTES' ||
                _this.filter === 'ONE_MINUTE') {
                tickFormat = '%H:%M:%S';
            }
            else {
                tickFormat = "%m-%d";
            }
            _this.chart.x = d3.scaleTime()
                .range([0, width]);
            var volume = techan.plot.volume()
                .accessor(techan.accessor.ohlc())
                .xScale(_this.chart.x)
                .yScale(yVolume);
            _this.chart.close = techan.plot.close()
                .xScale(_this.chart.x)
                .yScale(yClose);
            _this.chart.xAxis = d3.axisBottom()
                .scale(_this.chart.x)
                .tickSize(-height)
                .tickFormat(d3.timeFormat(tickFormat));
            var yCloseAxis = d3.axisLeft()
                .scale(yClose)
                .ticks(6);
            var yVolumeAxis = d3.axisRight()
                .scale(yVolume)
                .tickFormat(d3.formatPrefix(",.0", 1e6))
                .ticks(6);
            d3.selectAll('svg').remove();
            var svg = d3.select("#ohlcchart").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            var accessor = _this.chart.close.accessor();
            var filterDate = _this.getFilterDateTime(_this.filter);
            _this.chart.data = [];
            heatChart.data.forEach(function (d) {
                var itemDate = utils.timestampToDate(d[0]);
                if (itemDate >= filterDate) {
                    _this.chart.data.push({
                        date: itemDate,
                        open: +d[5],
                        high: +d[3],
                        low: +d[2],
                        close: +d[6],
                        volume: +d[4] / 10
                    });
                }
            });
            _this.chart.data.sort(function (a, b) {
                return d3.ascending(accessor.d(a), accessor.d(b));
            });
            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")");
            svg.append("g")
                .attr("class", "yClose axis");
            svg.append("g")
                .attr("class", "yVolume axis");
            var focus = svg.append("g")
                .attr("class", "focus")
                .style("display", "none");
            focus.append("line").attr("class", "x--line")
                .style("stroke", "#FFFFFF")
                .attr("stroke-width", "1px")
                .attr("y1", -height)
                .attr("y2", 0);
            focus.append("line").attr("class", "y--line")
                .style("stroke", "#FFFFFF")
                .attr("stroke-width", "1px")
                .attr("x1", 0)
                .attr("x2", width);
            focus.append("text")
                .attr('id', 'xyValues')
                .attr("x", 0)
                .attr("y", -15)
                .attr("dy", ".35em")
                .style("fill", "white");
            focus.append("text")
                .attr('id', 'volumeValue')
                .attr("x", 0)
                .attr("y", -5)
                .attr("dy", ".35em")
                .style("fill", "white");
            svg.append("rect").attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .on("mouseover", function () { focus.style("display", null); })
                .on("mouseout", function () { focus.style("display", "none"); })
                .on("mousemove", mousemove);
            var x = _this.chart.x;
            var filter = _this.filter;
            var bisectDate = d3.bisector(function (d) { return d.date; }).left;
            var data = _this.chart.data;
            function mousemove() {
                var x0 = x.invert(d3.mouse(this)[0]), i = bisectDate(data, x0, 1), d0 = data[i - 1], d1 = data[i], d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                var xCoordinate = d.date;
                var yCoordinate = d.close;
                var yCoordinateRightAxis = d.volume / 1000000;
                focus.select(".x--line")
                    .attr("transform", "translate(" + x(d.date) + "," + (height) + ")");
                focus.select(".y--line")
                    .attr("transform", "translate(" + (0) + "," + yClose(yCoordinate) + ")");
                var xText;
                var dd = xCoordinate.getDate();
                var MM = xCoordinate.getMonth();
                var yyyy = xCoordinate.getFullYear();
                var hh = xCoordinate.getHours();
                var mm = xCoordinate.getMinutes();
                var ss = xCoordinate.getSeconds();
                if (dd < 10)
                    dd = '0' + dd;
                if (MM + 1 < 10)
                    MM = '0' + (MM + 1);
                if (hh < 10)
                    hh = '0' + hh;
                if (mm < 10)
                    mm = '0' + mm;
                if (ss < 10)
                    ss = '0' + ss;
                if (filter === 'ONE_DAY' ||
                    filter === 'ONE_HOUR' ||
                    filter === 'FIVE_MINUTES' ||
                    filter === 'ONE_MINUTE') {
                    xText = hh + ":" + mm + ":" + ss;
                }
                else {
                    xText = yyyy + "-" + MM + "-" + dd + " " + hh + ":" + mm + ":" + ss;
                }
                focus.select("#xyValues").text(xText + ", " + yCoordinate.toFixed(3));
                if (yCoordinateRightAxis) {
                    focus.select("#volumeValue").text("Volume: " + yCoordinateRightAxis.toFixed(3));
                }
            }
            var startDate = new Date(filterDate.valueOf());
            if (_this.filter == 'ALL') {
                startDate = new Date(_this.chart.data[0].date.valueOf());
            }
            yClose.domain(techan.scale.plot.ohlc(_this.chart.data, _this.chart.close.accessor()).domain());
            yVolume.domain(techan.scale.plot.volume(_this.chart.data, _this.chart.close.accessor().v).domain());
            var itemDate;
            if (_this.chart.data.length > 0) {
                _this.lastTrade = _this.chart.data[_this.chart.data.length - 1];
                itemDate = new Date(_this.chart.data[_this.chart.data.length - 1].date.valueOf());
            }
            else {
                itemDate = new Date(startDate.valueOf());
            }
            if (_this.filter === 'ONE_HOUR' ||
                _this.filter === 'FIVE_MINUTES' ||
                _this.filter === 'ONE_MINUTE') {
                var now = new Date();
                while (itemDate <= now) {
                    _this.chart.data.push({
                        date: new Date(itemDate.valueOf()),
                        open: _this.lastTrade.close,
                        high: _this.lastTrade.close,
                        low: _this.lastTrade.close,
                        close: _this.lastTrade.close,
                        volume: 0
                    });
                    itemDate.setSeconds(itemDate.getSeconds() + 2);
                }
                yClose.domain([_this.lastTrade.close - 5000, _this.lastTrade.close + 5000]);
            }
            _this.chart.x.domain([startDate, new Date()]);
            var defs = svg.append("defs");
            _this.chart.volumeArea = d3.area()
                .x(function (d) { return _this.chart.x(d.date); })
                .y0(height)
                .y1(function (d) { return yVolume(d.volume); })
                .curve(d3.curveStep);
            var volumeGradient = defs.append("linearGradient")
                .attr("id", "svgVolumeGradient")
                .attr("x1", "0%")
                .attr("x2", "0%")
                .attr("y1", "100%")
                .attr("y2", "40%");
            volumeGradient.append("stop")
                .attr('class', 'start')
                .attr("offset", "0%")
                .attr("stop-color", "#223141")
                .attr("stop-opacity", 0.1);
            volumeGradient.append("stop")
                .attr('class', 'end')
                .attr("offset", "100%")
                .attr("stop-color", "#4e5fd3")
                .attr("stop-opacity", 0.2);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "volume-area")
                .attr("fill", "url(#svgVolumeGradient)")
                .attr("d", _this.chart.volumeArea);
            _this.chart.volumeLine = d3.line()
                .x(function (d) { return _this.chart.x(d.date); })
                .y(function (d) { return yVolume(d.volume); })
                .curve(d3.curveStep);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "volume-line")
                .attr("fill", "none")
                .attr("stroke", "#4e5fd3")
                .attr("stroke-width", "1px")
                .attr("d", _this.chart.volumeLine);
            _this.chart.closeArea = d3.area()
                .x(function (d) { return _this.chart.x(d.date); })
                .y0(height)
                .y1(function (d) { return yClose(d.close); })
                .curve(d3.curveLinear);
            var closeGradient = defs.append("linearGradient")
                .attr("id", "svgCloseGradient")
                .attr("x1", "0%")
                .attr("x2", "0%")
                .attr("y1", "100%")
                .attr("y2", "40%");
            closeGradient.append("stop")
                .attr('class', 'start')
                .attr("offset", "0%")
                .attr("stop-color", "#223141")
                .attr("stop-opacity", 0.1);
            closeGradient.append("stop")
                .attr('class', 'end')
                .attr("offset", "100%")
                .attr("stop-color", "#ea543d")
                .attr("stop-opacity", 0.2);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "close-area")
                .attr("fill", "url(#svgCloseGradient)")
                .attr("d", _this.chart.closeArea);
            _this.chart.closeLine = d3.line()
                .x(function (d) { return _this.chart.x(d.date); })
                .y(function (d) { return yClose(d.close); })
                .curve(d3.curveLinear);
            svg.append("path")
                .datum(_this.chart.data)
                .attr("class", "close-line")
                .attr("fill", "none")
                .attr("stroke", "#ea543d")
                .attr("stroke-width", "1px")
                .attr("d", _this.chart.closeLine);
            svg.selectAll("g.x.axis").call(_this.chart.xAxis)
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.5em")
                .attr("dy", "-0.05em")
                .attr("transform", "rotate(-90)");
            svg.selectAll("g.x.axis")
                .selectAll("line")
                .style("stroke-opacity", "0.4")
                .style('stroke-width', '0.5px');
            svg.selectAll("g.yClose.axis").call(yCloseAxis);
            svg.selectAll("g.yVolume.axis")
                .attr("transform", "translate( " + width + ", 0 )")
                .call(yVolumeAxis);
        });
    };
    TraderChartComponent.prototype.getFilterDateTime = function (filter) {
        var filterDate = new Date();
        switch (filter) {
            case 'ONE_MONTH':
                filterDate.setMonth(filterDate.getMonth() - 1);
                break;
            case 'ONE_WEEK':
                filterDate.setDate(filterDate.getDate() - 7);
                break;
            case 'ONE_DAY':
                filterDate.setDate(filterDate.getDate() - 1);
                break;
            case 'ONE_HOUR':
                filterDate.setHours(filterDate.getHours() - 1);
                break;
            case 'FIVE_MINUTES':
                filterDate.setMinutes(filterDate.getMinutes() - 5);
                break;
            case 'ONE_MINUTE':
                filterDate.setMinutes(filterDate.getMinutes() - 1);
                break;
            default:
                filterDate.setFullYear(filterDate.getFullYear() - 100);
                break;
        }
        return filterDate;
    };
    TraderChartComponent = __decorate([
        Component({
            selector: 'traderChart',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" layout-align=\"end\" class=\"intervals\">\n        <div ng-class=\"{'selected':vm.filter=='ALL'}\" ng-click=\"vm.setFilter('ALL')\">All</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_MONTH'}\" ng-click=\"vm.setFilter('ONE_MONTH')\">1 Month</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_WEEK'}\" ng-click=\"vm.setFilter('ONE_WEEK')\">1 Week</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_DAY'}\" ng-click=\"vm.setFilter('ONE_DAY')\">1 Day</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_HOUR'}\" ng-click=\"vm.setFilter('ONE_HOUR')\">1 Hour</div>\n        <div ng-class=\"{'selected':vm.filter=='FIVE_MINUTES'}\" ng-click=\"vm.setFilter('FIVE_MINUTES')\">5 Minutes</div>\n        <div ng-class=\"{'selected':vm.filter=='ONE_MINUTE'}\" ng-click=\"vm.setFilter('ONE_MINUTE')\">1 Minutes</div>\n      </div>\n      <div layout=\"column\" flex layout-fill>\n        <div id=\"ohlcchart\" flex ng-if=\"vm.currencyInfo&&vm.assetInfo\"></div>\n      </div>\n    </div>\n  ",
            link: function (scope, element, attrs, controller) {
                function loop() {
                    if (!controller.determineElementSize()) {
                        setTimeout(loop, 50);
                    }
                }
                setTimeout(loop, 50);
            }
        }),
        Inject('$scope', 'heat', '$q', '$interval', '$window'),
        __metadata("design:paramtypes", [Object, HeatService, Function, Function, Object])
    ], TraderChartComponent);
    return TraderChartComponent;
}());
var TraderInfoAssetDescriptionComponent = (function () {
    function TraderInfoAssetDescriptionComponent($scope, settings, assetInfoService, $q, heat, user, assetWithdraw) {
        var _this = this;
        this.$scope = $scope;
        this.settings = settings;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        this.assetWithdraw = assetWithdraw;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.$scope.$evalAsync(function () {
                    _this.currencyIssuer = _this.currencyInfo.issuer;
                    _this.currencyIssuerPublicName = _this.currencyInfo.issuerPublicName;
                    _this.currencyLaunched = dateFormat(utils.timestampToDate(_this.currencyInfo.timestamp), format);
                    _this.assetIssuer = _this.assetInfo.issuer;
                    _this.assetIssuerPublicName = _this.assetInfo.issuerPublicName;
                    _this.assetLaunched = dateFormat(utils.timestampToDate(_this.assetInfo.timestamp), format);
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderInfoAssetDescriptionComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    TraderInfoAssetDescriptionComponent.prototype.showDeposit = function ($event, info) {
        dialogs.depositAsset($event, info);
    };
    TraderInfoAssetDescriptionComponent.prototype.showWithdraw = function ($event, info) {
        if (this.currencyInfo.id != '0') {
            this.assetWithdraw.dialog($event, info).then(function (dialog) {
                dialog.show();
            });
        }
    };
    TraderInfoAssetDescriptionComponent = __decorate([
        Component({
            selector: 'traderInfoAssetDescription',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div class=\"asset-container\">\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.currencyInfo)\">{{vm.currencyInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.currencyIssuer}}/transactions\">{{vm.currencyIssuerPublicName||vm.currencyIssuer}}</a>\n            </div>\n          </div>\n          <div class=\"col-item launched\">\n            <div class=\"title\">\n              Certified:\n            </div>\n            <div class=\"value\">\n              <md-icon ng-class=\"{iscertified:vm.currencyInfo.certified}\" md-font-library=\"material-icons\">{{vm.currencyInfo.certified?'check':'not_interested'}}</md-icon>\n              <span ng-if=\"vm.currencyInfo.certified == true\">Yes</span>\n              <span ng-if=\"vm.currencyInfo.certified == false\">No</span>\n            </div>\n          </div>\n          <div class=\"col-item id\">\n            <div class=\"title\">\n              Launched:\n            </div>\n            <div class=\"value\">\n              {{vm.currencyLaunched}}\n            </div>\n          </div>\n          <div class=\"col-item depositWithdraw\" ng-if=\"vm.currencyInfo.id != '0' && vm.currencyInfo.certified && vm.user.unlocked\">\n            <md-button class=\"md-primary\" ng-click=\"vm.showDeposit($event, vm.currencyInfo)\">Deposit {{vm.currencyInfo.symbol}}</md-button>\n            <md-button class=\"md-warn\" ng-click=\"vm.showWithdraw($event, vm.currencyInfo)\">Withdraw {{vm.currencyInfo.symbol}}</md-button>\n          </div>\n        </div>\n      </div>\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item header\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.assetInfo)\">{{vm.assetInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              <a href=\"#/explorer-account/{{vm.assetIssuer}}/transactions\">{{vm.assetIssuerPublicName||vm.assetIssuer}}</a>\n            </div>\n          </div>\n          <div class=\"col-item launched\">\n            <div class=\"title\">\n              Certified:\n            </div>\n            <div class=\"value\">\n              <md-icon ng-class=\"{iscertified:vm.assetInfo.certified}\" md-font-library=\"material-icons\">{{vm.assetInfo.certified?'check':'not_interested'}}</md-icon>\n              <span ng-if=\"vm.assetInfo.certified===true\">Yes</span>\n              <span ng-if=\"vm.assetInfo.certified===false\">No</span>\n            </div>\n          </div>\n          <div class=\"col-item id\">\n            <div class=\"title\">\n              Launched:\n            </div>\n            <div class=\"value\">\n              {{vm.assetLaunched}}\n            </div>\n          </div>\n          <div class=\"col-item depositWithdraw\" ng-if=\"vm.assetInfo.id != '0' && vm.assetInfo.certified && vm.user.unlocked\">\n            <md-button class=\"md-primary\" ng-click=\"vm.showDeposit($event, vm.assetInfo)\">Deposit {{vm.assetInfo.symbol}}</md-button>\n            <md-button class=\"md-warn\" ng-click=\"vm.showWithdraw($event, vm.assetInfo)\">Withdraw {{vm.assetInfo.symbol}}</md-button>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'settings', 'assetInfo', '$q', 'heat', 'user', 'assetWithdraw'),
        __metadata("design:paramtypes", [Object, SettingsService,
            AssetInfoService, Function, HeatService,
            UserService,
            AssetWithdrawService])
    ], TraderInfoAssetDescriptionComponent);
    return TraderInfoAssetDescriptionComponent;
}());
var TraderInfoComponent = (function () {
    function TraderInfoComponent() {
    }
    TraderInfoComponent = __decorate([
        Component({
            selector: 'traderInfo',
            inputs: ['currencyInfo', 'assetInfo', 'toggleMarkets', 'marketsSidenavOpen'],
            template: "\n    <div>\n      <div class=\"top-row\">\n        <div class=\"market-title\">\n          <span>\n            <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n              <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n              <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n            </md-button>\n          </span>\n          <span class=\"market-title-text\">\n            <span ng-class=\"{certified:vm.currencyInfo.certified}\">{{vm.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:vm.assetInfo.certified}\">{{vm.assetInfo.symbol}}</span>\n          </span>\n        </div>\n      </div>\n      <trader-info-asset-description currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-info-asset-description>\n    </div>\n  "
        })
    ], TraderInfoComponent);
    return TraderInfoComponent;
}());
var TraderListItemLoadingComponent = (function () {
    function TraderListItemLoadingComponent() {
    }
    TraderListItemLoadingComponent = __decorate([
        Component({
            selector: 'traderListItemLoading',
            template: "\n    <div>\n      <md-progress-circular md-mode=\"indeterminate\"></md-progress-circular>\n    </div>\n  "
        })
    ], TraderListItemLoadingComponent);
    return TraderListItemLoadingComponent;
}());
var TraderMarketsComponent = (function () {
    function TraderMarketsComponent($scope, heat, assetInfo, storage, $q, $mdToast, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.storage = storage;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.$interval = $interval;
        this.sort = 'change';
        this.asc = true;
        this.filter = '';
        this.showCertified = sessionStorage.getItem('trader.markets.showUncertified') != 'true';
        this.preMarkets = [null, null];
        this.markets = [];
        this.showFakeMarketsWarning = true;
        this.filterFunc = function (item) { return _this.filterFuncImpl(item); };
        var refresh = utils.debounce(angular.bind(this, this.loadMarkets), 5 * 1000, false);
        heat.subscriber.trade({}, refresh, $scope);
        this.loadMarkets();
        var interval = $interval(function () {
            _this.loadMarkets();
        }, 20 * 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
    }
    TraderMarketsComponent.prototype.loadMarkets = function () {
        var _this = this;
        this.heat.api.getMarketsAll(this.sort, this.asc, "0", 1, 0, 100).then(function (markets) {
            _this.$scope.$evalAsync(function () {
                if (_this.matchToPreMarkets(markets))
                    return;
                _this.markets = markets;
                var promises = [];
                _this.markets.forEach(function (market) {
                    promises.push(_this.assetInfo.getInfo(market.currency).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            market.currencyInfo = info;
                        });
                    }));
                    promises.push(_this.assetInfo.getInfo(market.asset).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            market.assetInfo = info;
                        });
                    }));
                    market.change = "" + (parseFloat(market.hr24Change) > 0 ? '+' : '') + market.hr24Change + "%";
                    market.price = utils.formatQNT(market.lastPrice, market.currencyDecimals);
                    market.vol = utils.commaFormat(Math.round(parseInt(utils.convertToQNTf(market.hr24AssetVolume))) + '');
                    market.currencyInfo = { symbol: '*' };
                    market.assetInfo = { symbol: '*' };
                });
                _this.$q.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        _this.markets.sort(function (a, b) {
                            return _this.compareMarket(a, b);
                        });
                    });
                });
                var mymarkets = _this.storage.namespace('trader').get('my-markets');
                if (angular.isArray(mymarkets)) {
                    mymarkets = mymarkets.filter(function (m) { return !_this.markets.find(function (_m) { return _m.currency == m.currency.id && _m.asset == m.asset.id; }); });
                    _this.storage.namespace('trader').put('my-markets', mymarkets);
                    var showWarning = false;
                    mymarkets.forEach(function (m) {
                        if (m.currency && m.asset) {
                            showWarning = true;
                            _this.markets.push({
                                currency: m.currency.id,
                                asset: m.asset.id,
                                change: '*',
                                price: '*',
                                vol: '*',
                                currencyInfo: { symbol: m.currency.symbol },
                                assetInfo: { symbol: m.asset.symbol }
                            });
                        }
                    });
                    if (showWarning && _this.showFakeMarketsWarning) {
                        _this.showFakeMarketsWarning = false;
                        _this.$mdToast.show(_this.$mdToast.simple()
                            .textContent("You must send at least one buy or sell order for the market to become visible in the HEAT network.")
                            .hideDelay(6000));
                    }
                }
            });
        });
    };
    TraderMarketsComponent.prototype.matchToPreMarkets = function (markets) {
        var result = true;
        if (this.preMarkets.length != markets.length) {
            result = false;
        }
        else {
            for (var i = 0; i < markets.length; ++i) {
                var market = markets[i];
                var found = false;
                for (var k = 0; k < this.preMarkets.length; ++k) {
                    var pre = this.preMarkets[k];
                    if (pre != null && market.asset == pre.asset && market.currency == pre.currency) {
                        found = true;
                        if (market.lastPrice != pre.lastPrice || market.hr24Change != pre.hr24Change
                            || market.hr24AssetVolume != pre.hr24AssetVolume || market.hr24CurrencyVolume != pre.hr24CurrencyVolume
                            || market.hr24High != pre.hr24High || market.hr24Low != pre.hr24Low) {
                            result = false;
                            break;
                        }
                    }
                }
                if (!found || !result) {
                    result = false;
                    break;
                }
            }
        }
        this.preMarkets = markets;
        return result;
    };
    TraderMarketsComponent.prototype.isSpecialMarket = function (market) {
        return market.currency == '5592059897546023466' && market.asset == '0';
    };
    TraderMarketsComponent.prototype.compareMarket = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (this.isSpecialMarket(a) && !this.isSpecialMarket(b))
            return -1;
        if (!this.isSpecialMarket(a) && this.isSpecialMarket(b))
            return 1;
        var bothCertifiedA = currencyA.certified && assetA.certified;
        var bothCertifiedB = currencyB.certified && assetB.certified;
        if (bothCertifiedA && bothCertifiedB) {
            return this.compareMarketAlphabetical(a, b);
        }
        if (bothCertifiedA != bothCertifiedB) {
            return bothCertifiedA ? -1 : 1;
        }
        var oneCertifiedA = currencyA.certified || assetA.certified;
        var oneCertifiedB = currencyB.certified || assetB.certified;
        if (oneCertifiedA && oneCertifiedB) {
            return this.compareMarketAlphabetical(a, b);
        }
        if (oneCertifiedA != oneCertifiedB) {
            return oneCertifiedA ? -1 : 1;
        }
        return this.compareMarketAlphabetical(a, b);
    };
    TraderMarketsComponent.prototype.compareMarketAlphabetical = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (currencyA.symbol < currencyB.symbol)
            return -1;
        if (currencyA.symbol > currencyB.symbol)
            return 1;
        if (assetA.symbol < assetB.symbol)
            return -1;
        if (assetA.symbol > assetB.symbol)
            return 1;
        return 0;
    };
    TraderMarketsComponent.prototype.onFilterChange = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    TraderMarketsComponent.prototype.toggleShowCertified = function () {
        var _this = this;
        this.showCertified = !this.showCertified;
        sessionStorage.setItem('trader.markets.showUncertified', this.showCertified ? 'false' : 'true');
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    TraderMarketsComponent.prototype.filterFuncImpl = function (market) {
        if (this.filter) {
            var mask = this.filter.toUpperCase();
            if (!(market.assetInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.assetInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.assetInfo.description !== null && market.assetInfo.description.toUpperCase().indexOf(mask) >= 0) ||
                market.currencyInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.currencyInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.currencyInfo.description !== null && market.currencyInfo.description.toUpperCase().indexOf(mask) >= 0))) {
                return false;
            }
        }
        if (this.showCertified && !heat.isTestnet) {
            if (market.currency != "0") {
                if (!market.currencyInfo || !market.currencyInfo.certified) {
                    return false;
                }
            }
            if (market.asset != "0") {
                if (!market.assetInfo || !market.assetInfo.certified) {
                    return false;
                }
            }
        }
        return true;
    };
    TraderMarketsComponent = __decorate([
        Component({
            selector: 'traderMarkets',
            template: "\n    <div class=\"trader-component-title\" layout=\"row\">Markets&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      <a ng-if=\"!isTestnet\" ng-click=\"vm.toggleShowCertified()\" class=\"configure\">Show {{vm.showCertified?'uncertified':'certified only'}}</a>\n    </div>\n    <input type=\"text\" placeholder=\"Search markets\" ng-model=\"vm.filter\" ng-change=\"vm.onFilterChange()\"></input>\n    <md-list flex layout-fill layout=\"column\">\n      <md-list-item>\n        <div class=\"truncate-col market-col\">Market</div>\n        <div class=\"truncate-col change-col\">Change</div>\n        <div class=\"truncate-col price-col\">Price</div>\n        <div class=\"truncate-col vol-col\" flex>Vol</div>\n      </md-list-item>\n      <md-virtual-repeat-container flex layout-fill layout=\"column\"\n          virtual-repeat-flex-helper ng-if=\"vm.markets.length>0\">\n        <md-list-item md-virtual-repeat=\"item in vm.markets | filter: vm.filterFunc\">\n          <div class=\"truncate-col market-col\">\n            <a href=\"#/trader/{{item.currency}}/{{item.asset}}\">\n              <span ng-class=\"{certified:item.currencyInfo.certified}\">{{item.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:item.assetInfo.certified}\">{{item.assetInfo.symbol}}</span>\n            </a>\n          </div>\n          <div class=\"truncate-col change-col\">{{item.change}}</div>\n          <div class=\"truncate-col price-col\">{{item.price}}</div>\n          <div class=\"truncate-col vol-col right-align\" flex>{{ item.vol }}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'assetInfo', 'storage', '$q', '$mdToast', '$interval'),
        __metadata("design:paramtypes", [Object, HeatService,
            AssetInfoService,
            StorageService, Function, Object, Function])
    ], TraderMarketsComponent);
    return TraderMarketsComponent;
}());
var TraderOrdersBuyComponent = (function (_super) {
    __extends(TraderOrdersBuyComponent, _super);
    function TraderOrdersBuyComponent($scope, $rootScope, ordersProviderFactory, $q, heat, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.heat = heat;
        _this.user = user;
        _this.currencyBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, false), function (order, context) {
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.assetInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    _this.orders.push(order);
                }, function (firstIndex, lastIndex, items) {
                    items.forEach(function (order) {
                        if (order['runningTotalQNT']) {
                            order['sum'] = utils.formatQNT(order['sumQNT'].toString(), _this.currencyInfo.decimals);
                            order['runningTotal'] = utils.formatQNT(order['runningTotalQNT'].toString(), _this.assetInfo.decimals);
                        }
                    });
                });
                unregister.forEach(function (fn) { return fn(); });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                _this.subscribeToTradeEvents(_this.currencyInfo.id, _this.assetInfo.id);
                if (_this.user.unlocked) {
                    _this.updateCurrencyBalance();
                    _this.subscribeToBalanceEvents(_this.user.account, _this.currencyInfo.id);
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateCurrencyBalance), 2000, false);
        $scope.$on('balance', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var balance = parseFloat(opts.balance);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += parseInt(_this.orders[i].quantity);
                if (totalQuantity >= balance) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var total = balance * (price);
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    TraderOrdersBuyComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('total', { total: this.currencyBalance });
    };
    TraderOrdersBuyComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            if (order.type == 'bid') {
                _this.refreshGrid();
            }
        }, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.subscribeToTradeEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.trade({ currency: currency, asset: asset }, function () {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.subscribeToBalanceEvents = function (account, currency) {
        this.heat.subscriber.balanceChanged({ account: account, currency: currency }, this.refreshBalance, this.$scope);
    };
    TraderOrdersBuyComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    TraderOrdersBuyComponent.prototype.updateCurrencyBalance = function () {
        var _this = this;
        this.heat.api.getAccountBalanceVirtual(this.user.account, this.currencyInfo.id, "0", 1).then(function (balance) {
            _this.$scope.$evalAsync(function () {
                _this.currencyBalance = utils.formatQNT(balance.virtualBalance, _this.currencyInfo.decimals);
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.currencyBalance = "0";
            });
        });
    };
    TraderOrdersBuyComponent = __decorate([
        Component({
            selector: 'traderOrdersBuy',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"popover.html\">\n      <div class=\"account-popover\">\n        <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.account||item.accountName}}</a>\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Buyers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.currencyBalance}}&nbsp;{{vm.currencyInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popover.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\",\n              >\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ordersProviderFactory', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, Object, OrdersProviderFactory, Function, HeatService,
            UserService])
    ], TraderOrdersBuyComponent);
    return TraderOrdersBuyComponent;
}(VirtualRepeatComponent));
var TraderOrdersMyComponent = (function (_super) {
    __extends(TraderOrdersMyComponent, _super);
    function TraderOrdersMyComponent($scope, ordersProviderFactory, $q, user, settings, cancelBidOrder, cancelAskOrder, heat) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.cancelBidOrder = cancelBidOrder;
        _this.cancelAskOrder = cancelAskOrder;
        _this.heat = heat;
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, user.account), function (order) {
                    order.typeDisplay = order.type == 'ask' ? 'Sell' : 'Buy';
                    order.market = _this.currencyInfo.symbol + '/' + _this.assetInfo.symbol;
                    order.quantityDisplay = utils.formatQNT(order.quantity, _this.assetInfo.decimals);
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.quantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    var date = utils.timestampToDate(order.expiration);
                    order.expires = dateFormat(date, format);
                });
                unregister.forEach(function (fn) { return fn(); });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 1000, false);
        return _this;
    }
    TraderOrdersMyComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        var filter = { currency: currency, asset: asset, account: this.user.account };
        this.heat.subscriber.order(filter, function (order) {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersMyComponent.prototype.onSelect = function (item) { };
    TraderOrdersMyComponent.prototype.cancelOrder = function (order) {
        var dialog = order.type == 'ask' ?
            this.cancelAskOrder.dialog(order.order) :
            this.cancelBidOrder.dialog(order.order);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderOrdersMyComponent = __decorate([
        Component({
            selector: 'traderOrdersMy',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.user.unlocked?'My':'All'}} pending orders&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col market-col\">Market</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col total-col\">Total ({{vm.currencyInfo.symbol}})</div>\n          <div class=\"truncate-col expires-col\" flex>Expires</div>\n          <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\"\n              ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col type-col\">{{item.typeDisplay}}</div>\n            <div class=\"truncate-col market-col\">{{item.market}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col expires-col\" flex tooltip=\"{{item.expires}}\">{{item.expires}}</div>\n            <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\">\n              <a ng-if=\"!item.cancelled && !item.unconfirmed\" ng-click=\"vm.cancelOrder(item)\">Cancel</a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', 'ordersProviderFactory', '$q', 'user', 'settings', 'cancelBidOrder', 'cancelAskOrder', 'heat'),
        __metadata("design:paramtypes", [Object, OrdersProviderFactory, Function, UserService,
            SettingsService,
            CancelBidOrderService,
            CancelAskOrderService,
            HeatService])
    ], TraderOrdersMyComponent);
    return TraderOrdersMyComponent;
}(VirtualRepeatComponent));
var TraderOrdersSellComponent = (function (_super) {
    __extends(TraderOrdersSellComponent, _super);
    function TraderOrdersSellComponent($scope, $rootScope, ordersProviderFactory, $q, heat, user) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.heat = heat;
        _this.user = user;
        _this.assetBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, true), function (order, context) {
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.assetInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    _this.orders.push(order);
                }, function (firstIndex, lastIndex, items) {
                    items.forEach(function (order) {
                        if (order['runningTotalQNT']) {
                            order['sum'] = utils.formatQNT(order['sumQNT'].toString(), _this.currencyInfo.decimals);
                            order['runningTotal'] = utils.formatQNT(order['runningTotalQNT'].toString(), _this.assetInfo.decimals);
                        }
                    });
                });
                _this.subscribeToOrderEvents(_this.currencyInfo.id, _this.assetInfo.id);
                _this.subscribeToTradeEvents(_this.currencyInfo.id, _this.assetInfo.id);
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateAssetBalance();
                    _this.subscribeToBalanceEvents(_this.user.account, _this.assetInfo.id);
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateAssetBalance), 2000, false);
        $scope.$on('total', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var total = parseFloat(opts.total);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += (parseFloat(_this.orders[i].quantity) / 100000000);
                if (totalQuantity >= total) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var balance = total / price;
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    TraderOrdersSellComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('balance', { balance: this.assetBalance });
    };
    TraderOrdersSellComponent.prototype.subscribeToOrderEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.order({ currency: currency, asset: asset }, function (order) {
            if (order.type == 'ask') {
                _this.refreshGrid();
            }
        }, this.$scope);
    };
    TraderOrdersSellComponent.prototype.subscribeToTradeEvents = function (currency, asset) {
        var _this = this;
        this.heat.subscriber.trade({ currency: currency, asset: asset }, function () {
            _this.refreshGrid();
        }, this.$scope);
    };
    TraderOrdersSellComponent.prototype.subscribeToBalanceEvents = function (account, currency) {
        this.heat.subscriber.balanceChanged({ account: account, currency: currency }, this.refreshBalance, this.$scope);
    };
    TraderOrdersSellComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    TraderOrdersSellComponent.prototype.updateAssetBalance = function () {
        var _this = this;
        this.heat.api.getAccountBalanceVirtual(this.user.account, this.assetInfo.id, "0", 1).then(function (balance) {
            _this.$scope.$evalAsync(function () {
                _this.assetBalance = utils.formatQNT(balance.virtualBalance, _this.assetInfo.decimals);
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                _this.assetBalance = "0";
            });
        });
    };
    TraderOrdersSellComponent = __decorate([
        Component({
            selector: 'traderOrdersSell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"templateId.tml\">\n      <div class=\"account-popover\">\n        <a href=\"#/explorer-account/{{item.account}}/transactions\">{{item.account||item.accountName}}</a>\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Sellers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.assetBalance}}&nbsp;{{vm.assetInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item  class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n           <div class=\"truncate-col info-col\">\n             <div\n              class=\"info\"\n              angular-popover\n              direction=\"right\"\n              template-url=\"templateId.tml\"\n              mode=\"mouseover\"\n              style=\"position: absolute;\">\n             </div>\n             <img src=\"assets/info.png\">\n           </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ordersProviderFactory', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, Object, OrdersProviderFactory, Function, HeatService,
            UserService])
    ], TraderOrdersSellComponent);
    return TraderOrdersSellComponent;
}(VirtualRepeatComponent));
heat.Loader.directive("maxDecimals", ['$mdToast', function ($mdToast) {
        return {
            require: 'ngModel',
            link: function (scope, elem, attr, ngModel) {
                var decimals;
                var notifyUser = utils.debounce(function () {
                    $mdToast.show($mdToast.simple().textContent("Too many decimals, max " + decimals + " allowed").hideDelay(3000));
                }, 500, true);
                ngModel.$parsers.unshift(function (value) {
                    decimals = parseInt(attr.maxDecimals);
                    var valid = !utils.hasToManyDecimals(value, decimals);
                    ngModel.$setValidity('decimals', valid);
                    if (!valid) {
                        notifyUser();
                    }
                    return valid ? value : undefined;
                });
            }
        };
    }]);
var TraderQuickBuySellComponent = (function () {
    function TraderQuickBuySellComponent($scope, $q, $mdToast, placeAskOrder, placeBidOrder, user, settings) {
        var _this = this;
        this.$scope = $scope;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.placeAskOrder = placeAskOrder;
        this.placeBidOrder = placeBidOrder;
        this.user = user;
        this.settings = settings;
        this.quantity = '0';
        this.price = '0';
        this.total = null;
        this.fee = utils.formatQNT(HeatAPI.fee.standard, 8);
        this.EXPIRY_MIN = 3600;
        this.EXPIRY_MAX = 3600 * 24 * 30;
        this.expiryUnitsOptions = {
            'minutes': {
                label: 'Minutes',
                min: Math.round(this.EXPIRY_MIN / 60),
                max: Math.round(this.EXPIRY_MAX / 60),
                delta: 60
            },
            'hours': {
                label: 'Hours',
                min: Math.round(this.EXPIRY_MIN / (60 * 60)),
                max: Math.round(this.EXPIRY_MAX / (60 * 60)),
                delta: 60 * 60
            },
            'days': {
                label: 'Days',
                min: 1,
                max: 30,
                delta: (60 * 60 * 24)
            },
            'weeks': {
                label: 'Weeks',
                min: 1,
                max: 4,
                delta: (60 * 60 * 24 * 7)
            }
        };
        this.expiryUnits = 'days';
        this.expiryUnitsValue = 30;
        this.expiresTooltip = '';
        $scope.$on('price', function (event, opts) {
            _this.price = opts.price.toFixed(8);
            _this.quantity = opts.balance.toFixed(8);
            _this.total = opts.total.toFixed(8);
        });
        $scope.$watch('vm.selectedOrder', function () {
            if (_this.selectedOrder) {
                _this.quantity = _this.selectedOrder['runningTotal'];
                _this.price = utils.formatQNT(_this.selectedOrder.price, _this.currencyInfo.decimals);
                _this.total = _this.selectedOrder['sum'];
                if (_this.selectedOrder.type == 'bid' && angular.isString(_this.assetInfo.userBalance)) {
                    var quantityQNT = new Big(utils.convertToQNT(utils.unformat(_this.quantity)));
                    var balanceQNT = new Big(_this.assetInfo.userBalance);
                    if (balanceQNT.lt(quantityQNT)) {
                        _this.quantity = utils.formatQNT(_this.assetInfo.userBalance, 8);
                        _this.recalculate();
                    }
                }
                else if (_this.selectedOrder.type == 'ask' && angular.isString(_this.currencyInfo.userBalance)) {
                    var totalQNT = new Big(utils.convertToQNT(utils.unformat(_this.total)));
                    var balanceQNT = new Big(_this.currencyInfo.userBalance);
                    if (balanceQNT.lt(totalQNT)) {
                        _this.total = utils.formatQNT(_this.currencyInfo.userBalance, 8);
                        _this.recalculateTotal();
                    }
                }
            }
        });
        this.isTestnet = heat.isTestnet;
        this.notifyUser = utils.debounce(function (text) {
            $mdToast.show($mdToast.simple().textContent(text).hideDelay(3000));
        }, 500, true);
        this.expiryUnitsValueChanged(true);
    }
    TraderQuickBuySellComponent.prototype.expiryUnitsValueChanged = function (suppressNotification) {
        this.expiry = parseInt(this.expiryUnitsValue + '') * this.expiryUnitsOptions[this.expiryUnits].delta;
        this.expiryValid = false;
        this.expiresTooltip = '';
        if (this.expiry <= this.EXPIRY_MAX && this.expiry >= this.EXPIRY_MIN) {
            this.expiryValid = true;
            var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
            var date = new Date(Date.now() + (this.expiry * 1000));
            var dateFormatted = dateFormat(date, format);
            this.expiresTooltip = "This order will expiry if (even partially) unfilled by " + dateFormatted;
        }
        else {
            var min = this.expiryUnitsOptions[this.expiryUnits].min;
            var max = this.expiryUnitsOptions[this.expiryUnits].max;
            var units = this.expiryUnitsOptions[this.expiryUnits].label;
            this.expiresTooltip = "Min expiry in " + units + " is " + min + ", max expiry in " + units + " is " + max;
            this.notifyUser(this.expiresTooltip);
        }
    };
    TraderQuickBuySellComponent.prototype.quickAsk = function ($event) {
        if (angular.isString(this.assetInfo.userBalance)) {
            var quantityQNT = new Big(utils.convertToQNT(utils.unformat(this.quantity)));
            var balanceQNT = new Big(this.assetInfo.userBalance);
            if (balanceQNT.lt(quantityQNT)) {
                this.notifyUser("Insufficient " + this.assetInfo.symbol + " balance");
                return;
            }
        }
        var dialog = this.placeAskOrder.dialog(this.currencyInfo, this.assetInfo, utils.unformat(this.price), utils.unformat(this.quantity), parseInt(this.expiry + ''), true, $event);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderQuickBuySellComponent.prototype.quickBid = function ($event) {
        if (angular.isString(this.currencyInfo.userBalance)) {
            var totalQNT = new Big(utils.convertToQNT(utils.unformat(this.total)));
            var balanceQNT = new Big(this.currencyInfo.userBalance);
            if (balanceQNT.lt(totalQNT)) {
                this.notifyUser("Insufficient " + this.currencyInfo.symbol + " balance");
                return;
            }
        }
        var dialog = this.placeBidOrder.dialog(this.currencyInfo, this.assetInfo, utils.unformat(this.price), utils.unformat(this.quantity), parseInt(this.expiry + ''), true, $event);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    TraderQuickBuySellComponent.prototype.calculateTotalPrice = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                return "";
            }
            else {
                var quantityQNT = utils.convertToQNT(quantity);
                var priceQNT = utils.convertToQNT(price);
                var totalQNT = utils.calculateTotalOrderPriceQNT(quantityQNT, priceQNT);
                return utils.formatQNT(totalQNT, this.currencyInfo.decimals, true);
            }
        }
        catch (e) {
            return "";
        }
    };
    TraderQuickBuySellComponent.prototype.recalculate = function () {
        this.total = this.calculateTotalPrice();
    };
    TraderQuickBuySellComponent.prototype.recalculateTotal = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var total = utils.unformat(this.total) || "0";
            if (price == "0" || total == "0") {
                this.quantity = "0";
            }
            else {
                this.quantity = new Big(total).div(new Big(price)).toFixed(this.assetInfo.decimals).toString();
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    TraderQuickBuySellComponent = __decorate([
        Component({
            selector: 'traderQuickBuySell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder', 'oneClickOrders'],
            template: "\n    <div>\n      <div class=\"trader-component-title\">Buy/Sell&nbsp;<elipses-loading ng-show=\"vm.loading\"></elipses-loading></div>\n      <form name=\"quickBuySellForm\">\n        <div class=\"row\">\n          <div class=\"label\">\n            Unit price\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-price-input\" type=\"text\" ng-model=\"vm.price\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculate()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}} / {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Amount\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-quantity-input\" type=\"text\" ng-model=\"vm.quantity\" required max-decimals=\"{{vm.assetInfo.decimals}}\"\n              ng-change=\"vm.recalculate()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Fees\n          </div>\n          <div class=\"fee input\">\n            {{vm.fee}}\n          </div>\n          <div class=\"label\">\n            HEAT\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\" ng-class=\"{'expires-invalid': !vm.expiryValid}\">\n            Expires in\n          </div>\n          <div class=\"input\">\n            <input type=\"number\" ng-model=\"vm.expiryUnitsValue\" required name=\"expiry\"\n                      ng-change=\"vm.expiryUnitsValueChanged()\"\n                      min=\"{{vm.expiryUnitsOptions[vm.expiryUnits].min}}\"\n                      max=\"{{vm.expiryUnitsOptions[vm.expiryUnits].max}}\"\n                      ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            <md-menu>\n              <a ng-click=\"$mdMenu.open($event)\">\n                <md-tooltip>{{vm.expiresTooltip}}</md-tooltip>\n                {{vm.expiryUnitsOptions[vm.expiryUnits].label}}\n              </a>\n              <md-menu-content width=\"4\">\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='minutes';vm.expiryUnitsValueChanged()\">Minutes</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='hours';vm.expiryUnitsValueChanged()\">Hours</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='days';vm.expiryUnitsValueChanged()\">Days</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='weeks';vm.expiryUnitsValueChanged()\">Weeks</md-button>\n                </md-menu-item>\n              </md-menu-content>\n            </md-menu>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Total\n          </div>\n          <div class=\"input\">\n            <input type=\"text\" id=\"trader-quick-buy-sell-total-input\" ng-model=\"vm.total\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}}\n          </div>\n        </div>\n        <div ng-hide=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <md-button class=\"md-primary\" aria-label=\"Sign in\" href=\"#/login\">\n            Sign in to trade\n          </md-button>\n        </div>\n        <div ng-show=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <div>\n            <md-button class=\"md-primary\" aria-label=\"Buy\" ng-click=\"vm.quickBid($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              BUY\n            </md-button>\n          </div>\n          <div>\n            <md-switch ng-model=\"vm.oneClickOrders\" aria-label=\"1-click orders\" class=\"md-primary\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n              <span ng-show=\"vm.oneClickOrders\"><b>1-click orders enabled</b></span><span ng-hide=\"vm.oneClickOrders\">1-click orders disabled</span>\n            </md-switch>\n          </div>\n          <div>\n            <md-button class=\"md-warn\" aria-label=\"Sell\" ng-click=\"vm.quickAsk($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              SELL\n            </md-button>\n          </div>\n        </div>\n      </form>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$mdToast', 'placeAskOrder', 'placeBidOrder', 'user', 'settings'),
        __metadata("design:paramtypes", [Object, Function, Object, PlaceAskOrderService,
            PlaceBidOrderService,
            UserService,
            SettingsService])
    ], TraderQuickBuySellComponent);
    return TraderQuickBuySellComponent;
}());
var TraderTradeHistoryComponent = (function (_super) {
    __extends(TraderTradeHistoryComponent, _super);
    function TraderTradeHistoryComponent($scope, $window, tradesProviderFactory, $q, user, settings, heat) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$window = $window;
        _this.tradesProviderFactory = tradesProviderFactory;
        _this.user = user;
        _this.settings = settings;
        _this.heat = heat;
        _this.showTheseTrades = "all";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.createProvider();
                unregister.forEach(function (fn) { return fn(); });
                var refresh = utils.debounce((angular.bind(_this, _this.determineLength)), 1 * 1000, false);
                heat.subscriber.trade({}, function (trade) {
                    if (trade.currency == _this.currencyInfo.id && trade.asset == _this.assetInfo.id) {
                        var account = _this.showTheseTrades == 'all' ? null : _this.user.account;
                        if (account) {
                            if (trade.seller != account && trade.buyer != account) {
                                return;
                            }
                        }
                        refresh();
                    }
                }, $scope);
                heat.subscriber.blockPopped({}, refresh, $scope);
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        return _this;
    }
    TraderTradeHistoryComponent.prototype.createProvider = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.$window.innerWidth < 870) {
            format = this.settings.get(SettingsService.TIMEFORMAT_DEFAULT);
        }
        var account = this.showTheseTrades == 'all' ? null : this.user.account;
        this.initializeVirtualRepeat(this.tradesProviderFactory.createProvider(this.currencyInfo.id, this.assetInfo.id, account), function (trade) {
            var date = utils.timestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            if (account) {
                trade.type = trade.seller == account ? 'Sell' : 'Buy';
            }
            else {
                trade.type = trade.isBuy ? 'Buy' : 'Sell';
            }
            trade.priceDisplay = utils.formatQNT(trade.price, _this.currencyInfo.decimals);
            trade.quantityDisplay = utils.formatQNT(trade.quantity, _this.assetInfo.decimals);
            var totalQNT = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
            trade.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
            trade.virtual = trade.block == "0";
        });
    };
    TraderTradeHistoryComponent.prototype.onSelect = function (item) { };
    TraderTradeHistoryComponent.prototype.updateView = function () {
        if (this.currencyInfo && this.assetInfo) {
            this.createProvider();
        }
    };
    TraderTradeHistoryComponent.prototype.onResize = function () {
        this.updateView();
    };
    TraderTradeHistoryComponent = __decorate([
        Component({
            selector: 'traderTradeHistory',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n  <script type=\"text/ng-template\" id=\"popoverHistory.html\">\n    <div class=\"account-popover\">\n      <div>Buyer: <a href=\"#/explorer-account/{{item.buyer}}/transactions\">{{item.buyerName||item.buyer}}</a></div>\n      <div>Seller: <a href=\"#/explorer-account/{{item.seller}}/transactions\">{{item.sellerName||item.seller}}</a></div>\n    </div>\n  </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">Past trades&nbsp;\n        <span flex></span>\n        <span layout=\"row\" ng-if=\"vm.user.unlocked\" class=\"selector\">\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"all\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show all trades</i>\n          </label>\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"my\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show my trades</i>\n          </label>\n        </span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col time-col\" flex>Time</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">{{vm.assetInfo.symbol}}</div>\n          <div class=\"truncate-col total-col\" flex>Total ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" ng-class=\"{'virtual': item.virtual}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popoverHistory.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\">\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col type-col\">{{item.type}}</div>\n            <div class=\"truncate-col time-col\" flex>{{item.time}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\" flex>{{item.total}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$window', 'tradesProviderFactory', '$q', 'user', 'settings', 'heat'),
        __metadata("design:paramtypes", [Object, Object, TradesProviderFactory, Function, UserService,
            SettingsService,
            HeatService])
    ], TraderTradeHistoryComponent);
    return TraderTradeHistoryComponent;
}(VirtualRepeatComponent));
var TraderTrollboxComponent = (function () {
    function TraderTrollboxComponent($q, $scope, trollbox, $timeout, user) {
        var _this = this;
        this.$q = $q;
        this.$scope = $scope;
        this.trollbox = trollbox;
        this.$timeout = $timeout;
        this.user = user;
        this.messages = [];
        this.nameRegexp = /^(.+)\s\[(\d+)\]$/;
        trollbox.getMessages().forEach(function (promise) {
            promise.then(function (messages) {
                $scope.$evalAsync(function () {
                    var ar = messages.map(function (message) {
                        return _this.augmentMessage(message);
                    });
                    _this.messages = _this.messages.concat(ar);
                });
            });
        });
        trollbox.subscribe(function (event) {
            $scope.$evalAsync(function () {
                if (angular.isObject(event) && angular.isString(event.username) && angular.isString(event.text)) {
                    if (event.username.length > 0 && event.text.length > 0) {
                        _this.messages.push(_this.augmentMessage(event));
                    }
                }
            });
        }, $scope);
        if (angular.isString(user.accountName)) {
            this.name = user.accountName.replace(/@heatwallet.com$/, "");
        }
    }
    TraderTrollboxComponent.prototype.augmentMessage = function (message) {
        if (message.username) {
            var match = message.username.match(this.nameRegexp);
            if (match) {
                message['name'] = match[1];
                message['account'] = match[2];
            }
        }
        try {
            message['text'] = decodeURIComponent(message['text']);
        }
        catch (e) { }
        return message;
    };
    TraderTrollboxComponent.prototype.joinChat = function () {
        this.trollbox.join(this.name);
    };
    TraderTrollboxComponent.prototype.onTextAreaKeyPress = function ($event) {
        var _this = this;
        if ($event.keyCode == 13 && !$event.shiftKey && utils.emptyToNull(this.messageText)) {
            this.trollbox.sendMessage(this.messageText);
            this.$scope.$evalAsync(function () {
                _this.messageText = null;
            });
        }
    };
    TraderTrollboxComponent = __decorate([
        Component({
            selector: 'traderTrollbox',
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div class=\"trader-component-title\">Trollbox&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n<!--\n        <a href=\"https://t.me/joinchat/Bs91sA3agGFXqLaZwWMogg\" target=\"_blank\">Join Telegram!\n          <md-tooltip md-direction=\"bottom\">\n            This trollbox is connected to our Telegram #trollbox channel, post either here or on #trollbox and chat in realtime.\n          </md-tooltip>\n        </a>\n-->\n<!--\n        <a href=\"https://heat-slack.herokuapp.com\" target=\"_blank\">Join Slack!\n          <md-tooltip md-direction=\"bottom\">\n            This trollbox is connected to our Slack #trollbox channel, post either here or on #trollbox and chat in realtime.\n          </md-tooltip>\n        </a>\n-->\n      </div>\n      <div layout=\"row\">\n        <div flex>\n          <input type=\"text\" placeholder=\"Type your name here\" ng-model=\"vm.name\"\n                  ng-disabled=\"!vm.user.unlocked\"></input>\n        </div>\n        <div>\n          <button class=\"md-primary md-button md-ink-ripple\" ng-click=\"vm.joinChat()\" ng-disabled=\"!vm.name || vm.trollbox.name\">Join</button>\n        </div>\n      </div>\n      <div layout=\"column\" flex>\n        <ul class=\"display\" scroll-glue>\n          <li ng-repeat=\"item in vm.messages\">\n            <span><a ng-if=\"item.account\" href=\"#/explorer-account/{{item.account}}/transactions\">{{item.name}}</a>\n            <b ng-if=\"!item.account\">{{item.username}}</b>: {{item.text}}</span>\n          </li>\n        </ul>\n      </div>\n      <div layout=\"row\">\n        <textarea rows=\"2\" ng-keypress=\"vm.onTextAreaKeyPress($event)\"\n          ng-disabled=\"!vm.user.unlocked || !vm.trollbox.name\"\n          placeholder=\"ENTER to send, SHIFT+ENTER for new line\" ng-model=\"vm.messageText\"></textarea>\n      </div>\n    </div>\n  "
        }),
        Inject('$q', '$scope', 'trollbox', '$timeout', 'user'),
        __metadata("design:paramtypes", [Function, Object, TrollboxService, Function, UserService])
    ], TraderTrollboxComponent);
    return TraderTrollboxComponent;
}());
var TraderVolumeComponent = (function () {
    function TraderVolumeComponent($scope, heat, $interval) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.$interval = $interval;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                unregister.forEach(function (fn) { return fn(); });
                _this.loadMarket();
                var interval_1 = $interval(function () {
                    _this.loadMarket();
                }, 10 * 1000, 0, false);
                $scope.$on('$destroy', function () { $interval.cancel(interval_1); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    TraderVolumeComponent.prototype.loadMarket = function () {
        var _this = this;
        this.heat.api.getMarket(this.currencyInfo.id, this.assetInfo.id, "0", 1).then(function (market) {
            _this.$scope.$evalAsync(function () {
                _this.hr24Change = "" + (parseFloat(market.hr24Change) > 0 ? '+' : '') + market.hr24Change + "%";
                _this.hr24High = utils.formatQNT(market.hr24High, market.currencyDecimals);
                _this.hr24Low = utils.formatQNT(market.hr24Low, market.currencyDecimals);
                _this.hr24CurrencyVolume = utils.formatQNT(market.hr24CurrencyVolume, market.currencyDecimals) + ' ' + _this.currencyInfo.symbol;
                _this.hr24AssetVolume = utils.formatQNT(market.hr24AssetVolume, market.assetDecimals) + ' ' + _this.assetInfo.symbol;
            });
        });
    };
    TraderVolumeComponent = __decorate([
        Component({
            selector: 'traderVolume',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" flex layout-fill layout-align=\"end\">\n      <div class=\"label\">24h change</div>\n      <div class=\"value\">{{vm.hr24Change}}</div>\n      <div class=\"label\">24h high</div>\n      <div class=\"value\">{{vm.hr24High}}</div>\n      <div class=\"label\">24h low</div>\n      <div class=\"value\">{{vm.hr24Low}}</div>\n      <div class=\"label\">24h vol</div>\n      <div class=\"value\">{{vm.hr24CurrencyVolume}}</div>\n      <div class=\"label\">24h vol</div>\n      <div>{{vm.hr24AssetVolume}}</div>\n    </div>\n  "
        }),
        Inject('$scope', 'heat', '$interval'),
        __metadata("design:paramtypes", [Object, HeatService, Function])
    ], TraderVolumeComponent);
    return TraderVolumeComponent;
}());
var TraderComponent = (function () {
    function TraderComponent($scope, user, $timeout, assetInfoService, $mdSidenav) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.$timeout = $timeout;
        this.assetInfoService = assetInfoService;
        this.$mdSidenav = $mdSidenav;
        this.marketCurrency = "0";
        this.marketSort = "change";
        this.marketAsc = "false";
        this.marketsSidenavOpen = true;
        this.marketsSidenavLockedOpen = true;
        this.showMarketNotCertified = undefined;
        this.toggleMarkets = function () {
            var sidenav = _this.$mdSidenav("trader-markets-sidenav");
            if (sidenav.isOpen()) {
                _this.marketsSidenavLockedOpen = false;
                sidenav.close();
            }
            else {
                _this.marketsSidenavLockedOpen = true;
                sidenav.open();
            }
        };
        assetInfoService.getInfo(this.currency).then(function (info) {
            $scope.$evalAsync(function () {
                _this.currencyInfo = info;
            });
        });
        assetInfoService.getInfo(this.asset).then(function (info) {
            $scope.$evalAsync(function () {
                _this.assetInfo = info;
            });
        });
        this.user.account = user.account || "";
        this.isTestnet = heat.isTestnet;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.showMarketNotCertified = !_this.currencyInfo.certified || !_this.assetInfo.certified;
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        setTimeout(function () {
            if (!angular.isDefined(_this.showMarketNotCertified)) {
                $scope.$evalAsync(function () {
                    _this.showMarketNotCertified = true;
                });
            }
        }, 2000);
    }
    TraderComponent = __decorate([
        RouteConfig('/trader/:currency/:asset'),
        Component({
            selector: 'trader',
            inputs: ['currency', 'asset'],
            template: "\n    <div layout=\"row\">\n      <!--\n      <div>\n        <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n          <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n          <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n        </md-button>\n      </div>\n      -->\n      <span flex></span>\n      <trader-volume class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" layout=\"column\"></trader-volume>\n    </div>\n    <div layout=\"row\" flex layout-fill>\n      <md-sidenav class=\"md-sidenav-left\" md-component-id=\"trader-markets-sidenav\"\n          md-is-locked-open=\"vm.marketsSidenavLockedOpen\" md-is-open=\"vm.marketsSidenavOpen\"\n          md-disable-backdrop flex layout-fill>\n        <div class=\"sidenav-container\">\n          <trader-balances currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" ng-if=\"vm.user.unlocked\"></trader-balances>\n          <trader-markets></trader-markets>\n        </div>\n      </md-sidenav>\n      <div layout=\"column\" flex layout-fill class=\"main-display\">\n        <div>\n          <div ng-if=\"vm.showMarketNotCertified\">\n            <div class=\"top-warning\">CAUTION: This market comprises unverified asset from 3rd party outside the scope of Heat Ledger Ltd redemption gateway.</div>\n          </div>\n          <div class=\"trader-row top\">\n              <trader-info class=\"trader-component\" toggle-markets=\"vm.toggleMarkets\" markets-sidenav-open=\"vm.marketsSidenavOpen\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-info>\n              <trader-chart class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-chart>\n          </div>\n          <div class=\"trader-row middle\">\n            <trader-orders-buy class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-orders-buy>\n            <trader-quick-buy-sell class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-quick-buy-sell>\n            <trader-orders-sell class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"l></trader-orders-sell>\n          </div>\n          <div class=\"trader-row bottom\">\n            <trader-trade-history class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-trade-history>\n            <trader-orders-my ng-if=\"vm.user.unlocked\" class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-orders-my>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', '$timeout', 'assetInfo', '$mdSidenav'),
        __metadata("design:paramtypes", [Object, UserService, Function, AssetInfoService, Function])
    ], TraderComponent);
    return TraderComponent;
}());
var TokenBalance = (function () {
    function TokenBalance(name, symbol, address) {
        this.name = name;
        this.symbol = symbol;
        this.address = address;
        this.isTokenBalance = true;
        this.visible = false;
    }
    return TokenBalance;
}());
var CurrencyBalance = (function () {
    function CurrencyBalance(name, symbol, address, secretPhrase, parentAccountSecretPhrase) {
        this.name = name;
        this.symbol = symbol;
        this.address = address;
        this.secretPhrase = secretPhrase;
        this.parentAccountSecretPhrase = parentAccountSecretPhrase;
        this.isCurrencyBalance = true;
        this.inUse = false;
        this.tokens = [];
        this.visible = false;
    }
    CurrencyBalance.prototype.unlock = function (noPathChange) {
        var user = heat.$inject.get('user');
        var $location = heat.$inject.get('$location');
        var lightwalletService = heat.$inject.get('lightwalletService');
        var bip44Compatible = lightwalletService.validSeed(this.secretPhrase);
        var currency = null;
        var key = null;
        if (this.name == 'Ethereum') {
            currency = new ETHCurrency(this.secretPhrase, this.address);
        }
        else if (this.name == 'Bitcoin') {
            currency = new BTCCurrency(this.secretPhrase, this.address);
        }
        else if (this.name == 'FIMK') {
            currency = new FIMKCurrency(this.secretPhrase, this.address);
        }
        else if (this.name == 'NXT') {
            currency = new NXTCurrency(this.secretPhrase, this.address);
        }
        else if (this.name == 'Iota') {
            currency = new IOTACurrency(this.secretPhrase, this.address);
        }
        else if (this.name == 'ARDOR') {
            currency = new ARDRCurrency(this.secretPhrase, this.address);
        }
        else {
            currency = new HEATCurrency(this.secretPhrase, this.address);
        }
        var publicKey = heat.crypto.secretPhraseToPublicKey(this.parentAccountSecretPhrase);
        var account = heat.crypto.getAccountIdFromPublicKey(publicKey);
        var localKeyStore = heat.$inject.get('localKeyStore');
        key = {
            secretPhrase: this.parentAccountSecretPhrase,
            publicKey: publicKey,
            account: account,
            pincode: localKeyStore.getPasswordForAccount(account),
            name: localKeyStore.keyName(account)
        };
        user.unlock(this.secretPhrase, key, bip44Compatible, currency).then(function () {
            if (!noPathChange) {
                $location.path(currency.homePath);
                heat.fullApplicationScopeReload();
            }
        });
    };
    return CurrencyBalance;
}());
var CurrencyAddressLoading = (function () {
    function CurrencyAddressLoading(name) {
        this.name = name;
        this.isCurrencyAddressLoading = true;
        this.visible = false;
    }
    return CurrencyAddressLoading;
}());
var CurrencyAddressCreate = (function () {
    function CurrencyAddressCreate(name, wallet) {
        this.name = name;
        this.wallet = wallet;
        this.isCurrencyAddressCreate = true;
        this.visible = false;
        this.hidden = true;
        this.distinctValues = function (value, index, self) {
            return self.indexOf(value) === index;
        };
    }
    CurrencyAddressCreate.prototype.getStore = function () {
        var storage = heat.$inject.get('storage');
        var $rootScope = heat.$inject.get('$rootScope');
        return storage.namespace('wallet', $rootScope, true);
    };
    CurrencyAddressCreate.prototype.getCurrencies = function (account) {
        var currencies = this.getStore().get(account);
        if (!currencies)
            currencies = [];
        return currencies;
    };
    CurrencyAddressCreate.prototype.addCurrency = function (account, currency) {
        var store = this.getStore();
        var currencies = this.getCurrencies(account);
        currencies.push(currency);
        store.put(account, currencies.filter(this.distinctValues));
    };
    CurrencyAddressCreate.prototype.createAddress = function (component) {
        var _this = this;
        var currencyBalances = this.parent.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == _this.name; });
        if (currencyBalances.length == 0) {
            var nextAddress = this.wallet.addresses[0];
            var newCurrencyBalance = new CurrencyBalance('Ethereum', 'ETH', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
            component.rememberAdressCreated(this.parent.account, nextAddress.address);
            newCurrencyBalance.visible = this.parent.expanded;
            this.flatten();
            this.addCurrency(this.parent.account, 'ETH');
            return true;
        }
        var lastAddress = currencyBalances[currencyBalances.length - 1]['address'];
        if (!currencyBalances[currencyBalances.length - 1]['inUse']) {
            return false;
        }
        for (var i = 0; i < this.wallet.addresses.length; i++) {
            if (this.wallet.addresses[i].address == lastAddress) {
                if (i == this.wallet.addresses.length - 1)
                    return;
                var nextAddress = this.wallet.addresses[i + 1];
                var newCurrencyBalance = new CurrencyBalance('Ethereum', 'ETH', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
                component.rememberAdressCreated(this.parent.account, nextAddress.address);
                newCurrencyBalance.visible = this.parent.expanded;
                var index = this.parent.currencies.indexOf(currencyBalances[currencyBalances.length - 1]) + 1;
                this.parent.currencies.splice(index, 0, newCurrencyBalance);
                this.flatten();
                this.addCurrency(this.parent.account, 'ETH');
                return true;
            }
        }
        return false;
    };
    CurrencyAddressCreate.prototype.createBtcAddress = function (component) {
        var _this = this;
        var currencyBalances = this.parent.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == _this.name; });
        if (currencyBalances.length == 0) {
            var nextAddress = this.wallet.addresses[0];
            var newCurrencyBalance = new CurrencyBalance('Bitcoin', 'BTC', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
            component.rememberAdressCreated(this.parent.account, nextAddress.address);
            newCurrencyBalance.visible = this.parent.expanded;
            this.flatten();
            this.addCurrency(this.parent.account, 'BTC');
            return true;
        }
        var lastAddress = currencyBalances[currencyBalances.length - 1]['address'];
        if (!currencyBalances[currencyBalances.length - 1]['inUse']) {
            return false;
        }
        for (var i = 0; i < this.wallet.addresses.length; i++) {
            if (this.wallet.addresses[i].address == lastAddress) {
                if (i == this.wallet.addresses.length - 1)
                    return;
                var nextAddress = this.wallet.addresses[i + 1];
                var newCurrencyBalance = new CurrencyBalance('Bitcoin', 'BTC', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
                component.rememberAdressCreated(this.parent.account, nextAddress.address);
                newCurrencyBalance.visible = this.parent.expanded;
                var index = this.parent.currencies.indexOf(currencyBalances[currencyBalances.length - 1]) + 1;
                this.parent.currencies.splice(index, 0, newCurrencyBalance);
                this.flatten();
                this.addCurrency(this.parent.account, 'BTC');
                return true;
            }
        }
        return false;
    };
    CurrencyAddressCreate.prototype.createFIMKAddress = function (component) {
        var _this = this;
        var currencyBalances = this.parent.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == _this.name; });
        if (currencyBalances.length == 0) {
            var nextAddress = this.wallet.addresses[0];
            var newCurrencyBalance = new CurrencyBalance('FIMK', 'FIM', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
            component.rememberAdressCreated(this.parent.account, nextAddress.address);
            newCurrencyBalance.visible = this.parent.expanded;
            this.flatten();
            this.addCurrency(this.parent.account, 'FIM');
            return true;
        }
        return false;
    };
    CurrencyAddressCreate.prototype.createNXTAddress = function (component) {
        var _this = this;
        var currencyBalances = this.parent.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == _this.name; });
        if (currencyBalances.length == 0) {
            var nextAddress = this.wallet.addresses[0];
            var newCurrencyBalance = new CurrencyBalance('NXT', 'NXT', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
            component.rememberAdressCreated(this.parent.account, nextAddress.address);
            newCurrencyBalance.visible = this.parent.expanded;
            this.flatten();
            this.addCurrency(this.parent.account, 'NXT');
            return true;
        }
        return false;
    };
    CurrencyAddressCreate.prototype.createARDRAddress = function (component) {
        var _this = this;
        var currencyBalances = this.parent.currencies.filter(function (c) { return c['isCurrencyBalance'] && c.name == _this.name; });
        if (currencyBalances.length == 0) {
            var nextAddress = this.wallet.addresses[0];
            var newCurrencyBalance = new CurrencyBalance('ARDOR', 'ARDR', nextAddress.address, nextAddress.privateKey, this.parent.secretPhrase);
            component.rememberAdressCreated(this.parent.account, nextAddress.address);
            newCurrencyBalance.visible = this.parent.expanded;
            this.flatten();
            this.addCurrency(this.parent.account, 'ARDR');
            return true;
        }
        return false;
    };
    return CurrencyAddressCreate;
}());
var WalletEntry = (function () {
    function WalletEntry(account, name, component) {
        this.account = account;
        this.name = name;
        this.component = component;
        this.isWalletEntry = true;
        this.selected = true;
        this.currencies = [];
        this.unlocked = false;
        this.visible = true;
        this.expanded = false;
        this.btcWalletAddressIndex = 0;
        this.identifier = name ? name + " | " + account : account;
    }
    WalletEntry.prototype.toggle = function (forceVisible) {
        var _this = this;
        this.expanded = forceVisible || !this.expanded;
        this.currencies.forEach(function (curr) {
            var currency = curr;
            currency.visible = _this.expanded;
            if (currency.tokens) {
                currency.tokens.forEach(function (token) {
                    token.visible = _this.expanded;
                });
            }
        });
        if (this.expanded) {
            this.component.loadEthereumAddresses(this);
            this.component.loadBitcoinAddresses(this);
            this.component.loadFIMKAddresses(this);
            this.component.loadNXTAddresses(this);
            this.component.loadARDORAddresses(this);
            this.component.loadIotaAddresses(this);
        }
    };
    WalletEntry.prototype.showSecretPhrase = function () {
        var panel = heat.$inject.get('panel');
        panel.show("\n      <div layout=\"column\" flex class=\"toolbar-copy-passphrase\">\n        <md-input-container flex>\n          <textarea rows=\"2\" flex ng-bind=\"vm.secretPhrase\" readonly ng-trim=\"false\"></textarea>\n        </md-input-container>\n      </div>\n    ", {
            secretPhrase: this.secretPhrase
        });
    };
    return WalletEntry;
}());
var WalletComponent = (function () {
    function WalletComponent($scope, $q, localKeyStore, walletFile, $window, lightwalletService, heat, assetInfo, ethplorer, $mdToast, $mdDialog, clipboard, user, bitcoreService, fimkCryptoService, nxtCryptoService, ardorCryptoService, nxtBlockExplorerService, ardorBlockExplorerService, mofoSocketService, iotaCoreService, storage, $rootScope) {
        var _this = this;
        this.$scope = $scope;
        this.$q = $q;
        this.localKeyStore = localKeyStore;
        this.walletFile = walletFile;
        this.$window = $window;
        this.lightwalletService = lightwalletService;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.ethplorer = ethplorer;
        this.$mdToast = $mdToast;
        this.$mdDialog = $mdDialog;
        this.clipboard = clipboard;
        this.user = user;
        this.bitcoreService = bitcoreService;
        this.fimkCryptoService = fimkCryptoService;
        this.nxtCryptoService = nxtCryptoService;
        this.ardorCryptoService = ardorCryptoService;
        this.nxtBlockExplorerService = nxtBlockExplorerService;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.mofoSocketService = mofoSocketService;
        this.iotaCoreService = iotaCoreService;
        this.storage = storage;
        this.$rootScope = $rootScope;
        this.selectAll = true;
        this.allLocked = true;
        this.entries = [];
        this.walletEntries = [];
        this.createdAddresses = {};
        this.chains = [{ name: 'ETH', disabled: false }, { name: 'BTC', disabled: false }, { name: 'FIMK', disabled: false }, { name: 'NXT', disabled: true }, { name: 'ARDR', disabled: true }, { name: 'IOTA', disabled: false }];
        this.selectedChain = '';
        this.store = this.storage.namespace('wallet', $rootScope, true);
        nxtBlockExplorerService.getBlockchainStatus().then(function () {
            var nxtChain = { name: 'NXT', disabled: false };
            var index = _this.chains.findIndex(function (entry) { return entry.name === nxtChain.name; });
            _this.chains[index] = nxtChain;
        });
        ardorBlockExplorerService.getBlockchainStatus().then(function () {
            var ardorChain = { name: 'ARDR', disabled: false };
            var index = _this.chains.findIndex(function (entry) { return entry.name === ardorChain.name; });
            _this.chains[index] = ardorChain;
        });
        this.initLocalKeyStore();
        this.initCreatedAddresses();
    }
    WalletComponent.prototype.createAccount = function ($event) {
        if (this.$scope['vm'].selectedChain === 'ETH') {
            this.createEthAccount($event);
        }
        else if (this.$scope['vm'].selectedChain === 'BTC') {
            this.createBtcAccount($event);
        }
        else if (this.$scope['vm'].selectedChain === 'FIMK') {
            this.createFIMKAccount($event);
        }
        else if (this.$scope['vm'].selectedChain === 'NXT') {
            this.createNXTAccount($event);
        }
        else if (this.$scope['vm'].selectedChain === 'ARDR') {
            this.createARDRAccount($event);
        }
        else if (this.$scope['vm'].selectedChain === 'IOTA') {
            this.createIotaAccount($event);
        }
        this.$scope['vm'].selectedChain = null;
    };
    WalletComponent.prototype.initLocalKeyStore = function () {
        var _this = this;
        this.entries = [];
        this.walletEntries = [];
        this.localKeyStore.list().map(function (account) {
            var name = _this.localKeyStore.keyName(account);
            var walletEntry = new WalletEntry(account, name, _this);
            _this.walletEntries.push(walletEntry);
        });
        this.walletEntries.forEach(function (walletEntry) {
            var password = _this.localKeyStore.getPasswordForAccount(walletEntry.account);
            if (password) {
                try {
                    var key = _this.localKeyStore.load(walletEntry.account, password);
                    if (key) {
                        walletEntry.secretPhrase = key.secretPhrase;
                        walletEntry.bip44Compatible = _this.lightwalletService.validSeed(key.secretPhrase);
                        walletEntry.unlocked = true;
                        walletEntry.pin = password;
                        _this.initWalletEntry(walletEntry);
                    }
                }
                catch (e) {
                    console.log(e);
                }
            }
        });
        this.flatten();
        this.fetchCryptoAddresses('BTC');
    };
    WalletComponent.prototype.initCreatedAddresses = function () {
        for (var i = 0; i < window.localStorage.length; i++) {
            var key = window.localStorage.key(i);
            var data = key.match(/eth-address-created:(.+):(.+)/);
            if (data) {
                var acc = data[1], addr = data[2];
                this.createdAddresses[acc] = this.createdAddresses[acc] || [];
                this.createdAddresses[acc].push(addr);
            }
        }
    };
    WalletComponent.prototype.rememberAdressCreated = function (account, ethAddress) {
        this.createdAddresses[account] = this.createdAddresses[account] || [];
        this.createdAddresses[account].push(ethAddress);
        window.localStorage.setItem("eth-address-created:" + account + ":" + ethAddress, "1");
    };
    WalletComponent.prototype.flatten = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.entries = [];
            _this.walletEntries.forEach(function (walletEntry) {
                _this.entries.push(walletEntry);
                walletEntry.currencies = walletEntry.currencies.filter(function (currency, index, self) {
                    return index === self.findIndex(function (t) { return (t.name === currency.name && t.address === currency.address); });
                });
                walletEntry.currencies.forEach(function (curr) {
                    var currencyBalance = curr;
                    _this.entries.push(currencyBalance);
                    if (currencyBalance.tokens) {
                        currencyBalance.tokens.forEach(function (tokenBalance) {
                            _this.entries.push(tokenBalance);
                        });
                    }
                });
            });
        });
    };
    WalletComponent.prototype.shareCurrencyAddressesWithP2pContacts = function (currency, address) {
        var p2pContactsUtils = heat.$inject.get('p2pContactUtils');
        var p2pMessaging = heat.$inject.get('P2PMessaging');
        p2pMessaging.p2pContactStore.forEach(function (key, contact) {
            console.log("sharing key " + address + " of currency " + currency + " with p2p contact: " + contact.account);
            p2pContactsUtils.shareCryptoAddress(contact, currency, address);
        });
    };
    WalletComponent.prototype.fetchCryptoAddresses = function (currency) {
        var p2pContactsUtils = heat.$inject.get('p2pContactUtils');
        var p2pMessaging = heat.$inject.get('P2PMessaging');
        p2pMessaging.p2pContactStore.forEach(function (key, contact) {
            console.log("fetching " + currency + " of p2p contact: " + contact.account);
            p2pContactsUtils.fetchCryptoAddress(contact, currency);
        });
    };
    WalletComponent.prototype.pageAddAddSecretPhrase = function ($event) {
        var _this = this;
        this.promptSecretPlusPassword($event).then(function (data) {
            var account = heat.crypto.getAccountId(data.secretPhrase);
            var publicKey = heat.crypto.secretPhraseToPublicKey(data.secretPhrase);
            var key = {
                account: account,
                secretPhrase: data.secretPhrase,
                pincode: data.password,
                name: '',
                publicKey: publicKey
            };
            _this.localKeyStore.add(key);
            _this.$scope.$evalAsync(function () {
                _this.initLocalKeyStore();
            });
        });
    };
    WalletComponent.prototype.pageAddFileInputChange = function (files) {
        var _this = this;
        if (files && files[0]) {
            var reader_2 = new FileReader();
            reader_2.onload = function () {
                _this.$scope.$evalAsync(function () {
                    var fileContents = reader_2.result;
                    var wallet = _this.walletFile.createFromText(fileContents);
                    if (wallet) {
                        var addedKeys = _this.localKeyStore.import(wallet);
                        _this.$scope.$evalAsync(function () {
                            _this.initLocalKeyStore();
                        });
                        var message = "Imported " + addedKeys.length + " keys into this device";
                        _this.$mdToast.show(_this.$mdToast.simple().textContent(message).hideDelay(5000));
                    }
                });
            };
            reader_2.readAsText(files[0]);
        }
    };
    WalletComponent.prototype.remove = function ($event, entry) {
        var _this = this;
        dialogs.prompt($event, 'Remove Wallet Entry', "This completely removes the wallet entry from your device.\n       Please enter your Password (or Pin Code) to confirm you wish to remove this entry", '').then(function (pin) {
            if (pin == entry.pin) {
                _this.localKeyStore.remove(entry.account);
                _this.initLocalKeyStore();
                if (entry.account === _this.user.key.account) {
                    _this.heat.api.getKeystoreEntryCountByAccount(entry.account).then(function (count) {
                        if (count > 0) {
                            _this.shareCurrencyAddressesWithP2pContacts('BTC', '');
                        }
                    });
                }
            }
        });
    };
    WalletComponent.prototype.unlock = function ($event, selectedWalletEntry) {
        var _this = this;
        dialogs.prompt($event, 'Enter Password (or Pin)', 'Please enter your Password (or Pin Code) to unlock', '').then(function (pin) {
            var count = 0;
            _this.walletEntries.forEach(function (walletEntry) {
                if (!walletEntry.secretPhrase) {
                    var key = _this.localKeyStore.load(walletEntry.account, pin);
                    if (key) {
                        count += 1;
                        _this.localKeyStore.rememberPassword(walletEntry.account, pin);
                        walletEntry.pin = pin;
                        walletEntry.secretPhrase = key.secretPhrase;
                        walletEntry.bip44Compatible = _this.lightwalletService.validSeed(key.secretPhrase);
                        walletEntry.unlocked = true;
                        _this.initWalletEntry(walletEntry);
                    }
                }
            });
            var message = "Unlocked " + (count ? count : 'NO') + " entries";
            _this.$mdToast.show(_this.$mdToast.simple().textContent(message).hideDelay(5000));
            selectedWalletEntry.toggle(true);
            if (!_this.user.unlocked) {
                if (selectedWalletEntry.unlocked) {
                    for (var i = 0; i < selectedWalletEntry.currencies.length; i++) {
                        var balance = selectedWalletEntry.currencies[i];
                        if (balance.isCurrencyBalance) {
                            balance.unlock(true);
                            return;
                        }
                    }
                }
                for (var i = 0; i < _this.entries.length; i++) {
                    var balance = selectedWalletEntry.currencies[i];
                    if (balance.isCurrencyBalance) {
                        balance.unlock(true);
                        return;
                    }
                }
            }
        });
    };
    WalletComponent.prototype.initWalletEntry = function (walletEntry) {
        var _this = this;
        this.allLocked = false;
        var heatAccount = heat.crypto.getAccountIdFromPublicKey(heat.crypto.secretPhraseToPublicKey(walletEntry.secretPhrase));
        var heatCurrencyBalance = new CurrencyBalance('HEAT', 'HEAT', heatAccount, walletEntry.secretPhrase, walletEntry.secretPhrase);
        heatCurrencyBalance.visible = walletEntry.expanded;
        walletEntry.currencies.push(heatCurrencyBalance);
        this.flatten();
        this.heat.api.getAccountByNumericId(heatAccount).then(function (account) {
            _this.$scope.$evalAsync(function () {
                var balanceUnconfirmed = utils.formatQNT(account.unconfirmedBalance, 8);
                heatCurrencyBalance.balance = balanceUnconfirmed;
            });
            _this.getAccountAssets(heatAccount).then(function (assetInfos) {
                heatCurrencyBalance.tokens = [];
                assetInfos.forEach(function (assetInfo) {
                    var tokenBalance = new TokenBalance(assetInfo.name, assetInfo.symbol, assetInfo.id);
                    tokenBalance.balance = utils.formatQNT(assetInfo.userBalance, 8);
                    tokenBalance.visible = walletEntry.expanded;
                    heatCurrencyBalance.tokens.push(tokenBalance);
                });
                _this.flatten();
            });
        }, function () {
            _this.$scope.$evalAsync(function () {
                heatCurrencyBalance.balance = "Address is unused";
                heatCurrencyBalance.symbol = '';
            });
        });
        var selectedCurrencies = this.store.get(walletEntry.account);
        if (!selectedCurrencies || selectedCurrencies.includes('BTC'))
            this.bitcoreService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                if (wallet !== undefined) {
                    var btcCurrencyAddressLoading = new CurrencyAddressLoading('Bitcoin');
                    btcCurrencyAddressLoading.visible = walletEntry.expanded;
                    btcCurrencyAddressLoading.wallet = wallet;
                    walletEntry.currencies.push(btcCurrencyAddressLoading);
                    var btcCurrencyAddressCreate = new CurrencyAddressCreate('Bitcoin', wallet);
                    btcCurrencyAddressCreate.visible = walletEntry.expanded;
                    btcCurrencyAddressCreate.parent = walletEntry;
                    btcCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                    walletEntry.currencies.push(btcCurrencyAddressCreate);
                    _this.flatten();
                    if (_this.user.key.account === walletEntry.account)
                        _this.shareCurrencyAddressesWithP2pContacts('BTC', wallet.addresses[0].address);
                    if (walletEntry.expanded) {
                        _this.loadBitcoinAddresses(walletEntry);
                    }
                }
            });
        if (!selectedCurrencies || selectedCurrencies.includes('ETH'))
            this.lightwalletService.unlock(walletEntry.secretPhrase, "").then(function (wallet) {
                var ethCurrencyAddressLoading = new CurrencyAddressLoading('Ethereum');
                ethCurrencyAddressLoading.visible = walletEntry.expanded;
                ethCurrencyAddressLoading.wallet = wallet;
                walletEntry.currencies.push(ethCurrencyAddressLoading);
                var ethCurrencyAddressCreate = new CurrencyAddressCreate('Ethereum', wallet);
                ethCurrencyAddressCreate.visible = walletEntry.expanded;
                ethCurrencyAddressCreate.parent = walletEntry;
                ethCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                walletEntry.currencies.push(ethCurrencyAddressCreate);
                _this.flatten();
                if (walletEntry.expanded) {
                    _this.loadEthereumAddresses(walletEntry);
                }
            });
        if (!selectedCurrencies || selectedCurrencies.includes('IOTA'))
            this.iotaCoreService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                var iotaCurrencyAddressLoading = new CurrencyAddressLoading('Iota');
                iotaCurrencyAddressLoading.visible = walletEntry.expanded;
                iotaCurrencyAddressLoading.wallet = wallet;
                walletEntry.currencies.push(iotaCurrencyAddressLoading);
                var iotaCurrencyAddressCreate = new CurrencyAddressCreate('Iota', wallet);
                iotaCurrencyAddressCreate.visible = walletEntry.expanded;
                iotaCurrencyAddressCreate.parent = walletEntry;
                iotaCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                walletEntry.currencies.push(iotaCurrencyAddressCreate);
                _this.flatten();
                if (walletEntry.expanded) {
                    _this.loadIotaAddresses(walletEntry);
                }
            });
        if (!selectedCurrencies || selectedCurrencies.includes('FIM'))
            this.fimkCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                var fimkCurrencyAddressCreate = new CurrencyAddressCreate('FIMK', wallet);
                fimkCurrencyAddressCreate.visible = walletEntry.expanded;
                fimkCurrencyAddressCreate.parent = walletEntry;
                fimkCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                walletEntry.currencies.push(fimkCurrencyAddressCreate);
                _this.mofoSocketService.mofoSocket().then(function () {
                    var fimkCurrencyAddressLoading = new CurrencyAddressLoading('FIMK');
                    fimkCurrencyAddressLoading.visible = walletEntry.expanded;
                    fimkCurrencyAddressLoading.wallet = wallet;
                    walletEntry.currencies.push(fimkCurrencyAddressLoading);
                    if (walletEntry.expanded) {
                        _this.loadFIMKAddresses(walletEntry);
                    }
                });
            });
        if (!selectedCurrencies || selectedCurrencies.includes('NXT'))
            this.nxtCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                var nxtCurrencyAddressCreate = new CurrencyAddressCreate('NXT', wallet);
                nxtCurrencyAddressCreate.visible = walletEntry.expanded;
                nxtCurrencyAddressCreate.parent = walletEntry;
                nxtCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                walletEntry.currencies.push(nxtCurrencyAddressCreate);
                _this.nxtBlockExplorerService.getBlockchainStatus().then(function () {
                    var nxtCurrencyAddressLoading = new CurrencyAddressLoading('NXT');
                    nxtCurrencyAddressLoading.visible = walletEntry.expanded;
                    nxtCurrencyAddressLoading.wallet = wallet;
                    walletEntry.currencies.push(nxtCurrencyAddressLoading);
                    if (walletEntry.expanded) {
                        _this.loadNXTAddresses(walletEntry);
                    }
                });
            });
        if (!selectedCurrencies || selectedCurrencies.includes('ARDR'))
            this.ardorCryptoService.unlock(walletEntry.secretPhrase).then(function (wallet) {
                var ardorCurrencyAddressCreate = new CurrencyAddressCreate('ARDOR', wallet);
                ardorCurrencyAddressCreate.visible = walletEntry.expanded;
                ardorCurrencyAddressCreate.parent = walletEntry;
                ardorCurrencyAddressCreate.flatten = _this.flatten.bind(_this);
                walletEntry.currencies.push(ardorCurrencyAddressCreate);
                _this.ardorBlockExplorerService.getBlockchainStatus().then(function () {
                    var ardorCurrencyAddressLoading = new CurrencyAddressLoading('ARDOR');
                    ardorCurrencyAddressLoading.visible = walletEntry.expanded;
                    ardorCurrencyAddressLoading.wallet = wallet;
                    walletEntry.currencies.push(ardorCurrencyAddressLoading);
                    if (walletEntry.expanded) {
                        _this.loadARDORAddresses(walletEntry);
                    }
                });
            });
    };
    WalletComponent.prototype.loadNXTAddresses = function (walletEntry) {
        var _this = this;
        var nxtCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'NXT'; });
        if (!nxtCurrencyAddressLoading)
            return;
        this.nxtCryptoService.refreshAdressBalances(nxtCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(nxtCurrencyAddressLoading);
            nxtCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var nxtCurrencyBalance_1 = new CurrencyBalance('NXT', 'NXT', address.address, address.privateKey, walletEntry.secretPhrase);
                    nxtCurrencyBalance_1.balance = address.balance ? address.balance + "" : "0";
                    nxtCurrencyBalance_1.visible = walletEntry.expanded;
                    nxtCurrencyBalance_1.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, nxtCurrencyBalance_1);
                    index++;
                    if (address.tokensBalances) {
                        address.tokensBalances.forEach(function (balance) {
                            var tokenBalance = new TokenBalance(balance.name, balance.symbol, balance.address);
                            tokenBalance.balance = utils.commaFormat(balance.balance);
                            tokenBalance.visible = walletEntry.expanded;
                            nxtCurrencyBalance_1.tokens.push(tokenBalance);
                        });
                    }
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != nxtCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.loadARDORAddresses = function (walletEntry) {
        var _this = this;
        var ardorCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'ARDOR'; });
        if (!ardorCurrencyAddressLoading)
            return;
        this.ardorCryptoService.refreshAdressBalances(ardorCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(ardorCurrencyAddressLoading);
            ardorCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var nxtCurrencyBalance_2 = new CurrencyBalance('ARDOR', 'ARDR', address.address, address.privateKey, walletEntry.secretPhrase);
                    nxtCurrencyBalance_2.balance = address.balance ? address.balance + "" : "0";
                    nxtCurrencyBalance_2.visible = walletEntry.expanded;
                    nxtCurrencyBalance_2.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, nxtCurrencyBalance_2);
                    index++;
                    if (address.tokensBalances) {
                        address.tokensBalances.forEach(function (balance) {
                            var tokenBalance = new TokenBalance(balance.name, balance.symbol, balance.address);
                            tokenBalance.balance = utils.commaFormat(balance.balance);
                            tokenBalance.visible = walletEntry.expanded;
                            nxtCurrencyBalance_2.tokens.push(tokenBalance);
                        });
                    }
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != ardorCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.loadFIMKAddresses = function (walletEntry) {
        var _this = this;
        var fimkCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'FIMK'; });
        if (!fimkCurrencyAddressLoading)
            return;
        this.fimkCryptoService.refreshAdressBalances(fimkCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(fimkCurrencyAddressLoading);
            fimkCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var fimkCurrencyBalance_1 = new CurrencyBalance('FIMK', 'FIM', address.address, address.privateKey, walletEntry.secretPhrase);
                    fimkCurrencyBalance_1.balance = address.balance ? address.balance + "" : "0";
                    fimkCurrencyBalance_1.visible = walletEntry.expanded;
                    fimkCurrencyBalance_1.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, fimkCurrencyBalance_1);
                    index++;
                    if (address.tokensBalances) {
                        address.tokensBalances.forEach(function (balance) {
                            var tokenBalance = new TokenBalance(balance.name, balance.symbol, balance.address);
                            tokenBalance.balance = utils.commaFormat(balance.balance);
                            tokenBalance.visible = walletEntry.expanded;
                            fimkCurrencyBalance_1.tokens.push(tokenBalance);
                        });
                    }
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != fimkCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.loadEthereumAddresses = function (walletEntry) {
        var _this = this;
        var ethCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'Ethereum'; });
        if (!ethCurrencyAddressLoading)
            return;
        this.lightwalletService.refreshAdressBalances(ethCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(ethCurrencyAddressLoading);
            ethCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var ethCurrencyBalance_1 = new CurrencyBalance('Ethereum', 'ETH', address.address, address.privateKey, walletEntry.secretPhrase);
                    ethCurrencyBalance_1.balance = Number(address.balance + "").toFixed(18);
                    ethCurrencyBalance_1.visible = walletEntry.expanded;
                    ethCurrencyBalance_1.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, ethCurrencyBalance_1);
                    index++;
                    if (address.tokensBalances) {
                        address.tokensBalances.forEach(function (balance) {
                            var tokenBalance = new TokenBalance(balance.name, balance.symbol, balance.address);
                            tokenBalance.balance = utils.commaFormat(balance.balance);
                            tokenBalance.visible = walletEntry.expanded;
                            ethCurrencyBalance_1.tokens.push(tokenBalance);
                        });
                    }
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != ethCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.loadIotaAddresses = function (walletEntry) {
        var _this = this;
        var iotaCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'Iota'; });
        if (!iotaCurrencyAddressLoading)
            return;
        this.iotaCoreService.refreshAdressBalances(iotaCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(iotaCurrencyAddressLoading);
            iotaCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var iotaCurrencyBalance = new CurrencyBalance('Iota', 'i', address.address, address.privateKey, walletEntry.secretPhrase);
                    iotaCurrencyBalance.balance = Number(address.balance + "").toFixed(0);
                    iotaCurrencyBalance.visible = walletEntry.expanded;
                    iotaCurrencyBalance.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, iotaCurrencyBalance);
                    index++;
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != iotaCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.loadBitcoinAddresses = function (walletEntry) {
        var _this = this;
        var btcCurrencyAddressLoading = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressLoading && c.name == 'Bitcoin'; });
        if (!btcCurrencyAddressLoading)
            return;
        this.bitcoreService.refreshAdressBalances(btcCurrencyAddressLoading.wallet).then(function () {
            if (!walletEntry.currencies.find(function (c) { return c['isCurrencyAddressLoading']; }))
                return;
            var index = walletEntry.currencies.indexOf(btcCurrencyAddressLoading);
            btcCurrencyAddressLoading.wallet.addresses.forEach(function (address) {
                var wasCreated = (_this.createdAddresses[walletEntry.account] || []).indexOf(address.address) != -1;
                if (address.inUse || wasCreated) {
                    var btcCurrencyBalance = new CurrencyBalance('Bitcoin', 'BTC', address.address, address.privateKey, walletEntry.secretPhrase);
                    btcCurrencyBalance.balance = address.balance + "";
                    btcCurrencyBalance.visible = walletEntry.expanded;
                    btcCurrencyBalance.inUse = wasCreated ? false : true;
                    walletEntry.currencies.splice(index, 0, btcCurrencyBalance);
                    index++;
                }
            });
            walletEntry.currencies = walletEntry.currencies.filter(function (c) { return c != btcCurrencyAddressLoading; });
            _this.flatten();
        });
    };
    WalletComponent.prototype.getAccountAssets = function (account) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.getAccountBalances(account, "0", 1, 0, 100).then(function (balances) {
            var assetInfos = [];
            var promises = [];
            balances.forEach(function (balance) {
                if (balance.id != '0') {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info) {
                        assetInfos.push(angular.extend(info, {
                            userBalance: balance.virtualBalance
                        }));
                    }));
                }
            });
            if (promises.length > 0) {
                _this.$q.all(promises).then(function () {
                    assetInfos.sort(function (a, b) {
                        var textA = a.symbol.toUpperCase();
                        var textB = b.symbol.toUpperCase();
                        return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
                    });
                    deferred.resolve(assetInfos);
                }, deferred.reject);
            }
            else {
                deferred.resolve([]);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.importSeed = function ($event) {
        var _this = this;
        this.promptSecretPlusPassword($event).then(function (data) {
            var account = heat.crypto.getAccountId(data.secretPhrase);
            var publicKey = heat.crypto.secretPhraseToPublicKey(data.secretPhrase);
            var key = {
                account: account,
                secretPhrase: data.secretPhrase,
                pincode: data.password,
                name: '',
                publicKey: publicKey
            };
            _this.localKeyStore.add(key);
            var message = "Seed was successfully imported to your wallet";
            _this.$mdToast.show(_this.$mdToast.simple().textContent(message).hideDelay(5000));
            heat.fullApplicationScopeReload();
        });
    };
    WalletComponent.prototype.exportWallet = function () {
        var exported = this.localKeyStore.export();
        var encoded = this.walletFile.encode(exported);
        var blob = new Blob([encoded], { type: "text/plain;charset=utf-8" });
        saveAs(blob, 'heat.wallet');
    };
    WalletComponent.prototype.promptSecretPlusPassword = function ($event) {
        var self = this;
        function DialogController($scope, $mdDialog) {
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function () {
                $mdDialog.hide({
                    password: $scope['vm'].data.password1,
                    secretPhrase: $scope['vm'].data.secretPhrase,
                });
                importWallet($scope['vm'].data.secretPhrase, $scope['vm'].data.selectedImport);
            };
            $scope['vm'].secretChanged = function () {
                $scope['vm'].data.bip44Compatible = self.lightwalletService.validSeed($scope['vm'].data.secretPhrase);
            };
            $scope['vm'].data = {
                password1: '',
                password2: '',
                secretPhrase: '',
                bip44Compatible: false,
                selectedImport: ''
            };
            $scope['vm'].currencyList = [{ name: 'Ethereum', symbol: 'ETH' }, { name: 'Bitcoin', symbol: 'BTC' }, { name: 'FIMK', symbol: 'FIM' }, { name: 'NXT', symbol: 'NXT' }, { name: 'ARDOR', symbol: 'ARDR' }, { name: 'IOTA', symbol: 'IOTA' }];
        }
        function importWallet(secret, selectedImport) {
            var distinctValues = function (value, index, self) {
                return self.indexOf(value) === index;
            };
            var storage = heat.$inject.get('storage');
            var $rootScope = heat.$inject.get('$rootScope');
            var store = storage.namespace('wallet', $rootScope, true);
            var accountId = heat.crypto.getAccountId(secret);
            var currencies = store.get(accountId);
            if (!currencies)
                currencies = [];
            currencies.push(selectedImport);
            store.put(accountId, currencies.filter(distinctValues));
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Import Seed/Private Key</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>Select currency to import</p>\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selectedImport\" placeholder=\"Select currency\">\n                    <md-option ng-repeat=\"entry in vm.currencyList\" value=\"{{entry.symbol}}\">{{entry.symbol}}</md-option>\n                  </md-select>\n                </md-input-container>\n                <p>Enter your Secret Seed and provide a Password (or Pin)</p>\n                <md-input-container flex>\n                  <label>Private key / secret phrase</label>\n                  <textarea rows=\"2\" flex ng-model=\"vm.data.secretPhrase\" name=\"secretPhrase\" required ng-trim=\"false\" ng-change=\"vm.secretChanged() \"></textarea>\n                </md-input-container>\n                <md-input-container flex>\n                  <label>Desired Heatwallet PIN / password</label>\n                  <input type=\"password\" ng-model=\"vm.data.password1\" required name=\"password1\">\n                </md-input-container>\n                <md-input-container flex>\n                  <label>Desired Heatwallet PIN / password (confirm)</label>\n                  <input type=\"password\" ng-model=\"vm.data.password2\" required name=\"password2\">\n                </md-input-container>\n                <span>BIP44 compatible = <b>{{vm.data.bip44Compatible?'TRUE':'FALSE'}}</b></span>\n              </div>\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick()\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"dialogForm.$invalid || vm.data.password1 != vm.data.password2 || vm.data.selectedImport === ''\" class=\"md-primary\"\n                  ng-click=\"vm.okButtonClick()\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createEthAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var walletEntry = $scope['vm'].data.selectedWalletEntry;
                if (walletEntry) {
                    var walletEntry_1 = $scope['vm'].data.selectedWalletEntry;
                    var success_1 = false;
                    if (walletEntry_1) {
                        var node_1 = walletEntry_1.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Ethereum'; });
                        if (!node_1) {
                            var storage = heat.$inject.get('storage');
                            var $rootScope = heat.$inject.get('$rootScope');
                            var store = storage.namespace('wallet', $rootScope, true);
                            var currencies = store.get(walletEntry_1.account);
                            if (!currencies)
                                currencies = [];
                            currencies.push('ETH');
                            store.put(walletEntry_1.account, currencies.filter(function (value, index, self) { return self.indexOf(value) === index; }));
                            self.initWalletEntry(walletEntry_1);
                        }
                        setTimeout(function () {
                            node_1 = walletEntry_1.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Ethereum'; });
                            success_1 = node_1.createBtcAddress(self);
                            walletEntry_1.toggle(true);
                            $mdDialog.hide(null).then(function () {
                                if (!success_1) {
                                    dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                                }
                            });
                        }, 0);
                    }
                }
            };
            $scope['vm'].data = {
                selectedWalletEntry: walletEntries[0],
                selected: walletEntries[0].account,
                walletEntries: walletEntries,
                password: ''
            };
            $scope['vm'].selectedWalletEntryChanged = function () {
                $scope['vm'].data.password = '';
                $scope['vm'].data.selectedWalletEntry = walletEntries.find(function (w) { return $scope['vm'].data.selected == w.account; });
            };
            $scope['vm'].passwordChanged = function () {
                var password = $scope['vm'].data.password;
                var account = $scope['vm'].data.selected;
                var walletEntry = walletEntries.find(function (w) { return w.account == account; });
                try {
                    var key = self.localKeyStore.load(account, password);
                    if (key) {
                        self.localKeyStore.rememberPassword(walletEntry.account, password);
                        walletEntry.pin = password;
                        walletEntry.secretPhrase = key.secretPhrase;
                        walletEntry.bip44Compatible = self.lightwalletService.validSeed(key.secretPhrase);
                        walletEntry.unlocked = true;
                        self.initWalletEntry(walletEntry);
                        walletEntry.toggle(true);
                    }
                }
                catch (e) { }
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Ethereum Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Ethereum address, please choose the master HEAT account you want to attach the new Ethereum address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Put In Password -->\n\n                <div flex layout=\"column\" ng-if=\"vm.data.selectedWalletEntry && !vm.data.selectedWalletEntry.unlocked\">\n                  <p>\n                    Please first unlock this account by entering your password below\n                  </p>\n                  <md-input-container flex >\n                    <label>Password</label>\n                    <input ng-model=\"vm.data.password\" ng-change=\"vm.passwordChanged()\">\n                  </md-input-container>\n                </div>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  Eth wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Ethereum address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Ethereum.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createBtcAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var walletEntry = $scope['vm'].data.selectedWalletEntry;
                var success = false;
                if (walletEntry) {
                    var node_2 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Bitcoin'; });
                    if (!node_2) {
                        var storage = heat.$inject.get('storage');
                        var $rootScope = heat.$inject.get('$rootScope');
                        var store = storage.namespace('wallet', $rootScope, true);
                        var currencies = store.get(walletEntry.account);
                        if (!currencies)
                            currencies = [];
                        currencies.push('BTC');
                        store.put(walletEntry.account, currencies.filter(function (value, index, self) { return self.indexOf(value) === index; }));
                        self.initWalletEntry(walletEntry);
                    }
                    setTimeout(function () {
                        node_2 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'Bitcoin'; });
                        success = node_2.createBtcAddress(self);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'Make sure you use the previous address first before you can create a new address');
                            }
                        });
                    }, 0);
                }
            };
            $scope['vm'].data = {
                selectedWalletEntry: walletEntries[0],
                selected: walletEntries[0].account,
                walletEntries: walletEntries,
                password: ''
            };
            $scope['vm'].selectedWalletEntryChanged = function () {
                $scope['vm'].data.password = '';
                $scope['vm'].data.selectedWalletEntry = walletEntries.find(function (w) { return $scope['vm'].data.selected == w.account; });
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create Bitcoin Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new Bitcoin address, please choose the master HEAT account you want to attach the new Bitcoin address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  Btc wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your Bitcoin address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your Bitcoin.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createIotaAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create IOTA Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <p>Create your IOTA seed from\n                <a target=\"_blank\" href=\"https://ipfs.io/ipfs/QmdqTgEdyKVQAVnfT5iV4ULzTbkV4hhkDkMqGBuot8egfA\">here</a>\n              </p>\n              <span flex></span>\n            </md-dialog-content>\n            <md-dialog-actions>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createFIMKAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var walletEntry = $scope['vm'].data.selectedWalletEntry;
                var success = false;
                if (walletEntry) {
                    var node_3 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'FIMK'; });
                    if (!node_3) {
                        var storage = heat.$inject.get('storage');
                        var $rootScope = heat.$inject.get('$rootScope');
                        var store = storage.namespace('wallet', $rootScope, true);
                        var currencies = store.get(walletEntry.account);
                        if (!currencies)
                            currencies = [];
                        currencies.push('FIM');
                        store.put(walletEntry.account, currencies.filter(function (value, index, self) { return self.indexOf(value) === index; }));
                        self.initWalletEntry(walletEntry);
                    }
                    setTimeout(function () {
                        node_3 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'FIMK'; });
                        success = node_3.createBtcAddress(self);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'FIMK address already created for this account');
                            }
                        });
                    }, 0);
                }
            };
            $scope['vm'].data = {
                selectedWalletEntry: walletEntries[0],
                selected: walletEntries[0].account,
                walletEntries: walletEntries,
                password: ''
            };
            $scope['vm'].selectedWalletEntryChanged = function () {
                $scope['vm'].data.password = '';
                $scope['vm'].data.selectedWalletEntry = walletEntries.find(function (w) { return $scope['vm'].data.selected == w.account; });
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create FIMK Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new FIMK address, please choose the master HEAT account you want to attach the new FIMK address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  FIMK wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your FIMK address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your FIMK.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createNXTAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var walletEntry = $scope['vm'].data.selectedWalletEntry;
                var success = false;
                if (walletEntry) {
                    var node_4 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'NXT'; });
                    if (!node_4) {
                        var storage = heat.$inject.get('storage');
                        var $rootScope = heat.$inject.get('$rootScope');
                        var store = storage.namespace('wallet', $rootScope, true);
                        var currencies = store.get(walletEntry.account);
                        if (!currencies)
                            currencies = [];
                        currencies.push('NXT');
                        store.put(walletEntry.account, currencies.filter(function (value, index, self) { return self.indexOf(value) === index; }));
                        self.initWalletEntry(walletEntry);
                    }
                    setTimeout(function () {
                        node_4 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'NXT'; });
                        success = node_4.createBtcAddress(self);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'NXT address already created for this account');
                            }
                        });
                    }, 0);
                }
            };
            $scope['vm'].data = {
                selectedWalletEntry: walletEntries[0],
                selected: walletEntries[0].account,
                walletEntries: walletEntries,
                password: ''
            };
            $scope['vm'].selectedWalletEntryChanged = function () {
                $scope['vm'].data.password = '';
                $scope['vm'].data.selectedWalletEntry = walletEntries.find(function (w) { return $scope['vm'].data.selected == w.account; });
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create NXT Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new NXT address, please choose the master HEAT account you want to attach the new NXT address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  NXT wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your NXT address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your NXT.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent.prototype.createARDRAccount = function ($event) {
        var walletEntries = this.walletEntries;
        var self = this;
        if (walletEntries.length == 0)
            return;
        function DialogController2($scope, $mdDialog) {
            $scope['vm'].copySeed = function () {
                self.clipboard.copyWithUI(document.getElementById('wallet-secret-textarea'), 'Copied seed to clipboard');
            };
            $scope['vm'].cancelButtonClick = function () {
                $mdDialog.cancel();
            };
            $scope['vm'].okButtonClick = function ($event) {
                var walletEntry = $scope['vm'].data.selectedWalletEntry;
                var success = false;
                if (walletEntry) {
                    var node_5 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'ARDR'; });
                    if (!node_5) {
                        var storage = heat.$inject.get('storage');
                        var $rootScope = heat.$inject.get('$rootScope');
                        var store = storage.namespace('wallet', $rootScope, true);
                        var currencies = store.get(walletEntry.account);
                        if (!currencies)
                            currencies = [];
                        currencies.push('ARDR');
                        store.put(walletEntry.account, currencies.filter(function (value, index, self) { return self.indexOf(value) === index; }));
                        self.initWalletEntry(walletEntry);
                    }
                    setTimeout(function () {
                        node_5 = walletEntry.currencies.find(function (c) { return c.isCurrencyAddressCreate && c.name == 'ARDR'; });
                        success = node_5.createBtcAddress(self);
                        walletEntry.toggle(true);
                        $mdDialog.hide(null).then(function () {
                            if (!success) {
                                dialogs.alert($event, 'Unable to Create Address', 'ARDR address already created for this account');
                            }
                        });
                    }, 0);
                }
            };
            $scope['vm'].data = {
                selectedWalletEntry: walletEntries[0],
                selected: walletEntries[0].account,
                walletEntries: walletEntries,
                password: ''
            };
            $scope['vm'].selectedWalletEntryChanged = function () {
                $scope['vm'].data.password = '';
                $scope['vm'].data.selectedWalletEntry = walletEntries.find(function (w) { return $scope['vm'].data.selected == w.account; });
            };
        }
        var deferred = this.$q.defer();
        this.$mdDialog.show({
            controller: DialogController2,
            parent: angular.element(document.body),
            targetEvent: $event,
            clickOutsideToClose: false,
            controllerAs: 'vm',
            template: "\n        <md-dialog>\n          <form name=\"dialogForm\">\n            <md-toolbar>\n              <div class=\"md-toolbar-tools\"><h2>Create ARDR Address</h2></div>\n            </md-toolbar>\n            <md-dialog-content style=\"min-width:500px;max-width:600px\" layout=\"column\" layout-padding>\n              <div flex layout=\"column\">\n                <p>To create a new ARDR address, please choose the master HEAT account you want to attach the new ARDR address to:</p>\n\n                <!-- Select Master Account -->\n\n                <md-input-container flex>\n                  <md-select ng-model=\"vm.data.selected\" ng-change=\"vm.selectedWalletEntryChanged()\">\n                    <md-option ng-repeat=\"entry in vm.data.walletEntries\" value=\"{{entry.account}}\">{{entry.identifier}}</md-option>\n                  </md-select>\n                </md-input-container>\n\n                <!-- Invalid Non BIP44 Seed-->\n\n                <p ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && !vm.data.selectedWalletEntry.bip44Compatible\">\n                  ARDR wallet cannot be added to that old HEAT account. Please choose another or create a new HEAT account with BIP44 compatible seed.\n                </p>\n\n                <!-- Valid BIP44 Seed -->\n                <div flex layout=\"column\"\n                  ng-if=\"vm.data.selectedWalletEntry && vm.data.selectedWalletEntry.unlocked && vm.data.selectedWalletEntry.bip44Compatible\">\n\n                  <p>This is your ARDR address seed, It\u2019s the same as for your HEAT account {{vm.data.selectedWalletEntry.account}}.\n                      Please store it in a safe place or you may lose access to your ARDR.\n                      <a ng-click=\"vm.copySeed()\">Copy Seed</a></p>\n\n                  <md-input-container flex>\n                    <textarea rows=\"3\" flex ng-model=\"vm.data.selectedWalletEntry.secretPhrase\" readonly ng-trim=\"false\"\n                        style=\"font-family:monospace; font-size:16px; font-weight: bold; color: white; border: 1px solid white\"></textarea>\n                    <span id=\"wallet-secret-textarea\" style=\"display:none\">{{vm.data.selectedWalletEntry.secretPhrase}}</span>\n                  </md-input-container>\n\n                </div>\n              </div>\n\n            </md-dialog-content>\n            <md-dialog-actions layout=\"row\">\n              <span flex></span>\n              <md-button class=\"md-warn\" ng-click=\"vm.cancelButtonClick($event)\" aria-label=\"Cancel\">Cancel</md-button>\n              <md-button ng-disabled=\"!vm.data.selectedWalletEntry || !vm.data.selectedWalletEntry.unlocked || !vm.data.selectedWalletEntry.bip44Compatible\"\n                  class=\"md-primary\" ng-click=\"vm.okButtonClick($event)\" aria-label=\"OK\">OK</md-button>\n            </md-dialog-actions>\n          </form>\n        </md-dialog>\n      "
        }).then(deferred.resolve, deferred.reject);
        return deferred.promise;
    };
    WalletComponent = __decorate([
        RouteConfig('/wallet'),
        Component({
            selector: 'wallet',
            template: "\n   <!--  layout-align=\"start center\" -->\n    <div layout=\"column\"  flex layout-padding>\n      <div layout=\"row\">\n\n        <!-- Open File input is hidden -->\n        <md-button class=\"md-primary md-raised\">\n          <md-tooltip md-direction=\"bottom\">Open wallet file, adds all contents</md-tooltip>\n          <label for=\"walet-input-file\">\n            Import File\n          </label>\n        </md-button>\n        <input type=\"file\" onchange=\"angular.element(this).scope().vm.pageAddFileInputChange(this.files)\" class=\"ng-hide\" id=\"walet-input-file\">\n\n        <!-- Adds a wallet seed (heat secret phrase or bip44 eth/btc seed) -->\n        <md-button class=\"md-primary md-raised\" ng-click=\"vm.importSeed()\" aria-label=\"Import Seed\">\n          <md-tooltip md-direction=\"bottom\">Import Seed</md-tooltip>\n          Import Seed/Private Key\n        </md-button>\n\n        <!-- Export Wallet to File -->\n        <md-button class=\"md-warn md-raised\" ng-click=\"vm.exportWallet()\" aria-label=\"Export Wallet\" ng-if=\"!vm.allLocked\">\n          <md-tooltip md-direction=\"bottom\">Export Wallet File</md-tooltip>\n          Export Wallet File\n        </md-button>\n\n        <md-select class=\"wallet-dropdown md-warn md-raised\" placeholder=\"Create Address\" ng-change=\"vm.createAccount($event)\" ng-model=\"vm.selectedChain\">\n          <md-option ng-repeat=\"entry in vm.chains\" value=\"{{entry.name}}\" ng-disabled=\"{{entry.disabled}}\">{{entry.name}}</md-option>\n        </md-select>\n      </div>\n\n      <div layout=\"column\" layout-fill  flex>\n        <div layout-fill layout=\"column\" class=\"wallet-entries\" flex>\n\n          <!-- Build a wallet structure that contains ::\n                - wallet entries\n                - per entry currency balances\n                - per currency token balances  -->\n\n          <md-list layout-fill layout=\"column\" flex>\n            <md-list-item ng-repeat=\"entry in vm.entries\" ng-if=\"entry.visible && !entry.hidden\">\n\n              <!-- Wallet entry -->\n              <div ng-if=\"entry.isWalletEntry\" layout=\"row\" class=\"wallet-entry\" flex>\n                <!--\n                <md-checkbox ng-model=\"entry.selected\">\n                  <md-tooltip md-direction=\"bottom\">\n                    Check this to include in wallet export\n                  </md-tooltip>\n                </md-checkbox>\n                -->\n                <md-button class=\"md-icon-button left\" ng-click=\"entry.toggle()\">\n                  <md-icon md-font-library=\"material-icons\">{{entry.expanded?'expand_less':'expand_more'}}</md-icon>\n                </md-button>\n\n                <div flex ng-if=\"entry.secretPhrase\" class=\"identifier\"><a ng-click=\"entry.toggle()\">{{entry.identifier}}</a></div>\n                <div flex ng-if=\"!entry.secretPhrase\" class=\"identifier\">{{entry.identifier}}</div>\n                <md-button ng-if=\"!entry.unlocked\" ng-click=\"vm.unlock($event, entry)\">Sign in</md-button>\n\n                <md-menu md-position-mode=\"target-right target\" md-offset=\"34px 34px\" ng-if=\"entry.unlocked\">\n                  <md-button aria-label=\"user menu\" class=\"md-icon-button right\" ng-click=\"$mdOpenMenu($event)\" md-menu-origin >\n                    <md-icon md-font-library=\"material-icons\">more_horiz</md-icon>\n                  </md-button>\n                  <md-menu-content width=\"4\">\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"entry.showSecretPhrase()\">\n                        <md-icon md-font-library=\"material-icons\">file_copy</md-icon>\n                        Show private key\n                      </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                      <md-button aria-label=\"explorer\" ng-click=\"vm.remove($event, entry)\">\n                        <md-icon md-font-library=\"material-icons\">delete_forever</md-icon>\n                        Remove\n                      </md-button>\n                    </md-menu-item>\n                  </md-menu-content>\n                </md-menu>\n              </div>\n\n              <!-- Currency Balance -->\n              <div ng-if=\"entry.isCurrencyBalance\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex><a ng-click=\"entry.unlock()\">{{entry.address}}</a></div>&nbsp;\n                <div class=\"balance\">{{entry.balance}}&nbsp;{{entry.symbol}}</div>\n              </div>\n\n              <!-- Currency Address Loading -->\n              <div ng-if=\"entry.isCurrencyAddressLoading\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex>Loading ..</div>\n              </div>\n\n              <!-- Currency Address Create -->\n              <div ng-if=\"entry.isCurrencyAddressCreate\" layout=\"row\" class=\"currency-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex></div>\n                <md-button ng-click=\"entry.createAddress()\">Create New</md-button>\n              </div>\n\n              <!-- Token Balance -->\n              <div ng-if=\"entry.isTokenBalance\" layout=\"row\" class=\"token-balance\" flex>\n                <div class=\"name\">{{entry.name}}</div>&nbsp;\n                <div class=\"identifier\" flex>{{entry.address}}</div>&nbsp;\n                <div class=\"balance\">{{entry.balance}}&nbsp;{{entry.symbol}}</div>\n              </div>\n\n            </md-list-item>\n          </md-list>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', '$q', 'localKeyStore', 'walletFile', '$window', 'lightwalletService', 'heat', 'assetInfo', 'ethplorer', '$mdToast', '$mdDialog', 'clipboard', 'user', 'bitcoreService', 'fimkCryptoService', 'nxtCryptoService', 'ardorCryptoService', 'nxtBlockExplorerService', 'ardorBlockExplorerService', 'mofoSocketService', 'iotaCoreService', 'storage', '$rootScope'),
        __metadata("design:paramtypes", [Object, Function, LocalKeyStoreService,
            WalletFileService, Object, LightwalletService,
            HeatService,
            AssetInfoService,
            EthplorerService, Object, Object, ClipboardService,
            UserService,
            BitcoreService,
            FIMKCryptoService,
            NXTCryptoService,
            ARDORCryptoService,
            NxtBlockExplorerService,
            ArdorBlockExplorerService,
            MofoSocketService,
            IotaCoreService,
            StorageService, Object])
    ], WalletComponent);
    return WalletComponent;
}());
var DialogFieldBuilder = (function () {
    function DialogFieldBuilder($scope) {
        this.$scope = $scope;
    }
    DialogFieldBuilder.prototype.money = function (name, _default) { return new DialogFieldMoney(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.account = function (name, _default) { return new DialogFieldAccount(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.asset = function (name, _default) { return new DialogFieldAsset(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.text = function (name, _default) { return new DialogFieldText(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.hidden = function (name, _default) { return new DialogFieldHidden(this.$scope, name, _default); };
    DialogFieldBuilder.prototype.staticText = function (name, _default) { return new DialogFieldStatic(this.$scope, name, _default); };
    return DialogFieldBuilder;
}());
var AbstractDialogField = (function () {
    function AbstractDialogField($scope, name, value) {
        this.$scope = $scope;
        this.name = name;
        this.value = value;
        this._onchange = [];
        this.parsers = [];
        this.formatters = [];
        this.validators = [];
        this.asyncValidators = [];
        this.errorMessages = [];
        this._required = false;
        this._readonly = false;
        this._disabled = false;
        this._visible = true;
        this._previousValue = value;
    }
    AbstractDialogField.prototype.changed = function (force) {
        var _this = this;
        if (force || this.value != this._previousValue) {
            this._onchange.forEach(function (fn) {
                fn(_this.value, _this._previousValue);
            });
            this._previousValue = this.value;
        }
    };
    AbstractDialogField.prototype.selector = function (selector) {
        this._selector = selector;
    };
    AbstractDialogField.prototype.parse = function (parser) {
        this.parsers = this.parsers.concat(parser);
        return this;
    };
    AbstractDialogField.prototype.formatter = function (formatter) {
        this.formatters = this.formatters.concat(formatter);
        return this;
    };
    AbstractDialogField.prototype.validate = function (message, validator) {
        this.validators.push({
            validator: validator,
            message: message
        });
        return this;
    };
    AbstractDialogField.prototype.asyncValidate = function (message, validator) {
        this.asyncValidators.push({
            validator: validator,
            message: message
        });
        return this;
    };
    AbstractDialogField.prototype.onchange = function (fn) {
        this._onchange.push(fn);
        return this;
    };
    AbstractDialogField.prototype.required = function (required) {
        this._required = angular.isDefined(required) ? required : true;
        return this;
    };
    AbstractDialogField.prototype.readonly = function (readonly) {
        this._readonly = angular.isDefined(readonly) ? readonly : true;
        return this;
    };
    AbstractDialogField.prototype.label = function (label) {
        this._label = label;
        return this;
    };
    AbstractDialogField.prototype.disabled = function (disabled) {
        this._disabled = disabled;
        return this;
    };
    AbstractDialogField.prototype.visible = function (visible) {
        this._visible = visible;
        return this;
    };
    return AbstractDialogField;
}());
var Field = (function () {
    function Field() {
    }
    Field = __decorate([
        Component({
            selector: 'field',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n    field .async-validator-pending md-progress-linear,\n    field .async-validator-pending md-progress-linear * {\n      height: 3px !important;\n    }\n    field .async-validator-pending .md-input:focus {\n      border-width: 0px !important;\n    }\n  "],
            link: function (scope, element, attrs, controller) {
                var h = [];
                h.push('<', attrs.selector, ' label="vm.label" value="vm.value" changed="vm.changed" f="vm.f">');
                h.push('</', attrs.selector, '>');
                element.html(h.join(''));
                element.injector().get('$compile')(element.contents())(scope);
            }
        })
    ], Field);
    return Field;
}());
heat.Loader.directive('fieldValidator', function () {
    return {
        require: '^ngModel',
        link: function (scope, elm, attrs, ngModel) {
            elm.bind('blur', function () {
                if (!ngModel.$valid) {
                    return;
                }
                var viewValue = ngModel.$modelValue;
                var formatters = ngModel.$formatters;
                for (var i = formatters.length - 1; i >= 0; --i) {
                    viewValue = formatters[i](viewValue);
                }
                ngModel.$viewValue = viewValue;
                ngModel.$render();
            });
            var field = scope.$eval(attrs.fieldValidator);
            if (!field) {
                return;
            }
            field.formatters.forEach(function (fn) { ngModel.$formatters.unshift(fn); });
            field.parsers.forEach(function (fn) { ngModel.$parsers.push(fn); });
            field.validators.forEach(function (validator, index) {
                ngModel.$validators["validator_" + index] = function (modelValue, viewValue) {
                    return validator.validator(modelValue, viewValue);
                };
                field.errorMessages.push({
                    type: "validator_" + index,
                    text: validator.message
                });
            });
            field.asyncValidators.forEach(function (validator, index) {
                ngModel.$asyncValidators["async_validator_" + index] = function (modelValue, viewValue) {
                    return validator.validator(modelValue, viewValue);
                };
                field.errorMessages.push({
                    type: "async_validator_" + index,
                    text: validator.message
                });
            });
        }
    };
});
var DialogFieldAccount = (function (_super) {
    __extends(DialogFieldAccount, _super);
    function DialogFieldAccount($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.heat = heat.$inject.get('heat');
        _this.settings = heat.$inject.get('settings');
        _this.user = heat.$inject.get('user');
        _this.$q = heat.$inject.get('$q');
        _this.numbersOnly = /^[0-9]+$/;
        _this.selector('field-account');
        return _this;
    }
    DialogFieldAccount.prototype.search = function (query) {
        var _this = this;
        var deferred = this.$q.defer();
        this.heat.api.searchPublicNames(query, 0, 100).then(function (accounts) {
            accounts.forEach(function (account) {
                if (_this.numbersOnly.test(account.publicName)) {
                    account.publicName = '';
                }
            });
            if (accounts.length > 0) {
                deferred.resolve(accounts);
            }
            else if (_this.numbersOnly.test(query)) {
                _this.heat.api.getAccountByNumericId(query).then(function (account) {
                    deferred.resolve([account]);
                }, deferred.reject);
            }
        }, deferred.reject);
        return deferred.promise;
    };
    return DialogFieldAccount;
}(AbstractDialogField));
var DialogFieldAccountComponent = (function () {
    function DialogFieldAccountComponent() {
        this.searchText = this.f.value;
    }
    DialogFieldAccountComponent.prototype.selectedItemChange = function () {
        this.f.value = this.selectedItem ? this.selectedItem.id : '';
    };
    DialogFieldAccountComponent.prototype.searchTextChange = function () {
        this.f.value = this.searchText;
    };
    DialogFieldAccountComponent = __decorate([
        Component({
            selector: 'fieldAccount',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n  field-account md-input-container {\n    padding-bottom: 0px !important;\n  }\n  "],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-autocomplete\n        ng-required=\"vm.f._required\"\n        ng-readonly=\"vm.f._readonly\"\n        md-input-name=\"userField\"\n        md-floating-label=\"{{vm.label}}\"\n        md-min-length=\"1\"\n        md-items=\"item in vm.f.search(vm.searchText)\"\n        md-item-text=\"item.publicName||item.id\"\n        md-search-text=\"vm.searchText\"\n        md-selected-item-change=\"vm.selectedItemChange()\"\n        md-search-text-change=\"vm.searchTextChange()\"\n        md-selected-item=\"vm.selectedItem\"\n        ng-disabled=\"vm.f._disabled\">\n        <md-item-template>\n          <div layout=\"row\" flex class=\"monospace-font\">\n            <span>{{item.publicName||''}}</span>\n            <span flex></span>\n            <span>{{item.id}}</span>\n          </span>\n        </md-item-template>\n        <md-not-found>\n          No matches found.\n        </md-not-found>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-autocomplete>\n    </ng-form>\n  "
        }),
        __metadata("design:paramtypes", [])
    ], DialogFieldAccountComponent);
    return DialogFieldAccountComponent;
}());
var DialogFieldAsset = (function (_super) {
    __extends(DialogFieldAsset, _super);
    function DialogFieldAsset($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.heat = heat.$inject.get('heat');
        _this.$q = heat.$inject.get('$q');
        _this.settings = heat.$inject.get('settings');
        _this.user = heat.$inject.get('user');
        _this.assetInfo = heat.$inject.get('assetInfo');
        _this.availableAssets = [];
        _this._searchAllAssets = false;
        _this.selector('field-asset');
        return _this;
    }
    DialogFieldAsset.prototype.initAvailableAssets = function () {
        var _this = this;
        if (this.availableAssetsPromise) {
            return this.availableAssetsPromise;
        }
        var deferred = this.$q.defer();
        if (this._searchAllAssets) {
            this.heat.api.getAllAssetProtocol1(0, 100).then(function (assets) {
                assets.unshift({
                    name: "HEAT Cryptocurrency",
                    symbol: "HEAT",
                    asset: "0",
                    decimals: 8
                });
                var promises = [];
                assets.forEach(function (asset) {
                    promises.push(_this.assetInfo.getInfo(asset.asset).then(function (info2) {
                        var info = {
                            name: asset.name,
                            symbol: asset.symbol,
                            id: asset.asset,
                            decimals: asset.decimals,
                            certified: false
                        };
                        info.symbol = info2.symbol;
                        info.name = info2.name;
                        info.certified = info2.certified;
                        _this.availableAssets.push(info);
                    }));
                });
                _this.$q.all(promises).then(deferred.resolve, deferred.reject);
            }, deferred.reject);
        }
        else {
            this.heat.api.getAccountBalances(this.user.account, "0", 1, 0, 100).then(function (balances) {
                var promises = [];
                balances.forEach(function (balance) {
                    promises.push(_this.assetInfo.getInfo(balance.id).then(function (info2) {
                        var info = {
                            name: '*',
                            symbol: '*',
                            id: balance.id,
                            decimals: balance.decimals,
                            certified: false
                        };
                        info.symbol = info2.symbol;
                        info.name = info2.name;
                        info.certified = info2.certified;
                        _this.availableAssets.push(info);
                    }));
                });
                _this.$q.all(promises).then(deferred.resolve, deferred.reject);
            }, deferred.reject);
        }
        return this.availableAssetsPromise = deferred.promise;
    };
    DialogFieldAsset.prototype.search = function (_query) {
        var _this = this;
        var deferred = this.$q.defer();
        var query = _query.toLowerCase();
        if (!angular.isString(query)) {
            deferred.resolve(this.availableAssets);
        }
        else {
            this.initAvailableAssets().then(function () {
                var matches = [];
                _this.availableAssets.forEach(function (asset) {
                    if ((asset.name && asset.name.toLowerCase().indexOf(query) != -1) ||
                        (asset.symbol && asset.symbol.toLowerCase().indexOf(query) != -1) ||
                        (asset.id && asset.id.toLowerCase().indexOf(query) != -1)) {
                        matches.push(asset);
                    }
                });
                deferred.resolve(matches);
            }, deferred.reject);
        }
        return deferred.promise;
    };
    DialogFieldAsset.prototype.getAssetInfo = function (asset) {
        for (var i = 0; i < this.availableAssets.length; i++) {
            if (this.availableAssets[i].id == asset) {
                return this.availableAssets[i];
            }
        }
        return null;
    };
    DialogFieldAsset.prototype.searchAllAssets = function (searchAllAssets) {
        this._searchAllAssets = searchAllAssets;
        return this;
    };
    return DialogFieldAsset;
}(AbstractDialogField));
var DialogFieldAssetComponent = (function () {
    function DialogFieldAssetComponent() {
        this.searchText = this.f.value;
    }
    DialogFieldAssetComponent.prototype.selectedItemChange = function () {
        this.f.value = this.selectedItem ? this.selectedItem.id : '';
    };
    DialogFieldAssetComponent.prototype.searchTextChange = function () {
        this.f.value = this.searchText;
    };
    DialogFieldAssetComponent = __decorate([
        Component({
            selector: 'fieldAsset',
            inputs: ['label', 'value', 'changed', 'f'],
            styles: ["\n  field-asset md-input-container {\n    padding-bottom: 0px !important;\n  }\n  "],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-autocomplete\n        ng-required=\"vm.f._required\"\n        ng-readonly=\"vm.f._readonly\"\n        md-input-name=\"userField\"\n        md-floating-label=\"{{vm.label}}\"\n        md-min-length=\"1\"\n        md-items=\"item in vm.f.search(vm.searchText)\"\n        md-item-text=\"item.symbol + '    (' + item.id + ')'\"\n        md-search-text=\"vm.searchText\"\n        md-selected-item-change=\"vm.selectedItemChange()\"\n        md-search-text-change=\"vm.searchTextChange()\"\n        md-selected-item=\"vm.selectedItem\"\n        ng-disabled=\"vm.f._disabled\">\n        <md-item-template>\n          <div layout=\"row\" flex>\n            <span>{{item.symbol}}</span>\n            <span flex></span>\n            <span>{{item.id}}</span>\n          </span>\n        </md-item-template>\n        <md-not-found>\n          No matches found.\n        </md-not-found>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-autocomplete>\n    </ng-form>\n  "
        }),
        __metadata("design:paramtypes", [])
    ], DialogFieldAssetComponent);
    return DialogFieldAssetComponent;
}());
var DialogFieldHidden = (function (_super) {
    __extends(DialogFieldHidden, _super);
    function DialogFieldHidden($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.selector('field-hidden');
        return _this;
    }
    return DialogFieldHidden;
}(AbstractDialogField));
var DialogFieldHiddenComponent = (function () {
    function DialogFieldHiddenComponent() {
    }
    DialogFieldHiddenComponent = __decorate([
        Component({
            selector: 'fieldHidden',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\">\n      <input type=\"hidden\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n          name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-trim=\"false\">\n    </ng-form>\n  "
        })
    ], DialogFieldHiddenComponent);
    return DialogFieldHiddenComponent;
}());
var DialogFieldMoney = (function (_super) {
    __extends(DialogFieldMoney, _super);
    function DialogFieldMoney($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default) || this;
        _this._precision = 8;
        _this._symbol = 'HEAT';
        _this.selector('field-money');
        _this.parse(function (value) {
            if (value == '')
                return '';
            if (!utils.isNumber(value))
                return undefined;
            try {
                return utils.convertToQNT(utils.unformat(value));
            }
            catch (e) {
                console.log('this');
                console.log(_this);
                console.log('error:', e);
            }
        });
        _this.formatter(function (value) {
            if (value === undefined || value == '')
                return undefined;
            return utils.formatQNT(value, _this._precision);
        });
        _this.formatter(function (value) {
            if (value === undefined || value == '')
                return undefined;
            return utils.commaFormat(value);
        });
        return _this;
    }
    DialogFieldMoney.prototype.precision = function (precision) {
        this._precision = precision;
        return this;
    };
    DialogFieldMoney.prototype.symbol = function (symbol) {
        this._symbol = symbol;
        return this;
    };
    return DialogFieldMoney;
}(AbstractDialogField));
var DialogFieldMoneyComponent = (function () {
    function DialogFieldMoneyComponent() {
    }
    DialogFieldMoneyComponent = __decorate([
        Component({
            selector: 'fieldMoney',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label>{{vm.label}}<span ng-if=\"vm.f._symbol\"> ({{vm.f._symbol}})</span></label>\n        <input field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-disabled=\"vm.f._disabled\">\n        <md-progress-linear md-mode=\"indeterminate\" ng-if=\"userForm.userField.$pending\"></md-progress-linear>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldMoneyComponent);
    return DialogFieldMoneyComponent;
}());
var DialogFieldStatic = (function (_super) {
    __extends(DialogFieldStatic, _super);
    function DialogFieldStatic($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this.selector('field-static');
        return _this;
    }
    return DialogFieldStatic;
}(AbstractDialogField));
var DialogFieldStaticComponent = (function () {
    function DialogFieldStaticComponent() {
    }
    DialogFieldStaticComponent = __decorate([
        Component({
            selector: 'fieldStatic',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" flex ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label ng-if=\"vm.label\">{{vm.label}}</label>\n        <p>{{vm.value}}</p>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldStaticComponent);
    return DialogFieldStaticComponent;
}());
var DialogFieldText = (function (_super) {
    __extends(DialogFieldText, _super);
    function DialogFieldText($scope, name, _default) {
        var _this = _super.call(this, $scope, name, _default || '') || this;
        _this._rows = 0;
        _this.selector('field-text');
        return _this;
    }
    DialogFieldText.prototype.rows = function (rows) {
        this._rows = rows;
        return this;
    };
    return DialogFieldText;
}(AbstractDialogField));
var DialogFieldTextComponent = (function () {
    function DialogFieldTextComponent() {
    }
    DialogFieldTextComponent = __decorate([
        Component({
            selector: 'fieldText',
            inputs: ['label', 'value', 'changed', 'f'],
            template: "\n    <ng-form name=\"userForm\" layout=\"row\" ng-show=\"vm.f._visible\">\n      <md-input-container class=\"md-block\" flex ng-class=\"{'async-validator-pending':userForm.userField.$pending}\">\n        <label>{{vm.label}}</label>\n        <input ng-if=\"!vm.f._rows\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\" ng-trim=\"false\" ng-disabled=\"vm.f._disabled\">\n        <textarea ng-if=\"vm.f._rows\" field-validator=\"vm.f\" ng-model=\"vm.value\" ng-change=\"vm.changed()\"\n            name=\"userField\" ng-required=\"vm.f._required\" ng-readonly=\"vm.f._readonly\"\n            ng-trim=\"false\" rows=\"{{vm.f._rows}}\" ng-disabled=\"vm.f._disabled\"></textarea>\n        <md-progress-linear md-mode=\"indeterminate\" ng-if=\"userForm.userField.$pending\"></md-progress-linear>\n        <div ng-messages=\"userForm.userField.$error\" ng-if=\"userForm.userField.$dirty\">\n          <div ng-messages-include=\"error-messages\"></div>\n          <div ng-repeat=\"errorMessage in vm.f.errorMessages\"\n               ng-message-exp=\"errorMessage.type\">{{ errorMessage.text }}</div>\n        </div>\n      </md-input-container>\n    </ng-form>\n  "
        })
    ], DialogFieldTextComponent);
    return DialogFieldTextComponent;
}());
var TransactionMessageType;
(function (TransactionMessageType) {
    TransactionMessageType[TransactionMessageType["TO_SELF"] = 0] = "TO_SELF";
    TransactionMessageType[TransactionMessageType["TO_RECIPIENT"] = 1] = "TO_RECIPIENT";
    TransactionMessageType[TransactionMessageType["PUBLIC"] = 2] = "PUBLIC";
})(TransactionMessageType || (TransactionMessageType = {}));
var TransactionBuilder = (function () {
    function TransactionBuilder(transaction) {
        this.transaction = transaction;
        this.$q = heat.$inject.get('$q');
        this.user = heat.$inject.get('user');
        this.settings = heat.$inject.get('settings');
        this.heat = heat.$inject.get('heat');
        this._deadline = 1440;
        this._messageIsBinary = false;
    }
    TransactionBuilder.prototype.deadline = function (deadline) {
        this._deadline = deadline;
        return this;
    };
    TransactionBuilder.prototype.feeNQT = function (feeHQT) {
        this._feeHQT = feeHQT;
        return this;
    };
    TransactionBuilder.prototype.secretPhrase = function (secretPhrase) {
        this._secretPhrase = secretPhrase;
        return this;
    };
    TransactionBuilder.prototype.recipientPublicKey = function (recipientPublicKey) {
        this._recipientPublicKey = recipientPublicKey;
        return this;
    };
    TransactionBuilder.prototype.recipient = function (recipient) {
        this._recipient = recipient;
        return this;
    };
    TransactionBuilder.prototype.message = function (message, messageType, isBinary) {
        this._message = message;
        this._messageType = messageType;
        this._messageIsBinary = isBinary;
        return this;
    };
    TransactionBuilder.prototype.attachment = function (name, attachment) {
        this._attachment = {};
        this._attachment[name] = attachment;
        return this;
    };
    TransactionBuilder.prototype.create = function () {
        var _this = this;
        var deferred = this.$q.defer();
        try {
            this._transactionArgs = this.getCreateTransactionArgs();
            var p = this.heat.api.createTransaction(this._transactionArgs);
            p.then(function (data) {
                _this._transactionData = data;
                deferred.resolve();
            }).
                catch(function (error) {
                console.log(error);
                deferred.reject(error);
            });
        }
        catch (e) {
            console.log(e);
            deferred.reject(e);
        }
        return deferred.promise;
    };
    TransactionBuilder.prototype.sign = function () {
        var deferred = this.$q.defer();
        var signature = heat.crypto.signBytes(this._transactionData.unsignedTransactionBytes, converters.stringToHexString(this._secretPhrase));
        var publicKey = heat.crypto.secretPhraseToPublicKey(this._secretPhrase);
        if (!heat.crypto.verifyBytes(signature, this._transactionData.unsignedTransactionBytes, publicKey)) {
            deferred.reject({
                description: 'Server returned invalid transaction',
                code: 1
            });
        }
        else {
            var payload = this.transaction.verifyAndSignTransactionBytes(this._transactionData.unsignedTransactionBytes, signature, this._transactionArgs);
            if (!payload) {
                deferred.reject({
                    description: 'Could not confirm client signature',
                    code: 2
                });
            }
            else {
                this._transactionBytes = payload;
                this.transactionFullHash = heat.crypto.calculateFullHash(this._transactionData.unsignedTransactionBytes, signature);
                this.transactionId = heat.crypto.calculateTransactionId(this.transactionFullHash);
                deferred.resolve();
            }
        }
        return deferred.promise;
    };
    TransactionBuilder.prototype.broadcast = function () {
        var _this = this;
        var deferred = this.$q.defer();
        var p = this.heat.api.broadcast({ transactionBytes: this._transactionBytes });
        p.then(function (data) {
            if (data.fullHash != _this.transactionFullHash) {
                deferred.resolve({
                    success: false,
                    internalError: 'Fullhash from server does not match expected fullHash'
                });
            }
            else if (data.transaction != _this.transactionId) {
                deferred.resolve({
                    success: false,
                    internalError: 'Transaction id from server does not match expected id'
                });
            }
            else {
                deferred.resolve({
                    success: true
                });
            }
        }).catch(function (error) {
            if (error instanceof InternalServerTimeoutError) {
                deferred.resolve({
                    success: false,
                    internalTimeout: true
                });
            }
            else {
                deferred.resolve({
                    success: false,
                    serverError: error.description
                });
            }
        });
        return deferred.promise;
    };
    TransactionBuilder.prototype.getCreateTransactionArgs = function () {
        var attachment = angular.isFunction(this._attachment) ? this._attachment.call(null) : (this._attachment || {});
        if (!angular.isDefined(this._feeHQT)) {
            throw new Error("You must provide a fee");
        }
        var args = {
            fee: this._feeHQT,
            deadline: this._deadline,
            publicKey: heat.crypto.secretPhraseToPublicKey(this._secretPhrase),
            broadcast: false
        };
        angular.extend(args, attachment);
        if (utils.emptyToNull(this._recipientPublicKey)) {
            args.recipientPublicKey = this._recipientPublicKey;
        }
        if (utils.emptyToNull(this._recipient)) {
            args.recipient = this._recipient;
        }
        if (utils.emptyToNull(this._message)) {
            switch (this._messageType) {
                case TransactionMessageType.TO_SELF: {
                    angular.extend(args, this.encryptToSelf(this._message));
                    break;
                }
                case TransactionMessageType.TO_RECIPIENT: {
                    if (!angular.isDefined(args.recipientPublicKey)) {
                        throw new Error("You must provide a recipient that has a publickey");
                    }
                    var publicKey = converters.hexStringToByteArray(args.recipientPublicKey);
                    angular.extend(args, this.encryptToRecipient(this._message, args.recipient, publicKey));
                    break;
                }
                case TransactionMessageType.PUBLIC: {
                    args.message = this._message;
                    args.messageIsText = !this._messageIsBinary;
                    break;
                }
            }
        }
        return args;
    };
    TransactionBuilder.prototype.encryptToSelf = function (message, isBinary) {
        var publicKey = converters.hexStringToByteArray(heat.crypto.secretPhraseToPublicKey(this._secretPhrase));
        var encrypted = isBinary ?
            heat.crypto.encryptBinaryNote(message, { "publicKey": publicKey }, this._secretPhrase, true) :
            heat.crypto.encryptNote(message, { "publicKey": publicKey }, this._secretPhrase);
        return {
            "encryptToSelfMessageData": encrypted.message,
            "encryptToSelfMessageNonce": encrypted.nonce,
            "messageToEncryptToSelfIsText": !isBinary
        };
    };
    TransactionBuilder.prototype.encryptToRecipient = function (message, recipient, recipientPublicKey, isBinary) {
        var options = {
            "account": recipient,
            "publicKey": recipientPublicKey
        };
        var encrypted = isBinary ?
            heat.crypto.encryptBinaryNote(message, options, this._secretPhrase, true) :
            heat.crypto.encryptNote(message, options, this._secretPhrase);
        return {
            "encryptedMessageData": encrypted.message,
            "encryptedMessageNonce": encrypted.nonce,
            "messageToEncryptIsText": !isBinary
        };
    };
    return TransactionBuilder;
}());
var ArdorTradesProviderFactory = (function () {
    function ArdorTradesProviderFactory(ardorBlockExplorerService, $q) {
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorTradesProviderFactory.prototype.createProvider = function (currency, asset, account) {
        return new ArdorTradesProvider(currency, asset, account, this.ardorBlockExplorerService, this.$q);
    };
    ArdorTradesProviderFactory = __decorate([
        Service('ardorTradesProviderFactory'),
        Inject('ardorBlockExplorerService', '$q'),
        __metadata("design:paramtypes", [ArdorBlockExplorerService, Function])
    ], ArdorTradesProviderFactory);
    return ArdorTradesProviderFactory;
}());
var ArdorTradesProvider = (function () {
    function ArdorTradesProvider(currency, asset, account, ardorBlockExplorerService, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorTradesProvider.prototype.getPaginatedLength = function () {
        if (this.account)
            return this.ardorBlockExplorerService.getTradesCount(this.currency, this.account);
        return this.ardorBlockExplorerService.getTradesCount(this.currency);
    };
    ArdorTradesProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account)
            return this.ardorBlockExplorerService.getTrades(this.currency, firstIndex, lastIndex, this.account);
        return this.ardorBlockExplorerService.getTrades(this.currency, firstIndex, lastIndex);
    };
    return ArdorTradesProvider;
}());
var ArdorTraderQuickBuySellComponent = (function () {
    function ArdorTraderQuickBuySellComponent($scope, $q, $mdToast, user, settings, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.user = user;
        this.settings = settings;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.quantity = '0';
        this.price = '0';
        this.total = null;
        this.fee = utils.formatQNT(HeatAPI.fee.standard, 8);
        this.EXPIRY_MIN = 3600;
        this.EXPIRY_MAX = 3600 * 24 * 30;
        this.expiryUnitsOptions = {
            'minutes': {
                label: 'Minutes',
                min: Math.round(this.EXPIRY_MIN / 60),
                max: Math.round(this.EXPIRY_MAX / 60),
                delta: 60
            },
            'hours': {
                label: 'Hours',
                min: Math.round(this.EXPIRY_MIN / (60 * 60)),
                max: Math.round(this.EXPIRY_MAX / (60 * 60)),
                delta: 60 * 60
            },
            'days': {
                label: 'Days',
                min: 1,
                max: 30,
                delta: (60 * 60 * 24)
            },
            'weeks': {
                label: 'Weeks',
                min: 1,
                max: 4,
                delta: (60 * 60 * 24 * 7)
            }
        };
        this.expiryUnits = 'days';
        this.expiryUnitsValue = 30;
        this.expiresTooltip = '';
        $scope.$on('price', function (event, opts) {
            _this.price = opts.price.toFixed(8);
            _this.quantity = opts.balance.toFixed(8);
            _this.total = opts.total.toFixed(8);
        });
        $scope.$watch('vm.selectedOrder', function () {
            if (_this.selectedOrder) {
                var price = parseFloat(utils.formatQNT(_this.selectedOrder.price));
                price = 1 / price;
                _this.price = price.toFixed(_this.currencyInfo.decimals);
                if (_this.selectedOrder.type == 'bid' && angular.isString(_this.assetInfo.userBalance)) {
                    _this.quantity = utils.formatQNT(_this.assetInfo.userBalance, _this.assetInfo.decimals);
                    var total = parseFloat(utils.unformat(_this.price)) * parseFloat(utils.unformat(_this.quantity));
                    _this.total = String(total);
                }
                else if (_this.selectedOrder.type == 'ask' && angular.isString(_this.currencyInfo.userBalance)) {
                    _this.total = utils.formatQNT(_this.currencyInfo.userBalance, _this.currencyInfo.decimals);
                    var quantity = parseFloat(utils.unformat(_this.total)) / parseFloat(utils.unformat(_this.price));
                    _this.quantity = String(quantity);
                }
            }
        });
        this.notifyUser = utils.debounce(function (text) {
            $mdToast.show($mdToast.simple().textContent(text).hideDelay(3000));
        }, 500, true);
        this.expiryUnitsValueChanged(true);
    }
    ArdorTraderQuickBuySellComponent.prototype.expiryUnitsValueChanged = function (suppressNotification) {
        this.expiry = parseInt(this.expiryUnitsValue + '') * this.expiryUnitsOptions[this.expiryUnits].delta;
        this.expiryValid = false;
        this.expiresTooltip = '';
        if (this.expiry <= this.EXPIRY_MAX && this.expiry >= this.EXPIRY_MIN) {
            this.expiryValid = true;
            var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
            var date = new Date(Date.now() + (this.expiry * 1000));
            var dateFormatted = dateFormat(date, format);
            this.expiresTooltip = "This order will expiry if (even partially) unfilled by " + dateFormatted;
        }
        else {
            var min = this.expiryUnitsOptions[this.expiryUnits].min;
            var max = this.expiryUnitsOptions[this.expiryUnits].max;
            var units = this.expiryUnitsOptions[this.expiryUnits].label;
            this.expiresTooltip = "Min expiry in " + units + " is " + min + ", max expiry in " + units + " is " + max;
            this.notifyUser(this.expiresTooltip);
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.quickAsk = function ($event) {
        console.log('qa');
        if (angular.isString(this.assetInfo.userBalance)) {
            var quantityQNT = parseInt(utils.unformat(this.quantity));
            var balanceQNT = parseInt(utils.unformat(this.currencyInfo.userBalance));
            if (balanceQNT < quantityQNT) {
                this.notifyUser("Insufficient " + this.assetInfo.symbol + " balance");
                return;
            }
            var price = parseInt(this.price);
            this.ardorBlockExplorerService.sendTransactionWithSecret("placeAskOrder&chain=2&asset=" + this.currencyInfo.id + "&quantityQNT=" + quantityQNT + "&priceNQTPerShare=" + price + "&secretPhrase=" + this.user.secretPhrase + "&feeNQT=3030000");
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.quickBid = function ($event) {
        console.log('qb');
        if (angular.isString(this.currencyInfo.userBalance)) {
            var total = parseInt(utils.unformat(this.total));
            var balanceQNT = parseInt(utils.unformat(this.currencyInfo.userBalance));
            if (balanceQNT < total) {
                this.notifyUser("Insufficient " + this.currencyInfo.symbol + " balance");
                return;
            }
            var price = parseInt(this.price);
            this.ardorBlockExplorerService.sendTransactionWithSecret("placeBidOrder&chain=2&asset=" + this.currencyInfo.id + "&quantityQNT=" + total + "&priceNQTPerShare=" + price + "&secretPhrase=" + this.user.secretPhrase + "&feeNQT=3030000");
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.calculateTotalPrice = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                return "";
            }
            else {
                var quantityQNT = utils.convertToQNT(quantity);
                var priceQNT = utils.convertToQNT(price);
                var totalQNT = utils.calculateTotalOrderPriceQNT(quantityQNT, priceQNT);
                return utils.formatQNT(totalQNT, this.currencyInfo.decimals, true);
            }
        }
        catch (e) {
            return "";
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.recalculateTotal = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var quantity = utils.unformat(this.quantity) || "0";
            if (price == "0" || quantity == "0") {
                this.total = "0";
            }
            else {
                this.total = String(parseFloat(utils.unformat(this.price)) * parseFloat(utils.unformat(this.quantity)));
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    ArdorTraderQuickBuySellComponent.prototype.recalculateAmount = function () {
        try {
            var price = utils.unformat(this.price) || "0";
            var total = utils.unformat(this.total) || "0";
            if (price == "0" || total == "0") {
                this.quantity = "0";
            }
            else {
                this.quantity = String(parseFloat(utils.unformat(this.total)) / parseFloat(utils.unformat(this.price)));
            }
        }
        catch (e) {
            console.log(e);
        }
    };
    ArdorTraderQuickBuySellComponent = __decorate([
        Component({
            selector: 'ardorTraderQuickBuySell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder', 'oneClickOrders'],
            template: "\n    <div>\n      <div class=\"trader-component-title\">Buy/Sell&nbsp;<elipses-loading ng-show=\"vm.loading\"></elipses-loading></div>\n      <form name=\"quickBuySellForm\">\n        <div class=\"row\">\n          <div class=\"label\">\n            Unit price\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-price-input\" type=\"text\" ng-model=\"vm.price\" required\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}} / {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Amount\n          </div>\n          <div class=\"input\">\n            <input id=\"trader-quick-buy-sell-quantity-input\" type=\"text\" ng-model=\"vm.quantity\"\n              ng-change=\"vm.recalculateTotal()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.assetInfo.symbol}}\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\" ng-class=\"{'expires-invalid': !vm.expiryValid}\">\n            Expires in\n          </div>\n          <div class=\"input\">\n            <input type=\"number\" ng-model=\"vm.expiryUnitsValue\" required name=\"expiry\"\n                      ng-change=\"vm.expiryUnitsValueChanged()\"\n                      min=\"{{vm.expiryUnitsOptions[vm.expiryUnits].min}}\"\n                      max=\"{{vm.expiryUnitsOptions[vm.expiryUnits].max}}\"\n                      ng-disabled=\"true\">\n          </div>\n          <div class=\"label\">\n            <md-menu>\n              <a ng-click=\"$mdMenu.open($event)\">\n                <md-tooltip>{{vm.expiresTooltip}}</md-tooltip>\n                {{vm.expiryUnitsOptions[vm.expiryUnits].label}}\n              </a>\n              <md-menu-content width=\"4\">\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='minutes';vm.expiryUnitsValueChanged()\">Minutes</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='hours';vm.expiryUnitsValueChanged()\">Hours</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='days';vm.expiryUnitsValueChanged()\">Days</md-button>\n                </md-menu-item>\n                <md-menu-item>\n                  <md-button ng-click=\"vm.expiryUnits='weeks';vm.expiryUnitsValueChanged()\">Weeks</md-button>\n                </md-menu-item>\n              </md-menu-content>\n            </md-menu>\n          </div>\n        </div>\n        <div class=\"row\">\n          <div class=\"label\">\n            Total\n          </div>\n          <div class=\"input\">\n            <input type=\"text\" id=\"trader-quick-buy-sell-total-input\" ng-model=\"vm.total\" required max-decimals=\"{{vm.currencyInfo.decimals}}\"\n              ng-change=\"vm.recalculateAmount()\" ng-disabled=\"!vm.currencyInfo||!vm.assetInfo\">\n          </div>\n          <div class=\"label\">\n            {{vm.currencyInfo.symbol}}\n          </div>\n        </div>\n        <div ng-hide=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <md-button class=\"md-primary\" aria-label=\"Sign in\" href=\"#/login\">\n            Sign in to trade\n          </md-button>\n        </div>\n        <div ng-show=\"vm.user.unlocked\" class=\"row bottom-row\">\n          <div>\n            <md-button class=\"md-primary\" aria-label=\"Buy\" ng-click=\"vm.quickBid($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              BUY\n            </md-button>\n          </div>\n          <div>\n          <md-switch ng-model=\"vm.oneClickOrders\" aria-label=\"1-click orders\" class=\"md-primary\" ng-disabled=\"true\">\n            <span ng-show=\"vm.oneClickOrders\"><b>1-click orders enabled</b></span><span ng-hide=\"vm.oneClickOrders\">1-click orders disabled</span>\n          </md-switch>\n        </div>\n          <div>\n            <md-button class=\"md-warn\" aria-label=\"Sell\" ng-click=\"vm.quickAsk($event)\" ng-disabled=\"quickBuySellForm.$invalid||!vm.expiryValid\">\n              SELL\n            </md-button>\n          </div>\n        </div>\n      </form>\n    </div>\n  "
        }),
        Inject('$scope', '$q', '$mdToast', 'user', 'settings', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Function, Object, UserService,
            SettingsService,
            ArdorBlockExplorerService])
    ], ArdorTraderQuickBuySellComponent);
    return ArdorTraderQuickBuySellComponent;
}());
var ArdorTraderBalancesComponent = (function () {
    function ArdorTraderBalancesComponent($scope, user, assetInfoService, $q, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.assetBalances = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var refresh = utils.debounce((angular.bind(_this, _this.loadBalances)), 1 * 1000, false);
                _this.loadBalances();
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    ArdorTraderBalancesComponent.prototype.loadBalances = function () {
        var _this = this;
        this.ardorBlockExplorerService.getBalance(this.user.account, 2).then(function (balance) {
            _this.assetBalances.push({ symbol: 'IGNIS', balance: new Big(utils.convertToQNTf(balance)).toFixed(8), name: 'IGNIS' });
            _this.assetInfo.userBalance = balance;
        });
        this.ardorBlockExplorerService.getAccountAssets(this.user.account).then(function (assets) {
            _this.$scope.$evalAsync(function () {
                var promises = [];
                assets.forEach(function (balance) {
                    promises.push(_this.assetInfoService.getInfo(balance.asset).then(function (info) {
                        _this.$scope.$evalAsync(function () {
                            balance.symbol = info.symbol;
                            balance.name = info.name;
                            balance.balance = utils.formatQNT(balance.quantityQNT, info.decimals).replace(/.00000000$/, '');
                            ;
                            _this.assetBalances.push(balance);
                        });
                    }));
                    balance.symbol = '*';
                    balance.name = '*';
                    balance.balance = '*';
                    if (_this.currencyInfo.id == balance.asset)
                        _this.currencyInfo.userBalance = balance.quantityQNT;
                    if (_this.assetInfo.id == balance.asset)
                        _this.assetInfo.userBalance = balance.quantityQNT;
                });
                Promise.all(promises).then(function () {
                    _this.$scope.$evalAsync(function () {
                        _this.assetBalances.sort(function (a, b) {
                            if (a.symbol < b.symbol)
                                return 1;
                            if (a.symbol > b.symbol)
                                return -1;
                            return 0;
                        });
                    });
                });
            });
        });
    };
    ArdorTraderBalancesComponent = __decorate([
        Component({
            selector: 'ardorTraderBalances',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div layout=\"row\" class=\"trader-component-title\">Account&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <md-list>\n      <md-list-item class=\"header\">\n        <div class=\"truncate-col symbol-col\">Asset</div>\n        <div class=\"truncate-col balance-col right-align\" flex>Balance</div>\n      </md-list-item>\n      <md-virtual-repeat-container  flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n        <md-list-item md-virtual-repeat=\"item in vm.assetBalances\">\n          <div class=\"truncate-col symbol-col\" >{{item.symbol}}</div>\n          <div class=\"truncate-col balance-col right-align\" flex>{{item.balance}}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'user', 'ardorAssetInfo', '$q', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, UserService,
            ArdorAssetInfoService, Function, ArdorBlockExplorerService])
    ], ArdorTraderBalancesComponent);
    return ArdorTraderBalancesComponent;
}());
var ArdorTraderInfoAssetDescriptionComponent = (function () {
    function ArdorTraderInfoAssetDescriptionComponent($scope, assetInfoService, $q, heat, user) {
        var _this = this;
        this.$scope = $scope;
        this.assetInfoService = assetInfoService;
        this.$q = $q;
        this.heat = heat;
        this.user = user;
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.$scope.$evalAsync(function () {
                    _this.currencyIssuer = _this.currencyInfo.issuer;
                    _this.currencyIssuerPublicName = _this.currencyInfo.issuerPublicName;
                    _this.assetIssuer = _this.assetInfo.issuer;
                    _this.assetIssuerPublicName = _this.assetInfo.issuerPublicName;
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    ArdorTraderInfoAssetDescriptionComponent.prototype.showDescription = function ($event, info) {
        dialogs.assetInfo($event, info);
    };
    ArdorTraderInfoAssetDescriptionComponent = __decorate([
        Component({
            selector: 'ardorTraderInfoAssetDescription',
            inputs: ['currencyInfo', 'assetInfo'],
            template: "\n    <div class=\"asset-container\">\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.currencyInfo)\">{{vm.currencyInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              {{vm.currencyIssuerPublicName||vm.currencyIssuer}}\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"asset-description\">\n        <div class=\"col\">\n          <div class=\"col-item header\">\n            <div class=\"title\">\n              Asset name:\n            </div>\n            <div class=\"value\">\n              <a ng-click=\"vm.showDescription($event, vm.assetInfo)\">{{vm.assetInfo.name}}</a>\n            </div>\n          </div>\n          <div class=\"col-item issued-by\">\n            <div class=\"title\">\n              Issuer:\n            </div>\n            <div class=\"value\">\n              {{vm.assetIssuerPublicName||vm.assetIssuer}}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'assetInfo', '$q', 'heat', 'user'),
        __metadata("design:paramtypes", [Object, AssetInfoService, Function, HeatService,
            UserService])
    ], ArdorTraderInfoAssetDescriptionComponent);
    return ArdorTraderInfoAssetDescriptionComponent;
}());
var ArdorTraderInfoComponent = (function () {
    function ArdorTraderInfoComponent() {
    }
    ArdorTraderInfoComponent = __decorate([
        Component({
            selector: 'ardorTraderInfo',
            inputs: ['currencyInfo', 'assetInfo', 'toggleMarkets', 'marketsSidenavOpen'],
            template: "\n    <div>\n      <div class=\"top-row\">\n        <div class=\"market-title\">\n          <span>\n            <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n              <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n              <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n            </md-button>\n          </span>\n          <span class=\"market-title-text\">\n            <span ng-class=\"{certified:vm.currencyInfo.certified}\">{{vm.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:vm.assetInfo.certified}\">{{vm.assetInfo.symbol}}</span>\n          </span>\n        </div>\n      </div>\n      <ardor-trader-info-asset-description currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-info-asset-description>\n    </div>\n  "
        })
    ], ArdorTraderInfoComponent);
    return ArdorTraderInfoComponent;
}());
var ArdorTraderMarketsComponent = (function () {
    function ArdorTraderMarketsComponent($scope, heat, assetInfo, storage, $q, $mdToast, $interval, ardorBlockExplorerService) {
        var _this = this;
        this.$scope = $scope;
        this.heat = heat;
        this.assetInfo = assetInfo;
        this.storage = storage;
        this.$q = $q;
        this.$mdToast = $mdToast;
        this.$interval = $interval;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.sort = 'change';
        this.asc = true;
        this.filter = '';
        this.preMarkets = [null, null];
        this.markets = [];
        this.showFakeMarketsWarning = true;
        this.filterFunc = function (item) { return _this.filterFuncImpl(item); };
        var refresh = utils.debounce(angular.bind(this, this.loadMarkets), 5 * 1000, false);
        heat.subscriber.trade({}, function (trade) { return refresh; }, $scope);
        this.loadMarkets();
        var interval = $interval(function () {
            _this.loadMarkets();
        }, 20 * 1000, 0, false);
        $scope.$on('$destroy', function () { $interval.cancel(interval); });
    }
    ArdorTraderMarketsComponent.prototype.loadMarkets = function () {
        var _this = this;
        this.ardorBlockExplorerService.getAllAssets().then(function (assets) {
            _this.markets = assets;
            _this.markets.forEach(function (market) {
                market.currencyInfo = { symbol: market.name, name: market.name, description: market.description };
                market.assetInfo = { symbol: 'IGNIS' };
            });
        });
    };
    ArdorTraderMarketsComponent.prototype.isSpecialMarket = function (market) {
        return market.currency == '5592059897546023466' && market.asset == '0';
    };
    ArdorTraderMarketsComponent.prototype.compareMarketAlphabetical = function (a, b) {
        var currencyA = a['currencyInfo'];
        var assetA = a['assetInfo'];
        var currencyB = b['currencyInfo'];
        var assetB = b['assetInfo'];
        if (currencyA.symbol < currencyB.symbol)
            return -1;
        if (currencyA.symbol > currencyB.symbol)
            return 1;
        if (assetA.symbol < assetB.symbol)
            return -1;
        if (assetA.symbol > assetB.symbol)
            return 1;
        return 0;
    };
    ArdorTraderMarketsComponent.prototype.onFilterChange = function () {
        var _this = this;
        this.$scope.$evalAsync(function () {
            _this.markets = [].concat(_this.markets);
        });
    };
    ArdorTraderMarketsComponent.prototype.filterFuncImpl = function (market) {
        if (this.filter) {
            var mask = this.filter.toUpperCase();
            if (!(market.currencyInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.assetInfo.symbol.toUpperCase().indexOf(mask) >= 0 ||
                market.currencyInfo.name.toUpperCase().indexOf(mask) >= 0 ||
                (market.currencyInfo.description !== null && market.currencyInfo.description.toUpperCase().indexOf(mask) >= 0))) {
                return false;
            }
        }
        return true;
    };
    ArdorTraderMarketsComponent = __decorate([
        Component({
            selector: 'ardorTraderMarkets',
            template: "\n    <div class=\"trader-component-title\" layout=\"row\">Markets&nbsp;\n      <span flex></span>\n      <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n    </div>\n    <input type=\"text\" placeholder=\"Search markets\" ng-model=\"vm.filter\" ng-change=\"vm.onFilterChange()\"></input>\n    <md-list flex layout-fill layout=\"column\">\n      <md-list-item>\n        <div class=\"truncate-col market-col\">Market</div>\n        <div class=\"truncate-col change-col\">Change</div>\n        <div class=\"truncate-col price-col\">Price</div>\n        <div class=\"truncate-col vol-col\" flex>Vol</div>\n      </md-list-item>\n      <md-virtual-repeat-container flex layout-fill layout=\"column\"\n          virtual-repeat-flex-helper ng-if=\"vm.markets.length>0\">\n        <md-list-item md-virtual-repeat=\"item in vm.markets | filter: vm.filterFunc\">\n          <div class=\"truncate-col market-col\">\n            <a href=\"#/ardor-trader/{{item.asset}}/ardor\">\n              <span ng-class=\"{certified:item.currencyInfo.certified}\">{{item.currencyInfo.symbol}}</span>/<span ng-class=\"{certified:item.assetInfo.certified}\">{{item.assetInfo.symbol}}</span>\n            </a>\n          </div>\n          <div class=\"truncate-col change-col\">{{item.change}}</div>\n          <div class=\"truncate-col price-col\">{{item.price}}</div>\n          <div class=\"truncate-col vol-col right-align\" flex>{{ item.vol }}</div>\n        </md-list-item>\n      </md-virtual-repeat-container>\n    </md-list>\n  "
        }),
        Inject('$scope', 'heat', 'ardorAssetInfo', 'storage', '$q', '$mdToast', '$interval', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, HeatService,
            ArdorAssetInfoService,
            StorageService, Function, Object, Function, ArdorBlockExplorerService])
    ], ArdorTraderMarketsComponent);
    return ArdorTraderMarketsComponent;
}());
var ArdorTraderOrdersBuyComponent = (function (_super) {
    __extends(ArdorTraderOrdersBuyComponent, _super);
    function ArdorTraderOrdersBuyComponent($scope, $rootScope, ordersProviderFactory, $q, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        _this.currencyBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var sum_1 = 0;
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, false), function (order, context) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.unconfirmedQuantity = order.quantity;
                    order.priceDisplay = utils.formatQNT(order.price, _this.assetInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    sum_1 += parseFloat(totalQNT);
                    order.sum = utils.formatQNT(sum_1.toString(), _this.currencyInfo.decimals);
                    _this.orders.push(order);
                });
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateCurrencyBalance();
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateCurrencyBalance), 2000, false);
        $scope.$on('balance', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var balance = parseFloat(opts.balance);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += parseInt(_this.orders[i].quantity);
                if (totalQuantity >= balance) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var total = balance * (price);
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    ArdorTraderOrdersBuyComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('total', { total: this.currencyBalance });
    };
    ArdorTraderOrdersBuyComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    ArdorTraderOrdersBuyComponent.prototype.updateCurrencyBalance = function () {
        var _this = this;
        this.ardorBlockExplorerService.getAccountAssets(this.user.account).then(function (assetBalances) {
            assetBalances.forEach(function (assetBalance) {
                if (assetBalance.asset === _this.currencyInfo.id)
                    _this.currencyBalance = utils.formatQNT(assetBalance.quantityQNT, _this.currencyInfo.decimals);
            });
        }), function () {
            _this.currencyBalance = "0";
        };
    };
    ArdorTraderOrdersBuyComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersBuy',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"popover.html\">\n      <div class=\"account-popover\">\n        {{item.account||item.accountName}}\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Buyers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.currencyBalance}}&nbsp;{{vm.currencyInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper  class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popover.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\",\n              >\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ardorOrdersProviderFactory', '$q', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Object, ArdorOrdersProviderFactory, Function, UserService,
            ArdorBlockExplorerService])
    ], ArdorTraderOrdersBuyComponent);
    return ArdorTraderOrdersBuyComponent;
}(VirtualRepeatComponent));
var ArdorTraderOrdersMyComponent = (function (_super) {
    __extends(ArdorTraderOrdersMyComponent, _super);
    function ArdorTraderOrdersMyComponent($scope, ordersProviderFactory, $q, user, settings, cancelBidOrder, cancelAskOrder) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.cancelBidOrder = cancelBidOrder;
        _this.cancelAskOrder = cancelAskOrder;
        var format = settings.get(SettingsService.DATEFORMAT_DEFAULT);
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, user.account), function (order) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.typeDisplay = order.type == 'ask' ? 'Sell' : 'Buy';
                    order.market = _this.currencyInfo.symbol + '/' + _this.assetInfo.symbol;
                    order.quantityDisplay = utils.formatQNT(order.quantity, _this.assetInfo.decimals);
                    order.priceDisplay = utils.formatQNT(order.price, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.quantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    var date = utils.timestampToDate(order.expiration);
                    order.expires = dateFormat(date, format);
                });
                unregister.forEach(function (fn) { return fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 1000, false);
        return _this;
    }
    ArdorTraderOrdersMyComponent.prototype.onSelect = function (item) { };
    ArdorTraderOrdersMyComponent.prototype.cancelOrder = function (order) {
        var dialog = order.type == 'ask' ?
            this.cancelAskOrder.dialog(order.order) :
            this.cancelBidOrder.dialog(order.order);
        if (this.oneClickOrders)
            dialog.send();
        else
            dialog.show();
    };
    ArdorTraderOrdersMyComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersMy',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.user.unlocked?'My':'All'}} pending orders&nbsp;\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col market-col\">Market</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col total-col\">Total ({{vm.currencyInfo.symbol}})</div>\n          <div class=\"truncate-col expires-col\" flex>Expires</div>\n          <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\"></div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\"\n              ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n            <div class=\"truncate-col type-col\">{{item.typeDisplay}}</div>\n            <div class=\"truncate-col market-col\">{{item.market}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col expires-col\" flex tooltip=\"{{item.expires}}\">{{item.expires}}</div>\n            <div class=\"truncate-col cancel-col\" layout=\"row\" layout-align=\"end\" ng-if=\"vm.user.unlocked\">\n              <a ng-if=\"!item.cancelled && !item.unconfirmed\" ng-click=\"vm.cancelOrder(item)\">Cancel</a>\n            </div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', 'ardorOrdersProviderFactory', '$q', 'user', 'settings', 'cancelBidOrder', 'cancelAskOrder'),
        __metadata("design:paramtypes", [Object, ArdorOrdersProviderFactory, Function, UserService,
            SettingsService,
            CancelBidOrderService,
            CancelAskOrderService])
    ], ArdorTraderOrdersMyComponent);
    return ArdorTraderOrdersMyComponent;
}(VirtualRepeatComponent));
var ArdorTraderOrdersSellComponent = (function (_super) {
    __extends(ArdorTraderOrdersSellComponent, _super);
    function ArdorTraderOrdersSellComponent($scope, $rootScope, ordersProviderFactory, $q, user, ardorBlockExplorerService) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$rootScope = $rootScope;
        _this.ordersProviderFactory = ordersProviderFactory;
        _this.user = user;
        _this.ardorBlockExplorerService = ardorBlockExplorerService;
        _this.assetBalance = "*";
        _this.PAGE_SIZE = 100;
        _this.orders = [];
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                var sum_2 = 0;
                _this.initializeVirtualRepeat(_this.ordersProviderFactory.createProvider(_this.currencyInfo.id, _this.assetInfo.id, null, true), function (order, context) {
                    order.price = order.priceNQTPerShare;
                    order.quantity = order.quantityQNT;
                    order.unconfirmedQuantity = order.quantity;
                    order.priceDisplay = utils.formatQNT(order.price, _this.assetInfo.decimals);
                    order.quantityDisplay = utils.formatQNT(order.unconfirmedQuantity, _this.currencyInfo.decimals);
                    var totalQNT = utils.calculateTotalOrderPriceQNT(order.unconfirmedQuantity, order.price);
                    order.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
                    sum_2 += parseFloat(totalQNT);
                    order.sum = utils.formatQNT(sum_2.toString(), _this.currencyInfo.decimals);
                    _this.orders.push(order);
                });
                unregister.forEach(function (fn) { return fn(); });
                if (_this.user.unlocked) {
                    _this.updateAssetBalance();
                }
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        _this.refreshGrid = utils.debounce(angular.bind(_this, _this.determineLength), 2000, false);
        _this.refreshBalance = utils.debounce(angular.bind(_this, _this.updateAssetBalance), 2000, false);
        $scope.$on('total', function (event, opts) {
            var price = parseInt(_this.orders[0].price);
            var totalQuantity = 0;
            var total = parseFloat(opts.total);
            for (var i = 0; i < _this.orders.length; i++) {
                totalQuantity += (parseFloat(_this.orders[i].quantity) / 100000000);
                if (totalQuantity >= total) {
                    price = parseInt(_this.orders[i].price);
                    break;
                }
            }
            price = price / 100000000;
            var balance = total / price;
            _this.$rootScope.$broadcast('price', { price: price, balance: balance, total: total });
        });
        return _this;
    }
    ArdorTraderOrdersSellComponent.prototype.broadcast = function () {
        this.$rootScope.$broadcast('balance', { balance: this.assetBalance });
    };
    ArdorTraderOrdersSellComponent.prototype.onSelect = function (selectedOrder) {
        this.selectedOrder = selectedOrder;
    };
    ArdorTraderOrdersSellComponent.prototype.updateAssetBalance = function () {
        var _this = this;
        this.ardorBlockExplorerService.getBalance(this.user.account, 2).then(function (balance) {
            _this.assetBalance = utils.formatQNT(balance, _this.assetInfo.decimals);
        }), function () {
            _this.assetBalance = "0";
        };
    };
    ArdorTraderOrdersSellComponent = __decorate([
        Component({
            selector: 'ardorTraderOrdersSell',
            inputs: ['currencyInfo', 'assetInfo', 'selectedOrder'],
            template: "\n    <script type=\"text/ng-template\" id=\"templateId.tml\">\n      <div class=\"account-popover\">\n        {{item.account||item.accountName}}\n      </div>\n    </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">{{vm.assetInfo.symbol}} Sellers&nbsp;\n        <span flex></span>\n        <span class=\"balance clickable-text\" ng-click=\"vm.broadcast()\" ng-if=\"vm.user.unlocked\">BALANCE: {{vm.assetBalance}}&nbsp;{{vm.assetInfo.symbol}}</span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item  class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">Quantity</div>\n          <div class=\"truncate-col total-col\">Total</div>\n          <div class=\"truncate-col sum-col\">Sum ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper class=\"content\">\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand\n               ng-click=\"vm.select(item)\" aria-label=\"Entry\"\n               ng-class=\"{'virtual': item.unconfirmed, 'currentlyNotValid': item.currentlyNotValid||item.cancelled}\">\n           <div class=\"truncate-col info-col\">\n             <div\n              class=\"info\"\n              angular-popover\n              direction=\"right\"\n              template-url=\"templateId.tml\"\n              mode=\"mouseover\"\n              style=\"position: absolute;\">\n             </div>\n             <img src=\"assets/info.png\">\n           </div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\">{{item.total}}</div>\n            <div class=\"truncate-col sum-col\">{{item.sum}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$rootScope', 'ardorOrdersProviderFactory', '$q', 'user', 'ardorBlockExplorerService'),
        __metadata("design:paramtypes", [Object, Object, ArdorOrdersProviderFactory, Function, UserService,
            ArdorBlockExplorerService])
    ], ArdorTraderOrdersSellComponent);
    return ArdorTraderOrdersSellComponent;
}(VirtualRepeatComponent));
var ArdorTraderTradeHistoryComponent = (function (_super) {
    __extends(ArdorTraderTradeHistoryComponent, _super);
    function ArdorTraderTradeHistoryComponent($scope, $window, tradesProviderFactory, $q, user, settings) {
        var _this = _super.call(this, $scope, $q) || this;
        _this.$scope = $scope;
        _this.$window = $window;
        _this.tradesProviderFactory = tradesProviderFactory;
        _this.user = user;
        _this.settings = settings;
        _this.showTheseTrades = "all";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                _this.createProvider();
                unregister.forEach(function (fn) { return fn(); });
                angular.element($window).bind('resize', function () { return _this.onResize(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
        return _this;
    }
    ArdorTraderTradeHistoryComponent.prototype.createProvider = function () {
        var _this = this;
        var format = this.settings.get(SettingsService.DATEFORMAT_DEFAULT);
        if (this.$window.innerWidth < 870) {
            format = this.settings.get(SettingsService.TIMEFORMAT_DEFAULT);
        }
        var account = this.showTheseTrades == 'all' ? null : this.user.account;
        this.initializeVirtualRepeat(this.tradesProviderFactory.createProvider(this.currencyInfo.id, this.assetInfo.id, account), function (trade) {
            var date = utils.ardorTimestampToDate(trade.timestamp);
            trade.time = dateFormat(date, format);
            if (account) {
                trade.type = trade.seller == account ? 'Sell' : 'Buy';
            }
            else {
                trade.type = trade.isBuy ? 'Buy' : 'Sell';
            }
            trade.price = trade.priceNQTPerShare;
            trade.quantity = trade.quantityQNT;
            trade.priceDisplay = utils.formatQNT(trade.price, _this.assetInfo.decimals);
            trade.quantityDisplay = utils.formatQNT(trade.quantity, _this.currencyInfo.decimals);
            var totalQNT = utils.calculateTotalOrderPriceQNT(trade.quantity, trade.price);
            trade.total = utils.formatQNT(totalQNT, _this.currencyInfo.decimals);
            trade.virtual = trade.block == "0";
        });
    };
    ArdorTraderTradeHistoryComponent.prototype.onSelect = function (item) { };
    ArdorTraderTradeHistoryComponent.prototype.updateView = function () {
        if (this.currencyInfo && this.assetInfo) {
            this.createProvider();
        }
    };
    ArdorTraderTradeHistoryComponent.prototype.onResize = function () {
        this.updateView();
    };
    ArdorTraderTradeHistoryComponent = __decorate([
        Component({
            selector: 'ardorTraderTradeHistory',
            inputs: ['currencyInfo', 'assetInfo', 'oneClickOrders'],
            template: "\n  <script type=\"text/ng-template\" id=\"popoverHistory.html\">\n    <div class=\"account-popover\">\n      <div>Buyer: {{item.buyerName||item.buyer}}</div>\n      <div>Seller: {{item.sellerName||item.seller}}</div>\n    </div>\n  </script>\n    <div layout=\"column\" flex layout-fill>\n      <div layout=\"row\" class=\"trader-component-title\">Past trades&nbsp;\n        <span flex></span>\n        <span layout=\"row\" ng-if=\"vm.user.unlocked\" class=\"selector\">\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"all\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show all trades</i>\n          </label>\n          <label>\n            <input type=\"radio\" name=\"trader-show-trades\" value=\"my\" ng-model=\"vm.showTheseTrades\" ng-change=\"vm.updateView()\">\n            <i>Show my trades</i>\n          </label>\n        </span>\n        <elipses-loading ng-show=\"vm.loading\"></elipses-loading>\n      </div>\n      <md-list flex layout-fill layout=\"column\" ng-if=\"vm.currencyInfo&&vm.assetInfo\">\n        <md-list-item class=\"header\">\n          <div class=\"truncate-col info-col\"></div>\n          <div class=\"truncate-col type-col\">Type</div>\n          <div class=\"truncate-col time-col\" flex>Time</div>\n          <div class=\"truncate-col price-col\">Price</div>\n          <div class=\"truncate-col quantity-col\">{{vm.assetInfo.symbol}}</div>\n          <div class=\"truncate-col total-col\" flex>Total ({{vm.currencyInfo.symbol}})</div>\n        </md-list-item>\n        <md-virtual-repeat-container md-top-index=\"vm.topIndex\" flex layout-fill layout=\"column\" virtual-repeat-flex-helper>\n          <md-list-item md-virtual-repeat=\"item in vm\" md-on-demand aria-label=\"Entry\" ng-class=\"{'virtual': item.virtual}\">\n            <div class=\"truncate-col info-col\">\n              <div\n                class=\"info\"\n                angular-popover\n                direction=\"right\"\n                template-url=\"popoverHistory.html\"\n                mode=\"mouseover\"\n                style=\"position: absolute;\">\n              </div>\n              <img src=\"assets/info.png\">\n            </div>\n            <div class=\"truncate-col type-col\">{{item.type}}</div>\n            <div class=\"truncate-col time-col\" flex>{{item.time}}</div>\n            <div class=\"truncate-col price-col\">{{item.priceDisplay}}</div>\n            <div class=\"truncate-col quantity-col\">{{item.quantityDisplay}}</div>\n            <div class=\"truncate-col total-col\" flex>{{item.total}}</div>\n          </md-list-item>\n        </md-virtual-repeat-container>\n      </md-list>\n    </div>\n  "
        }),
        Inject('$scope', '$window', 'ardorTradesProviderFactory', '$q', 'user', 'settings'),
        __metadata("design:paramtypes", [Object, Object, ArdorTradesProviderFactory, Function, UserService,
            SettingsService])
    ], ArdorTraderTradeHistoryComponent);
    return ArdorTraderTradeHistoryComponent;
}(VirtualRepeatComponent));
var ArdorTraderComponent = (function () {
    function ArdorTraderComponent($scope, user, $timeout, assetInfoService, $mdSidenav) {
        var _this = this;
        this.$scope = $scope;
        this.user = user;
        this.$timeout = $timeout;
        this.assetInfoService = assetInfoService;
        this.$mdSidenav = $mdSidenav;
        this.marketCurrency = "0";
        this.marketSort = "change";
        this.marketAsc = "false";
        this.marketsSidenavOpen = true;
        this.marketsSidenavLockedOpen = true;
        this.toggleMarkets = function () {
            var sidenav = _this.$mdSidenav("trader-markets-sidenav");
            if (sidenav.isOpen()) {
                _this.marketsSidenavLockedOpen = false;
                sidenav.close();
            }
            else {
                _this.marketsSidenavLockedOpen = true;
                sidenav.open();
            }
        };
        assetInfoService.getInfo(this.currency).then(function (info) {
            $scope.$evalAsync(function () {
                _this.currencyInfo = info;
            });
        });
        assetInfoService.getInfo(this.asset).then(function (info) {
            $scope.$evalAsync(function () {
                _this.assetInfo = info;
            });
        });
        this.user.account = user.account || "";
        var ready = function () {
            if (_this.currencyInfo && _this.assetInfo) {
                unregister.forEach(function (fn) { fn(); });
            }
        };
        var unregister = [$scope.$watch('vm.currencyInfo', ready), $scope.$watch('vm.assetInfo', ready)];
    }
    ArdorTraderComponent = __decorate([
        RouteConfig('/ardor-trader/:currency/:asset'),
        Component({
            selector: 'ardorTrader',
            inputs: ['currency', 'asset'],
            template: "\n    <div layout=\"row\">\n      <!--\n      <div>\n        <md-button class=\"md-icon-button show-hide\" aria-label=\"Show/hide markets\" ng-click=\"vm.toggleMarkets()\">\n          <md-tooltip md-direction=\"bottom\">Show/Hide markets</md-tooltip>\n          <i><img src=\"assets/{{vm.marketsSidenavOpen?'minusIcon':'plusIcon'}}.png\"></i>\n        </md-button>\n      </div>\n      -->\n      <span flex></span>\n      <trader-volume class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" layout=\"column\"></trader-volume>\n    </div>\n    <div layout=\"row\" flex layout-fill>\n      <md-sidenav class=\"md-sidenav-left\" md-component-id=\"trader-markets-sidenav\"\n          md-is-locked-open=\"vm.marketsSidenavLockedOpen\" md-is-open=\"vm.marketsSidenavOpen\"\n          md-disable-backdrop flex layout-fill>\n        <div class=\"sidenav-container\">\n          <ardor-trader-balances currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\" ng-if=\"vm.user.unlocked\"></ardor-trader-balances>\n          <ardor-trader-markets></ardor-trader-markets>\n        </div>\n      </md-sidenav>\n      <div layout=\"column\" flex layout-fill class=\"main-display\">\n        <div>\n          <div class=\"trader-row top\">\n              <ardor-trader-info class=\"trader-component\" toggle-markets=\"vm.toggleMarkets\" markets-sidenav-open=\"vm.marketsSidenavOpen\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-info>\n              <trader-chart class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></trader-chart>\n          </div>\n          <div class=\"trader-row middle\">\n            <ardor-trader-orders-buy class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-orders-buy>\n            <ardor-trader-quick-buy-sell class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-quick-buy-sell>\n            <ardor-trader-orders-sell class=\"trader-component\" selected-order=\"vm.selectedOrder\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"l></ardor-trader-orders-sell>\n          </div>\n          <div class=\"trader-row bottom\">\n            <ardor-trader-trade-history class=\"trader-component\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-trade-history>\n            <ardor-trader-orders-my ng-if=\"vm.user.unlocked\" class=\"trader-component\" one-click-orders=\"vm.oneClickOrders\" currency-info=\"vm.currencyInfo\" asset-info=\"vm.assetInfo\"></ardor-trader-orders-my>\n          </div>\n        </div>\n      </div>\n    </div>\n  "
        }),
        Inject('$scope', 'user', '$timeout', 'ardorAssetInfo', '$mdSidenav'),
        __metadata("design:paramtypes", [Object, UserService, Function, ArdorAssetInfoService, Function])
    ], ArdorTraderComponent);
    return ArdorTraderComponent;
}());
var ArdorOrdersProviderFactory = (function () {
    function ArdorOrdersProviderFactory(ardorBlockExplorerService, $q) {
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorOrdersProviderFactory.prototype.createProvider = function (currency, asset, account, isAsk) {
        return new ArdorOrdersProvider(currency, asset, account, isAsk, this.ardorBlockExplorerService, this.$q);
    };
    ArdorOrdersProviderFactory = __decorate([
        Service('ardorOrdersProviderFactory'),
        Inject('ardorBlockExplorerService', '$q'),
        __metadata("design:paramtypes", [ArdorBlockExplorerService, Function])
    ], ArdorOrdersProviderFactory);
    return ArdorOrdersProviderFactory;
}());
var ArdorOrdersProvider = (function () {
    function ArdorOrdersProvider(currency, asset, account, isAsk, ardorBlockExplorerService, $q) {
        this.currency = currency;
        this.asset = asset;
        this.account = account;
        this.isAsk = isAsk;
        this.ardorBlockExplorerService = ardorBlockExplorerService;
        this.$q = $q;
    }
    ArdorOrdersProvider.prototype.getPaginatedLength = function () {
        if (this.account) {
            return this.ardorBlockExplorerService.getMyPendingOrdersCount(this.account, this.currency);
        }
        else if (this.isAsk) {
            return this.ardorBlockExplorerService.getAskOrdersCount(this.currency);
        }
        return this.ardorBlockExplorerService.getBidOrdersCount(this.currency);
    };
    ArdorOrdersProvider.prototype.getPaginatedResults = function (firstIndex, lastIndex) {
        if (this.account) {
            return this.ardorBlockExplorerService.getMyPendingOrders(this.account, this.currency, firstIndex, lastIndex);
        }
        else if (this.isAsk) {
            return this.ardorBlockExplorerService.getAskOrders(this.currency, firstIndex, lastIndex);
        }
        return this.ardorBlockExplorerService.getBidOrders(this.currency, firstIndex, lastIndex);
    };
    return ArdorOrdersProvider;
}());

//# sourceMappingURL=../dist/maps/heat-ui-hI3ldb.js.map
